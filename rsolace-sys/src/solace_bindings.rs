/* automatically generated by rust-bindgen 0.65.1 */

pub const SOLCLIENT_FD_EVENT_READ: u32 = 1;
pub const SOLCLIENT_FD_EVENT_WRITE: u32 = 2;
pub const SOLCLIENT_FD_EVENT_ALL: u32 = 3;
pub const SOLCLIENT_COS_1: u32 = 0;
pub const SOLCLIENT_COS_2: u32 = 1;
pub const SOLCLIENT_COS_3: u32 = 2;
pub const SOLCLIENT_DELIVERY_MODE_DIRECT: u32 = 0;
pub const SOLCLIENT_DELIVERY_MODE_PERSISTENT: u32 = 16;
pub const SOLCLIENT_DELIVERY_MODE_NONPERSISTENT: u32 = 32;
pub const SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM: u32 = 2;
pub const SOLCLIENT_SUBSCRIBE_FLAGS_LOCAL_DISPATCH_ONLY: u32 = 8;
pub const SOLCLIENT_SUBSCRIBE_FLAGS_REQUEST_CONFIRM: u32 = 16;
pub const SOLCLIENT_MODIFYPROP_FLAGS_WAITFORCONFIRM: u32 = 1;
pub const SOLCLIENT_UUID_STRING_BUFFER_SIZE: u32 = 37;
pub const SOLCLIENT_SESSION_PROP_ACK_EVENT_MODE_PER_MSG: &[u8; 31usize] =
    b"SESSION_ACK_EVENT_MODE_PER_MSG\0";
pub const SOLCLIENT_SESSION_PROP_ACK_EVENT_MODE_WINDOWED: &[u8; 32usize] =
    b"SESSION_ACK_EVENT_MODE_WINDOWED\0";
pub const SOLCLIENT_PROP_ENABLE_VAL: &[u8; 2usize] = b"1\0";
pub const SOLCLIENT_PROP_DISABLE_VAL: &[u8; 2usize] = b"0\0";
pub const SOLCLIENT_GLOBAL_PROP_DBQUANTASIZE_0: &[u8; 23usize] = b"GLOBAL_DBQUANTA_SIZE_0\0";
pub const SOLCLIENT_GLOBAL_PROP_DBQUANTASIZE_1: &[u8; 23usize] = b"GLOBAL_DBQUANTA_SIZE_1\0";
pub const SOLCLIENT_GLOBAL_PROP_DBQUANTASIZE_2: &[u8; 23usize] = b"GLOBAL_DBQUANTA_SIZE_2\0";
pub const SOLCLIENT_GLOBAL_PROP_DBQUANTASIZE_3: &[u8; 23usize] = b"GLOBAL_DBQUANTA_SIZE_3\0";
pub const SOLCLIENT_GLOBAL_PROP_DBQUANTASIZE_4: &[u8; 23usize] = b"GLOBAL_DBQUANTA_SIZE_4\0";
pub const SOLCLIENT_GLOBAL_PROP_MAXPOOLMEM: &[u8; 18usize] = b"GLOBAL_MAXPOOLMEM\0";
pub const SOLCLIENT_GLOBAL_PROP_GSS_KRB_LIB: &[u8; 19usize] = b"GLOBAL_GSS_KRB_LIB\0";
pub const SOLCLIENT_GLOBAL_PROP_IBM_CODESET: &[u8; 19usize] = b"GLOBAL_IBM_CODESET\0";
pub const SOLCLIENT_GLOBAL_PROP_SSL_LIB: &[u8; 15usize] = b"GLOBAL_SSL_LIB\0";
pub const SOLCLIENT_GLOBAL_PROP_CRYPTO_LIB: &[u8; 18usize] = b"GLOBAL_CRYPTO_LIB\0";
pub const SOLCLIENT_GLOBAL_PROP_DEFAULT_DBQUANTASIZE_0: &[u8; 6usize] = b"10240\0";
pub const SOLCLIENT_GLOBAL_PROP_DEFAULT_DBQUANTASIZE_1: &[u8; 6usize] = b"32768\0";
pub const SOLCLIENT_GLOBAL_PROP_DEFAULT_DBQUANTASIZE_2: &[u8; 6usize] = b"65536\0";
pub const SOLCLIENT_GLOBAL_PROP_DEFAULT_DBQUANTASIZE_3: &[u8; 7usize] = b"262144\0";
pub const SOLCLIENT_GLOBAL_PROP_DEFAULT_DBQUANTASIZE_4: &[u8; 8usize] = b"1048576\0";
pub const SOLCLIENT_GLOBAL_PROP_DEFAULT_MAXPOOLMEM: &[u8; 11usize] = b"1073741824\0";
pub const SOLCLIENT_GLOBAL_PROP_DEFAULT_GSS_KRB_LIB_LINUX: &[u8; 20usize] =
    b"libgssapi_krb5.so.2\0";
pub const SOLCLIENT_GLOBAL_PROP_DEFAULT_GSS_KRB_LIB_SOLARIS: &[u8; 15usize] = b"mech_krb5.so.1\0";
pub const SOLCLIENT_GLOBAL_PROP_DEFAULT_GSS_KRB_LIB_WINDOWS: &[u8; 12usize] = b"secur32.dll\0";
pub const SOLCLIENT_GLOBAL_PROP_DEFAULT_GSS_KRB_LIB_AIX: &[u8; 38usize] =
    b"libgssapi_krb5.a(libgssapi_krb5.a.so)\0";
pub const SOLCLIENT_GLOBAL_PROP_DEFAULT_IBM_CODESET: &[u8; 18usize] = b"TPF_CCSID_IBM1047\0";
pub const SOLCLIENT_GLOBAL_PROP_DEFAULT_SSL_LIB_UNIX: &[u8; 10usize] = b"libssl.so\0";
pub const SOLCLIENT_GLOBAL_PROP_DEFAULT_SSL_LIB_MACOSX: &[u8; 17usize] = b"libssl.1.1.dylib\0";
pub const SOLCLIENT_GLOBAL_PROP_DEFAULT_SSL_LIB_VMS: &[u8; 20usize] = b"SSL1$LIBSSL_SHR.EXE\0";
pub const SOLCLIENT_GLOBAL_PROP_DEFAULT_SSL_LIB_WINDOWS: &[u8; 15usize] = b"libssl-1_1.dll\0";
pub const SOLCLIENT_GLOBAL_PROP_DEFAULT_CRYPTO_LIB_UNIX: &[u8; 13usize] = b"libcrypto.so\0";
pub const SOLCLIENT_GLOBAL_PROP_DEFAULT_CRYPTO_LIB_MACOSX: &[u8; 20usize] =
    b"libcrypto.1.1.dylib\0";
pub const SOLCLIENT_GLOBAL_PROP_DEFAULT_CRYPTO_LIB_VMS: &[u8; 23usize] =
    b"SSL1$LIBCRYPTO_SHR.EXE\0";
pub const SOLCLIENT_GLOBAL_PROP_DEFAULT_CRYPTO_LIB_WINDOWS: &[u8; 18usize] = b"libcrypto-1_1.dll\0";
pub const SOLCLIENT_CONTEXT_PROP_TIME_RES_MS: &[u8; 20usize] = b"CONTEXT_TIME_RES_MS\0";
pub const SOLCLIENT_CONTEXT_PROP_CREATE_THREAD: &[u8; 22usize] = b"CONTEXT_CREATE_THREAD\0";
pub const SOLCLIENT_CONTEXT_PROP_THREAD_AFFINITY: &[u8; 24usize] = b"CONTEXT_THREAD_AFFINITY\0";
pub const SOLCLIENT_CONTEXT_PROP_DEFAULT_TIME_RES_MS: &[u8; 3usize] = b"50\0";
pub const SOLCLIENT_CONTEXT_PROP_DEFAULT_CREATE_THREAD: &[u8; 2usize] = b"0\0";
pub const SOLCLIENT_CONTEXT_PROP_DEFAULT_THREAD_AFFINITY: &[u8; 2usize] = b"0\0";
pub const SOLCLIENT_SESSION_PROP_USERNAME: &[u8; 17usize] = b"SESSION_USERNAME\0";
pub const SOLCLIENT_SESSION_PROP_PASSWORD: &[u8; 17usize] = b"SESSION_PASSWORD\0";
pub const SOLCLIENT_SESSION_PROP_HOST: &[u8; 13usize] = b"SESSION_HOST\0";
pub const SOLCLIENT_SESSION_PROP_PORT: &[u8; 13usize] = b"SESSION_PORT\0";
pub const SOLCLIENT_SESSION_PROP_BUFFER_SIZE: &[u8; 20usize] = b"SESSION_BUFFER_SIZE\0";
pub const SOLCLIENT_SESSION_PROP_CONNECT_BLOCKING: &[u8; 25usize] = b"SESSION_CONNECT_BLOCKING\0";
pub const SOLCLIENT_SESSION_PROP_SEND_BLOCKING: &[u8; 22usize] = b"SESSION_SEND_BLOCKING\0";
pub const SOLCLIENT_SESSION_PROP_SUBSCRIBE_BLOCKING: &[u8; 27usize] =
    b"SESSION_SUBSCRIBE_BLOCKING\0";
pub const SOLCLIENT_SESSION_PROP_BLOCK_WHILE_CONNECTING: &[u8; 31usize] =
    b"SESSION_BLOCK_WHILE_CONNECTING\0";
pub const SOLCLIENT_SESSION_PROP_BLOCKING_WRITE_TIMEOUT_MS: &[u8; 25usize] =
    b"SESSION_WRITE_TIMEOUT_MS\0";
pub const SOLCLIENT_SESSION_PROP_CONNECT_TIMEOUT_MS: &[u8; 27usize] =
    b"SESSION_CONNECT_TIMEOUT_MS\0";
pub const SOLCLIENT_SESSION_PROP_SUBCONFIRM_TIMEOUT_MS: &[u8; 30usize] =
    b"SESSION_SUBCONFIRM_TIMEOUT_MS\0";
pub const SOLCLIENT_SESSION_PROP_IGNORE_DUP_SUBSCRIPTION_ERROR: &[u8; 38usize] =
    b"SESSION_IGNORE_DUP_SUBSCRIPTION_ERROR\0";
pub const SOLCLIENT_SESSION_PROP_TCP_NODELAY: &[u8; 20usize] = b"SESSION_TCP_NODELAY\0";
pub const SOLCLIENT_SESSION_PROP_SOCKET_SEND_BUF_SIZE: &[u8; 29usize] =
    b"SESSION_SOCKET_SEND_BUF_SIZE\0";
pub const SOLCLIENT_SESSION_PROP_SOCKET_RCV_BUF_SIZE: &[u8; 28usize] =
    b"SESSION_SOCKET_RCV_BUF_SIZE\0";
pub const SOLCLIENT_SESSION_PROP_KEEP_ALIVE_INT_MS: &[u8; 31usize] =
    b"SESSION_KEEP_ALIVE_INTERVAL_MS\0";
pub const SOLCLIENT_SESSION_PROP_KEEP_ALIVE_LIMIT: &[u8; 25usize] = b"SESSION_KEEP_ALIVE_LIMIT\0";
pub const SOLCLIENT_SESSION_PROP_APPLICATION_DESCRIPTION: &[u8; 32usize] =
    b"SESSION_APPLICATION_DESCRIPTION\0";
pub const SOLCLIENT_SESSION_PROP_CLIENT_MODE: &[u8; 20usize] = b"SESSION_CLIENT_MODE\0";
pub const SOLCLIENT_SESSION_PROP_BIND_IP: &[u8; 16usize] = b"SESSION_BIND_IP\0";
pub const SOLCLIENT_SESSION_PROP_PUB_WINDOW_SIZE: &[u8; 24usize] = b"SESSION_PUB_WINDOW_SIZE\0";
pub const SOLCLIENT_SESSION_PROP_PUB_ACK_TIMER: &[u8; 22usize] = b"SESSION_PUB_ACK_TIMER\0";
pub const SOLCLIENT_SESSION_PROP_VPN_NAME: &[u8; 17usize] = b"SESSION_VPN_NAME\0";
pub const SOLCLIENT_SESSION_PROP_VPN_NAME_IN_USE: &[u8; 24usize] = b"SESSION_VPN_NAME_IN_USE\0";
pub const SOLCLIENT_SESSION_PROP_CLIENT_NAME: &[u8; 20usize] = b"SESSION_CLIENT_NAME\0";
pub const SOLCLIENT_SESSION_PROP_COMPRESSION_LEVEL: &[u8; 26usize] = b"SESSION_COMPRESSION_LEVEL\0";
pub const SOLCLIENT_SESSION_PROP_GENERATE_RCV_TIMESTAMPS: &[u8; 22usize] =
    b"SESSION_RCV_TIMESTAMP\0";
pub const SOLCLIENT_SESSION_PROP_GENERATE_SEND_TIMESTAMPS: &[u8; 23usize] =
    b"SESSION_SEND_TIMESTAMP\0";
pub const SOLCLIENT_SESSION_PROP_GENERATE_SENDER_ID: &[u8; 23usize] = b"SESSION_SEND_SENDER_ID\0";
pub const SOLCLIENT_SESSION_PROP_GENERATE_SEQUENCE_NUMBER: &[u8; 29usize] =
    b"SESSION_SEND_SEQUENCE_NUMBER\0";
pub const SOLCLIENT_SESSION_PROP_CONNECT_RETRIES_PER_HOST: &[u8; 33usize] =
    b"SESSION_CONNECT_RETRIES_PER_HOST\0";
pub const SOLCLIENT_SESSION_PROP_CONNECT_RETRIES: &[u8; 24usize] = b"SESSION_CONNECT_RETRIES\0";
pub const SOLCLIENT_SESSION_PROP_RECONNECT_RETRIES: &[u8; 26usize] = b"SESSION_RECONNECT_RETRIES\0";
pub const SOLCLIENT_SESSION_PROP_RECONNECT_RETRY_WAIT_MS: &[u8; 32usize] =
    b"SESSION_RECONNECT_RETRY_WAIT_MS\0";
pub const SOLCLIENT_SESSION_PROP_USER_ID: &[u8; 16usize] = b"SESSION_USER_ID\0";
pub const SOLCLIENT_SESSION_PROP_P2PINBOX_IN_USE: &[u8; 30usize] =
    b"SESSION_REPLY_TO_DEFAULT_DEST\0";
pub const SOLCLIENT_SESSION_PROP_REPLY_TO_DEFAULT_DEST: &[u8; 30usize] =
    b"SESSION_REPLY_TO_DEFAULT_DEST\0";
pub const SOLCLIENT_SESSION_PROP_REAPPLY_SUBSCRIPTIONS: &[u8; 30usize] =
    b"SESSION_REAPPLY_SUBSCRIPTIONS\0";
pub const SOLCLIENT_SESSION_PROP_TOPIC_DISPATCH: &[u8; 23usize] = b"SESSION_TOPIC_DISPATCH\0";
pub const SOLCLIENT_SESSION_PROP_PROVISION_TIMEOUT_MS: &[u8; 29usize] =
    b"SESSION_PROVISION_TIMEOUT_MS\0";
pub const SOLCLIENT_SESSION_PROP_CALCULATE_MESSAGE_EXPIRATION: &[u8; 37usize] =
    b"SESSION_CALCULATE_MESSAGE_EXPIRATION\0";
pub const SOLCLIENT_SESSION_PROP_VIRTUAL_ROUTER_NAME: &[u8; 28usize] =
    b"SESSION_VIRTUAL_ROUTER_NAME\0";
pub const SOLCLIENT_SESSION_PROP_NO_LOCAL: &[u8; 17usize] = b"SESSION_NO_LOCAL\0";
pub const SOLCLIENT_SESSION_PROP_AD_PUB_ROUTER_WINDOWED_ACK: &[u8; 35usize] =
    b"SESSION_AD_PUB_ROUTER_WINDOWED_ACK\0";
pub const SOLCLIENT_SESSION_PROP_MODIFYPROP_TIMEOUT_MS: &[u8; 30usize] =
    b"SESSION_MODIFYPROP_TIMEOUT_MS\0";
pub const SOLCLIENT_SESSION_PROP_ACK_EVENT_MODE: &[u8; 23usize] = b"SESSION_ACK_EVENT_MODE\0";
pub const SOLCLIENT_SESSION_PROP_SSL_EXCLUDED_PROTOCOLS: &[u8; 31usize] =
    b"SESSION_SSL_EXCLUDED_PROTOCOLS\0";
pub const SOLCLIENT_SESSION_PROP_SSL_VALIDATE_CERTIFICATE: &[u8; 33usize] =
    b"SESSION_SSL_VALIDATE_CERTIFICATE\0";
pub const SOLCLIENT_SESSION_PROP_OPENSSL_SECURITY_LEVEL: &[u8; 31usize] =
    b"SESSION_OPENSSL_SECURITY_LEVEL\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CLIENT_CERTIFICATE_FILE: &[u8; 36usize] =
    b"SESSION_SSL_CLIENT_CERTIFICATE_FILE\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CLIENT_PRIVATE_KEY_FILE: &[u8; 36usize] =
    b"SESSION_SSL_CLIENT_PRIVATE_KEY_FILE\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CLIENT_PRIVATE_KEY_FILE_PASSWORD: &[u8; 45usize] =
    b"SESSION_SSL_CLIENT_PRIVATE_KEY_FILE_PASSWORD\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CONNECTION_DOWNGRADE_TO: &[u8; 36usize] =
    b"SESSION_SSL_CONNECTION_DOWNGRADE_TO\0";
pub const SOLCLIENT_SESSION_PROP_INITIAL_RECEIVE_BUFFER_SIZE: &[u8; 36usize] =
    b"SESSION_INITIAL_RECEIVE_BUFFER_SIZE\0";
pub const SOLCLIENT_SESSION_PROP_AUTHENTICATION_SCHEME: &[u8; 30usize] =
    b"SESSION_AUTHENTICATION_SCHEME\0";
pub const SOLCLIENT_SESSION_PROP_KRB_SERVICE_NAME: &[u8; 25usize] = b"SESSION_KRB_SERVICE_NAME\0";
pub const SOLCLIENT_SESSION_PROP_UNBIND_FAIL_ACTION: &[u8; 27usize] =
    b"SESSION_UNBIND_FAIL_ACTION\0";
pub const SOLCLIENT_SESSION_PROP_WEB_TRANSPORT_PROTOCOL: &[u8; 31usize] =
    b"SESSION_WEB_TRANSPORT_PROTOCOL\0";
pub const SOLCLIENT_SESSION_PROP_WEB_TRANSPORT_PROTOCOL_IN_USE: &[u8; 38usize] =
    b"SESSION_WEB_TRANSPORT_PROTOCOL_IN_USE\0";
pub const SOLCLIENT_SESSION_PROP_WEB_TRANSPORT_PROTOCOL_LIST: &[u8; 36usize] =
    b"SESSION_WEB_TRANSPORT_PROTOCOL_LIST\0";
pub const SOLCLIENT_SESSION_PROP_TRANSPORT_PROTOCOL_DOWNGRADE_TIMEOUT_MS: &[u8; 48usize] =
    b"SESSION_TRANSPORT_PROTOCOL_DOWNGRADE_TIMEOUT_MS\0";
pub const SOLCLIENT_SESSION_PROP_GUARANTEED_WITH_WEB_TRANSPORT: &[u8; 38usize] =
    b"SESSION_GUARANTEED_WITH_WEB_TRANSPORT\0";
pub const SOLCLIENT_SESSION_PROP_GD_RECONNECT_FAIL_ACTION: &[u8; 33usize] =
    b"SESSION_GD_RECONNECT_FAIL_ACTION\0";
pub const SOLCLIENT_SESSION_PROP_OAUTH2_ACCESS_TOKEN: &[u8; 28usize] =
    b"SESSION_OAUTH2_ACCESS_TOKEN\0";
pub const SOLCLIENT_SESSION_PROP_OAUTH2_ISSUER_IDENTIFIER: &[u8; 33usize] =
    b"SESSION_OAUTH2_ISSUER_IDENTIFIER\0";
pub const SOLCLIENT_SESSION_PROP_OIDC_ID_TOKEN: &[u8; 22usize] = b"SESSION_OIDC_ID_TOKEN\0";
pub const SOLCLIENT_TRANSPORT_PROTOCOL_NULL: &[u8; 1usize] = b"\0";
pub const SOLCLIENT_TRANSPORT_PROTOCOL_WS_BINARY: &[u8; 10usize] = b"WS_BINARY\0";
pub const SOLCLIENT_TRANSPORT_PROTOCOL_HTTP_BINARY_STREAMING: &[u8; 22usize] =
    b"HTTP_BINARY_STREAMING\0";
pub const SOLCLIENT_TRANSPORT_PROTOCOL_HTTP_BINARY: &[u8; 12usize] = b"HTTP_BINARY\0";
pub const SOLCLIENT_TRANSPORT_PROTOCOL_PLAIN_TEXT: &[u8; 11usize] = b"PLAIN_TEXT\0";
pub const SOLCLIENT_SESSION_PROP_AUTHENTICATION_SCHEME_BASIC: &[u8; 28usize] =
    b"AUTHENTICATION_SCHEME_BASIC\0";
pub const SOLCLIENT_SESSION_PROP_AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE: &[u8; 41usize] =
    b"AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE\0";
pub const SOLCLIENT_SESSION_PROP_AUTHENTICATION_SCHEME_GSS_KRB: &[u8; 30usize] =
    b"AUTHENTICATION_SCHEME_GSS_KRB\0";
pub const SOLCLIENT_SESSION_PROP_AUTHENTICATION_SCHEME_OAUTH2: &[u8; 29usize] =
    b"AUTHENTICATION_SCHEME_OAUTH2\0";
pub const SOLCLIENT_SESSION_PROP_UNBIND_FAIL_ACTION_RETRY: &[u8; 25usize] =
    b"UNBIND_FAIL_ACTION_RETRY\0";
pub const SOLCLIENT_SESSION_PROP_UNBIND_FAIL_ACTION_DISCONNECT: &[u8; 30usize] =
    b"UNBIND_FAIL_ACTION_DISCONNECT\0";
pub const SOLCLIENT_SESSION_PROP_SSL_VALIDATE_CERTIFICATE_DATE: &[u8; 38usize] =
    b"SESSION_SSL_VALIDATE_CERTIFICATE_DATE\0";
pub const SOLCLIENT_SESSION_PROP_SSL_VALIDATE_CERTIFICATE_HOST: &[u8; 38usize] =
    b"SESSION_SSL_VALIDATE_CERTIFICATE_HOST\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_SUITES: &[u8; 26usize] = b"SESSION_SSL_CIPHER_SUITES\0";
pub const SOLCLIENT_SESSION_PROP_SSL_TRUST_STORE_DIR: &[u8; 28usize] =
    b"SESSION_SSL_TRUST_STORE_DIR\0";
pub const SOLCLIENT_SESSION_PROP_SSL_TRUSTED_COMMON_NAME_LIST: &[u8; 37usize] =
    b"SESSION_SSL_TRUSTED_COMMON_NAME_LIST\0";
pub const SOLCLIENT_SESSION_PROP_GD_RECONNECT_FAIL_ACTION_AUTO_RETRY: &[u8; 36usize] =
    b"GD_RECONNECT_FAIL_ACTION_AUTO_RETRY\0";
pub const SOLCLIENT_SESSION_PROP_GD_RECONNECT_FAIL_ACTION_DISCONNECT: &[u8; 36usize] =
    b"GD_RECONNECT_FAIL_ACTION_DISCONNECT\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_USERNAME: &[u8; 1usize] = b"\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_PASSWORD: &[u8; 1usize] = b"\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_HOST: &[u8; 10usize] = b"127.0.0.1\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_PORT: &[u8; 6usize] = b"55555\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_PORT_COMPRESSION: &[u8; 6usize] = b"55003\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_PORT_SSL: &[u8; 6usize] = b"55443\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_BUFFER_SIZE: &[u8; 6usize] = b"90000\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_CONNECT_BLOCKING: &[u8; 2usize] = b"1\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_SEND_BLOCKING: &[u8; 2usize] = b"1\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_SUBSCRIBE_BLOCKING: &[u8; 2usize] = b"1\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_BLOCK_WHILE_CONNECTING: &[u8; 2usize] = b"1\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_BLOCKING_WRITE_TIMEOUT_MS: &[u8; 7usize] = b"100000\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_CONNECT_TIMEOUT_MS: &[u8; 6usize] = b"30000\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_SUBCONFIRM_TIMEOUT_MS: &[u8; 6usize] = b"10000\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_IGNORE_DUP_SUBSCRIPTION_ERROR: &[u8; 2usize] = b"1\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_TCP_NODELAY: &[u8; 2usize] = b"1\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_SOCKET_SEND_BUF_SIZE: &[u8; 6usize] = b"90000\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_SOCKET_RCV_BUF_SIZE: &[u8; 7usize] = b"150000\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_KEEP_ALIVE_INT_MS: &[u8; 5usize] = b"3000\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_KEEP_ALIVE_LIMIT: &[u8; 2usize] = b"3\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_APPLICATION_DESCRIPTION: &[u8; 1usize] = b"\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_CLIENT_MODE: &[u8; 2usize] = b"0\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_BIND_IP: &[u8; 1usize] = b"\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_PUB_ACK_TIMER: &[u8; 5usize] = b"2000\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_PUB_WINDOW_SIZE: &[u8; 3usize] = b"50\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_VPN_NAME: &[u8; 1usize] = b"\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_CLIENT_NAME: &[u8; 1usize] = b"\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_SUBSCRIBER_LOCAL_PRIORITY: &[u8; 2usize] = b"1\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_SUBSCRIBER_NETWORK_PRIORITY: &[u8; 2usize] = b"1\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_COMPRESSION_LEVEL: &[u8; 2usize] = b"0\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_GENERATE_RCV_TIMESTAMPS: &[u8; 2usize] = b"0\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_GENERATE_SEND_TIMESTAMPS: &[u8; 2usize] = b"0\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_GENERATE_SENDER_ID: &[u8; 2usize] = b"0\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_GENERATE_SEQUENCE_NUMBER: &[u8; 2usize] = b"0\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_CONNECT_RETRIES_PER_HOST: &[u8; 2usize] = b"0\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_CONNECT_RETRIES: &[u8; 2usize] = b"0\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_RECONNECT_RETRIES: &[u8; 2usize] = b"0\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_RECONNECT_RETRY_WAIT_MS: &[u8; 5usize] = b"3000\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_REAPPLY_SUBSCRIPTIONS: &[u8; 2usize] = b"0\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_TOPIC_DISPATCH: &[u8; 2usize] = b"0\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_PROVISION_TIMEOUT_MS: &[u8; 5usize] = b"3000\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_MODIFYPROP_TIMEOUT_MS: &[u8; 6usize] = b"10000\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_CALCULATE_EXPIRATION_TIME: &[u8; 2usize] = b"0\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_NO_LOCAL: &[u8; 2usize] = b"0\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_AD_PUB_ROUTER_WINDOWED_ACK: &[u8; 2usize] = b"1\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_SSL_EXCLUDED_PROTOCOLS: &[u8; 1usize] = b"\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_SSL_VALIDATE_CERTIFICATE: &[u8; 2usize] = b"1\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_SSL_VALIDATE_CERTIFICATE_DATE: &[u8; 2usize] = b"1\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_SSL_VALIDATE_CERTIFICATE_HOST: &[u8; 2usize] = b"1\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_SSL_CIPHER_SUITES : & [u8 ; 284usize] = b"ECDHE-RSA-AES256-GCM-SHA384,ECDHE-RSA-AES256-SHA384,ECDHE-RSA-AES256-SHA,AES256-GCM-SHA384,AES256-SHA256,AES256-SHA,ECDHE-RSA-DES-CBC3-SHA,DES-CBC3-SHA,ECDHE-RSA-AES128-GCM-SHA256,ECDHE-RSA-AES128-SHA256,ECDHE-RSA-AES128-SHA,AES128-GCM-SHA256,AES128-SHA256,AES128-SHA,RC4-SHA,RC4-MD5\0" ;
pub const SOLCLIENT_SESSION_PROP_DEFAULT_INITIAL_RECEIVE_BUFFER_SIZE: &[u8; 2usize] = b"0\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_AUTHENTICATION_SCHEME: &[u8; 28usize] =
    b"AUTHENTICATION_SCHEME_BASIC\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_KRB_SERVICE_NAME: &[u8; 7usize] = b"solace\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_UNBIND_FAIL_ACTION: &[u8; 25usize] =
    b"UNBIND_FAIL_ACTION_RETRY\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_WEB_TRANSPORT_PROTOCOL: &[u8; 1usize] = b"\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_TRANSPORT_PROTOCOL_DOWNGRADE_TIMEOUT_MS: &[u8; 5usize] =
    b"3000\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_GUARANTEED_WITH_WEB_TRANSPORT: &[u8; 2usize] = b"0\0";
pub const SOLCLIENT_SESSION_PROP_DEFAULT_GD_RECONNECT_FAIL_ACTION: &[u8; 36usize] =
    b"GD_RECONNECT_FAIL_ACTION_AUTO_RETRY\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_ECDHE_RSA_AES256_GCM_SHA384: &[u8; 28usize] =
    b"ECDHE-RSA-AES256-GCM-SHA384\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384: &[u8; 38usize] =
    b"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_ECDHE_RSA_AES256_SHA384: &[u8; 24usize] =
    b"ECDHE-RSA-AES256-SHA384\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384: &[u8; 38usize] =
    b"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_ECDHE_RSA_AES256_SHA: &[u8; 21usize] =
    b"ECDHE-RSA-AES256-SHA\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA: &[u8; 35usize] =
    b"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_AES256_GCM_SHA384: &[u8; 18usize] =
    b"AES256-GCM-SHA384\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_TLS_RSA_WITH_AES_256_GCM_SHA384: &[u8; 32usize] =
    b"TLS_RSA_WITH_AES_256_GCM_SHA384\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_AES256_SHA256: &[u8; 14usize] = b"AES256-SHA256\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_TLS_RSA_WITH_AES_256_CBC_SHA256: &[u8; 32usize] =
    b"TLS_RSA_WITH_AES_256_CBC_SHA256\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_AES256_SHA: &[u8; 11usize] = b"AES256-SHA\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_TLS_RSA_WITH_AES_256_CBC_SHA: &[u8; 29usize] =
    b"TLS_RSA_WITH_AES_256_CBC_SHA\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_ECDHE_RSA_DES_CBC3_SHA: &[u8; 23usize] =
    b"ECDHE-RSA-DES-CBC3-SHA\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA: &[u8; 36usize] =
    b"TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_DES_CBC3_SHA: &[u8; 13usize] = b"DES-CBC3-SHA\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_SSL_RSA_WITH_3DES_EDE_CBC_SHA: &[u8; 30usize] =
    b"SSL_RSA_WITH_3DES_EDE_CBC_SHA\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_ECDHE_RSA_AES128_GCM_SHA256: &[u8; 28usize] =
    b"ECDHE-RSA-AES128-GCM-SHA256\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256: &[u8; 38usize] =
    b"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_ECDHE_RSA_AES128_SHA256: &[u8; 24usize] =
    b"ECDHE-RSA-AES128-SHA256\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256: &[u8; 38usize] =
    b"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_ECDHE_RSA_AES128_SHA: &[u8; 21usize] =
    b"ECDHE-RSA-AES128-SHA\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA: &[u8; 35usize] =
    b"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_AES128_GCM_SHA256: &[u8; 18usize] =
    b"AES128-GCM-SHA256\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_TLS_RSA_WITH_AES_128_GCM_SHA256: &[u8; 32usize] =
    b"TLS_RSA_WITH_AES_128_GCM_SHA256\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_AES128_SHA256: &[u8; 14usize] = b"AES128-SHA256\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_TLS_RSA_WITH_AES_128_CBC_SHA256: &[u8; 32usize] =
    b"TLS_RSA_WITH_AES_128_CBC_SHA256\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_AES128_SHA: &[u8; 11usize] = b"AES128-SHA\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_TLS_RSA_WITH_AES_128_CBC_SHA: &[u8; 29usize] =
    b"TLS_RSA_WITH_AES_128_CBC_SHA\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_RC4_SHA: &[u8; 8usize] = b"RC4-SHA\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_SSL_RSA_WITH_RC4_128_SHA: &[u8; 25usize] =
    b"SSL_RSA_WITH_RC4_128_SHA\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_RC4_MD5: &[u8; 8usize] = b"RC4-MD5\0";
pub const SOLCLIENT_SESSION_PROP_SSL_CIPHER_SSL_RSA_WITH_RC4_128_MD5: &[u8; 25usize] =
    b"SSL_RSA_WITH_RC4_128_MD5\0";
pub const SOLCLIENT_SESSION_PROP_SSL_PROTOCOL_TLSV1_2: &[u8; 8usize] = b"TLSv1.2\0";
pub const SOLCLIENT_SESSION_PROP_SSL_PROTOCOL_TLSV1_1: &[u8; 8usize] = b"TLSv1.1\0";
pub const SOLCLIENT_SESSION_PROP_SSL_PROTOCOL_TLSV1: &[u8; 6usize] = b"TLSv1\0";
pub const SOLCLIENT_SESSION_PROP_SSL_PROTOCOL_SSLV3: &[u8; 6usize] = b"SSLv3\0";
pub const SOLCLIENT_SESSION_PROP_MAX_USERNAME_LEN: u32 = 189;
pub const SOLCLIENT_SESSION_PROP_MAX_PASSWORD_LEN: u32 = 128;
pub const SOLCLIENT_SESSION_PROP_MAX_HOSTS: u32 = 16;
pub const SOLCLIENT_SESSION_PROP_MAX_APP_DESC: u32 = 255;
pub const SOLCLIENT_SESSION_PROP_MAX_CLIENT_NAME_LEN: u32 = 160;
pub const SOLCLIENT_SESSION_PROP_MAX_VPN_NAME_LEN: u32 = 32;
pub const SOLCLIENT_SESSION_PROP_MAX_VIRTUAL_ROUTER_NAME_LEN: u32 = 52;
pub const SOLCLIENT_FLOW_PROP_BIND_BLOCKING: &[u8; 19usize] = b"FLOW_BIND_BLOCKING\0";
pub const SOLCLIENT_FLOW_PROP_BIND_TIMEOUT_MS: &[u8; 21usize] = b"FLOW_BIND_TIMEOUT_MS\0";
pub const SOLCLIENT_FLOW_PROP_BIND_ENTITY_ID: &[u8; 20usize] = b"FLOW_BIND_ENTITY_ID\0";
pub const SOLCLIENT_FLOW_PROP_BIND_ENTITY_DURABLE: &[u8; 25usize] = b"FLOW_BIND_ENTITY_DURABLE\0";
pub const SOLCLIENT_FLOW_PROP_BIND_NAME: &[u8; 15usize] = b"FLOW_BIND_NAME\0";
pub const SOLCLIENT_FLOW_PROP_WINDOWSIZE: &[u8; 16usize] = b"FLOW_WINDOWSIZE\0";
pub const SOLCLIENT_FLOW_PROP_AUTOACK: &[u8; 13usize] = b"FLOW_AUTOACK\0";
pub const SOLCLIENT_FLOW_PROP_ACKMODE: &[u8; 13usize] = b"FLOW_ACKMODE\0";
pub const SOLCLIENT_FLOW_PROP_TOPIC: &[u8; 11usize] = b"FLOW_TOPIC\0";
pub const SOLCLIENT_FLOW_PROP_MAX_BIND_TRIES: &[u8; 20usize] = b"FLOW_MAX_BIND_TRIES\0";
pub const SOLCLIENT_FLOW_PROP_ACK_TIMER_MS: &[u8; 18usize] = b"FLOW_ACK_TIMER_MS\0";
pub const SOLCLIENT_FLOW_PROP_ACK_THRESHOLD: &[u8; 19usize] = b"FLOW_ACK_THRESHOLD\0";
pub const SOLCLIENT_FLOW_PROP_START_STATE: &[u8; 17usize] = b"FLOW_START_STATE\0";
pub const SOLCLIENT_FLOW_PROP_SELECTOR: &[u8; 14usize] = b"FLOW_SELECTOR\0";
pub const SOLCLIENT_FLOW_PROP_NO_LOCAL: &[u8; 14usize] = b"FLOW_NO_LOCAL\0";
pub const SOLCLIENT_FLOW_PROP_MAX_UNACKED_MESSAGES: &[u8; 26usize] = b"FLOW_MAX_UNACKED_MESSAGES\0";
pub const SOLCLIENT_FLOW_PROP_BROWSER: &[u8; 13usize] = b"FLOW_BROWSER\0";
pub const SOLCLIENT_FLOW_PROP_ACTIVE_FLOW_IND: &[u8; 21usize] = b"FLOW_ACTIVE_FLOW_IND\0";
pub const SOLCLIENT_FLOW_PROP_REPLAY_START_LOCATION: &[u8; 27usize] =
    b"FLOW_REPLAY_START_LOCATION\0";
pub const SOLCLIENT_FLOW_PROP_MAX_RECONNECT_TRIES: &[u8; 25usize] = b"FLOW_MAX_RECONNECT_TRIES\0";
pub const SOLCLIENT_FLOW_PROP_RECONNECT_RETRY_INTERVAL_MS: &[u8; 33usize] =
    b"FLOW_RECONNECT_RETRY_INTERVAL_MS\0";
pub const SOLCLIENT_FLOW_PROP_DEFAULT_BIND_BLOCKING: &[u8; 2usize] = b"1\0";
pub const SOLCLIENT_FLOW_PROP_DEFAULT_BIND_TIMEOUT_MS: &[u8; 6usize] = b"10000\0";
pub const SOLCLIENT_FLOW_PROP_DEFAULT_BIND_ENTITY_DURABLE: &[u8; 2usize] = b"1\0";
pub const SOLCLIENT_FLOW_PROP_DEFAULT_BIND_NAME: &[u8; 1usize] = b"\0";
pub const SOLCLIENT_FLOW_PROP_DEFAULT_WINDOWSIZE: &[u8; 4usize] = b"255\0";
pub const SOLCLIENT_FLOW_PROP_DEFAULT_AUTOACK: &[u8; 2usize] = b"1\0";
pub const SOLCLIENT_FLOW_PROP_DEFAULT_TOPIC: &[u8; 1usize] = b"\0";
pub const SOLCLIENT_FLOW_PROP_DEFAULT_MAX_BIND_TRIES: &[u8; 2usize] = b"3\0";
pub const SOLCLIENT_FLOW_PROP_DEFAULT_ACK_TIMER_MS: &[u8; 5usize] = b"1000\0";
pub const SOLCLIENT_FLOW_PROP_DEFAULT_ACK_THRESHOLD: &[u8; 3usize] = b"60\0";
pub const SOLCLIENT_FLOW_PROP_DEFAULT_START_STATE: &[u8; 2usize] = b"1\0";
pub const SOLCLIENT_FLOW_PROP_DEFAULT_SELECTOR: &[u8; 1usize] = b"\0";
pub const SOLCLIENT_FLOW_PROP_DEFAULT_NO_LOCAL: &[u8; 2usize] = b"0\0";
pub const SOLCLIENT_FLOW_PROP_DEFAULT_MAX_UNACKED_MESSAGES: &[u8; 3usize] = b"-1\0";
pub const SOLCLIENT_FLOW_PROP_DEFAULT_BROWSER: &[u8; 2usize] = b"0\0";
pub const SOLCLIENT_FLOW_PROP_DEFAULT_ACTIVE_FLOW_IND: &[u8; 2usize] = b"0\0";
pub const SOLCLIENT_FLOW_PROP_DEFAULT_REPLAY_START_LOCATION: &[u8; 1usize] = b"\0";
pub const SOLCLIENT_FLOW_PROP_DEFAULT_MAX_RECONNECT_TRIES: &[u8; 3usize] = b"-1\0";
pub const SOLCLIENT_FLOW_PROP_DEFAULT_RECONNECT_RETRY_INTERVAL_MS: &[u8; 5usize] = b"3000\0";
pub const SOLCLIENT_FLOW_PROP_BIND_ENTITY_SUB: &[u8; 2usize] = b"1\0";
pub const SOLCLIENT_FLOW_PROP_BIND_ENTITY_QUEUE: &[u8; 2usize] = b"2\0";
pub const SOLCLIENT_FLOW_PROP_BIND_ENTITY_TE: &[u8; 2usize] = b"3\0";
pub const SOLCLIENT_FLOW_PROP_BIND_ENTITY_DTE: &[u8; 2usize] = b"3\0";
pub const SOLCLIENT_FLOW_PROP_ACKMODE_AUTO: &[u8; 2usize] = b"1\0";
pub const SOLCLIENT_FLOW_PROP_ACKMODE_CLIENT: &[u8; 2usize] = b"2\0";
pub const SOLCLIENT_ENDPOINT_PROP_ID: &[u8; 12usize] = b"ENDPOINT_ID\0";
pub const SOLCLIENT_ENDPOINT_PROP_NAME: &[u8; 14usize] = b"ENDPOINT_NAME\0";
pub const SOLCLIENT_ENDPOINT_PROP_DURABLE: &[u8; 17usize] = b"ENDPOINT_DURABLE\0";
pub const SOLCLIENT_ENDPOINT_PROP_PERMISSION: &[u8; 20usize] = b"ENDPOINT_PERMISSION\0";
pub const SOLCLIENT_ENDPOINT_PROP_ACCESSTYPE: &[u8; 20usize] = b"ENDPOINT_ACCESSTYPE\0";
pub const SOLCLIENT_ENDPOINT_PROP_QUOTA_MB: &[u8; 18usize] = b"ENDPOINT_QUOTA_MB\0";
pub const SOLCLIENT_ENDPOINT_PROP_MAXMSG_SIZE: &[u8; 21usize] = b"ENDPOINT_MAXMSG_SIZE\0";
pub const SOLCLIENT_ENDPOINT_PROP_RESPECTS_MSG_TTL: &[u8; 26usize] = b"ENDPOINT_RESPECTS_MSG_TTL\0";
pub const SOLCLIENT_ENDPOINT_PROP_DISCARD_BEHAVIOR: &[u8; 26usize] = b"ENDPOINT_DISCARD_BEHAVIOR\0";
pub const SOLCLIENT_ENDPOINT_PROP_MAXMSG_REDELIVERY: &[u8; 27usize] =
    b"ENDPOINT_MAXMSG_REDELIVERY\0";
pub const SOLCLIENT_ENDPOINT_PROP_DEFAULT_DURABLE: &[u8; 2usize] = b"1\0";
pub const SOLCLIENT_ENDPOINT_PROP_DEFAULT_RESPECTS_MSG_TTL: &[u8; 2usize] = b"0\0";
pub const SOLCLIENT_ENDPOINT_PROP_QUEUE: &[u8; 2usize] = b"2\0";
pub const SOLCLIENT_ENDPOINT_PROP_TE: &[u8; 2usize] = b"3\0";
pub const SOLCLIENT_ENDPOINT_PROP_CLIENT_NAME: &[u8; 2usize] = b"4\0";
pub const SOLCLIENT_ENDPOINT_PROP_ACCESSTYPE_NONEXCLUSIVE: &[u8; 2usize] = b"0\0";
pub const SOLCLIENT_ENDPOINT_PROP_ACCESSTYPE_EXCLUSIVE: &[u8; 2usize] = b"1\0";
pub const SOLCLIENT_ENDPOINT_PERM_NONE: &[u8; 2usize] = b"n\0";
pub const SOLCLIENT_ENDPOINT_PERM_READ_ONLY: &[u8; 2usize] = b"r\0";
pub const SOLCLIENT_ENDPOINT_PERM_CONSUME: &[u8; 2usize] = b"c\0";
pub const SOLCLIENT_ENDPOINT_PERM_MODIFY_TOPIC: &[u8; 2usize] = b"m\0";
pub const SOLCLIENT_ENDPOINT_PERM_DELETE: &[u8; 2usize] = b"d\0";
pub const SOLCLIENT_ENDPOINT_PROP_DISCARD_NOTIFY_SENDER_ON: &[u8; 2usize] = b"1\0";
pub const SOLCLIENT_ENDPOINT_PROP_DISCARD_NOTIFY_SENDER_OFF: &[u8; 2usize] = b"2\0";
pub const SOLCLIENT_PROVISION_FLAGS_WAITFORCONFIRM: u32 = 1;
pub const SOLCLIENT_PROVISION_FLAGS_IGNORE_EXIST_ERRORS: u32 = 2;
pub const SOLCLIENT_FLOW_PROP_REPLAY_START_LOCATION_BEGINNING: &[u8; 10usize] = b"BEGINNING\0";
pub const SOLCLIENT_SESSION_CAPABILITY_PUB_GUARANTEED: &[u8; 34usize] =
    b"SESSION_CAPABILITY_PUB_GUARANTEED\0";
pub const SOLCLIENT_SESSION_CAPABILITY_SUB_FLOW_GUARANTEED: &[u8; 39usize] =
    b"SESSION_CAPABILITY_SUB_FLOW_GUARANTEED\0";
pub const SOLCLIENT_SESSION_CAPABILITY_BROWSER: &[u8; 27usize] = b"SESSION_CAPABILITY_BROWSER\0";
pub const SOLCLIENT_SESSION_CAPABILITY_TEMP_ENDPOINT: &[u8; 33usize] =
    b"SESSION_CAPABILITY_TEMP_ENDPOINT\0";
pub const SOLCLIENT_SESSION_CAPABILITY_JNDI: &[u8; 24usize] = b"SESSION_CAPABILITY_JNDI\0";
pub const SOLCLIENT_SESSION_CAPABILITY_COMPRESSION: &[u8; 31usize] =
    b"SESSION_CAPABILITY_COMPRESSION\0";
pub const SOLCLIENT_SESSION_CAPABILITY_SELECTOR: &[u8; 28usize] = b"SESSION_CAPABILITY_SELECTOR\0";
pub const SOLCLIENT_SESSION_CAPABILITY_ENDPOINT_MANAGEMENT: &[u8; 39usize] =
    b"SESSION_CAPABILITY_ENDPOINT_MANAGEMENT\0";
pub const SOLCLIENT_SESSION_PEER_PLATFORM: &[u8; 22usize] = b"SESSION_PEER_PLATFORM\0";
pub const SOLCLIENT_SESSION_PEER_SOFTWARE_DATE: &[u8; 27usize] = b"SESSION_PEER_SOFTWARE_DATE\0";
pub const SOLCLIENT_SESSION_PEER_SOFTWARE_VERSION: &[u8; 30usize] =
    b"SESSION_PEER_SOFTWARE_VERSION\0";
pub const SOLCLIENT_SESSION_PEER_PORT_SPEED: &[u8; 24usize] = b"SESSION_PEER_PORT_SPEED\0";
pub const SOLCLIENT_SESSION_PEER_PORT_TYPE: &[u8; 23usize] = b"SESSION_PEER_PORT_TYPE\0";
pub const SOLCLIENT_SESSION_PEER_ROUTER_NAME: &[u8; 25usize] = b"SESSION_PEER_ROUTER_NAME\0";
pub const SOLCLIENT_SESSION_CAPABILITY_MAX_GUARANTEED_MSG_SIZE: &[u8; 43usize] =
    b"SESSION_CAPABILITY_MAX_GUARANTEED_MSG_SIZE\0";
pub const SOLCLIENT_SESSION_CAPABILITY_MAX_DIRECT_MSG_SIZE: &[u8; 39usize] =
    b"SESSION_CAPABILITY_MAX_DIRECT_MSG_SIZE\0";
pub const SOLCLIENT_SESSION_CAPABILITY_ENDPOINT_MESSAGE_TTL: &[u8; 40usize] =
    b"SESSION_CAPABILITY_ENDPOINT_MESSAGE_TTL\0";
pub const SOLCLIENT_SESSION_CAPABILITY_QUEUE_SUBSCRIPTIONS: &[u8; 39usize] =
    b"SESSION_CAPABILITY_QUEUE_SUBSCRIPTIONS\0";
pub const SOLCLIENT_SESSION_CAPABILITY_SUBSCRIPTION_MANAGER: &[u8; 40usize] =
    b"SESSION_CAPABILITY_SUBSCRIPTION_MANAGER\0";
pub const SOLCLIENT_SESSION_CAPABILITY_MESSAGE_ELIDING: &[u8; 35usize] =
    b"SESSION_CAPABILITY_MESSAGE_ELIDING\0";
pub const SOLCLIENT_SESSION_CAPABILITY_NO_LOCAL: &[u8; 28usize] = b"SESSION_CAPABILITY_NO_LOCAL\0";
pub const SOLCLIENT_SESSION_CAPABILITY_PER_TOPIC_SEQUENCE_NUMBERING: &[u8; 48usize] =
    b"SESSION_CAPABILITY_PER_TOPIC_SEQUENCE_NUMBERING\0";
pub const SOLCLIENT_SESSION_CAPABILITY_ENDPOINT_DISCARD_BEHAVIOR: &[u8; 45usize] =
    b"SESSION_CAPABILITY_ENDPOINT_DISCARD_BEHAVIOR\0";
pub const SOLCLIENT_SESSION_CAPABILITY_ACTIVE_FLOW_INDICATION: &[u8; 42usize] =
    b"SESSION_CAPABILITY_ACTIVE_FLOW_INDICATION\0";
pub const SOLCLIENT_SESSION_CAPABILITY_TRANSACTED_SESSION: &[u8; 38usize] =
    b"SESSION_CAPABILITY_TRANSACTED_SESSION\0";
pub const SOLCLIENT_SESSION_CAPABILITY_OPENMAMA: &[u8; 28usize] = b"SESSION_CAPABILITY_OPENMAMA\0";
pub const SOLCLIENT_SESSION_CAPABILITY_MESSAGE_REPLAY: &[u8; 34usize] =
    b"SESSION_CAPABILITY_MESSAGE_REPLAY\0";
pub const SOLCLIENT_SESSION_CAPABILITY_COMPRESSED_SSL: &[u8; 34usize] =
    b"SESSION_CAPABILITY_COMPRESSED_SSL\0";
pub const SOLCLIENT_SESSION_CAPABILITY_LONG_SELECTORS: &[u8; 34usize] =
    b"SESSION_CAPABILITY_LONG_SELECTORS\0";
pub const SOLCLIENT_SESSION_CAPABILITY_SHARED_SUBSCRIPTIONS: &[u8; 40usize] =
    b"SESSION_CAPABILITY_SHARED_SUBSCRIPTIONS\0";
pub const SOLCLIENT_SESSION_CAPABILITY_BR_REPLAY_ERRORID: &[u8; 37usize] =
    b"SESSION_CAPABILITY_BR_REPLAY_ERRORID\0";
pub const SOLCLIENT_SESSION_CAPABILITY_ADCTRL_VERSION_MIN: &[u8; 38usize] =
    b"SESSION_CAPABILITY_ADCTRL_VERSION_MIN\0";
pub const SOLCLIENT_SESSION_CAPABILITY_ADCTRL_VERSION_MAX: &[u8; 38usize] =
    b"SESSION_CAPABILITY_ADCTRL_VERSION_MAX\0";
pub const SOLCLIENT_TRANSACTEDSESSION_PROP_HAS_PUBLISHER: &[u8; 32usize] =
    b"TRANSACTEDSESSION_HAS_PUBLISHER\0";
pub const SOLCLIENT_TRANSACTEDSESSION_PROP_CREATE_MESSAGE_DISPATCHER: &[u8; 44usize] =
    b"TRANSACTEDSESSION_CREATE_MESSAGE_DISPATCHER\0";
pub const SOLCLIENT_TRANSACTEDSESSION_PROP_REQUESTREPLY_TIMEOUT_MS: &[u8; 42usize] =
    b"TRANSACTEDSESSION_REQUESTREPLY_TIMEOUT_MS\0";
pub const SOLCLIENT_TRANSACTEDSESSION_PROP_PUB_WINDOW_SIZE: &[u8; 34usize] =
    b"TRANSACTEDSESSION_PUB_WINDOW_SIZE\0";
pub const SOLCLIENT_TRANSACTEDSESSION_PROP_DEFAULT_HAS_PUBLISHER: &[u8; 2usize] = b"1\0";
pub const SOLCLIENT_TRANSACTEDSESSION_PROP_DEFAULT_CREATE_MESSAGE_DISPATCHER: &[u8; 2usize] =
    b"0\0";
pub const SOLCLIENT_TRANSACTEDSESSION_PROP_DEFAULT_REQUESTREPLY_TIMEOUT_MS: &[u8; 6usize] =
    b"10000\0";
pub const SOLCLIENT_TRANSACTEDSESSION_PROP_DEFAULT_PUB_WINDOW_SIZE: &[u8; 4usize] = b"255\0";
pub const SOLCLIENT_MESSAGE_USER_PROP_QUEUE_PARTITION_KEY: &[u8; 12usize] = b"JMSXGroupID\0";
pub const SOLCLIENT_ERRORINFO_STR_SIZE: u32 = 256;
pub const SOLCLIENT_BUFINFO_MAX_USER_DATA_SIZE: u32 = 36;
pub const SOLCLIENT_BUFINFO_MAX_CORRELATION_TAG_SIZE: u32 = 16;
pub const SOLCLIENT_BUFINFO_MAX_TOPIC_SIZE: u32 = 250;
pub const SOLCLIENT_BUFINFO_MAX_QUEUENAME_SIZE: u32 = 250;
pub const SOLCLIENT_SESSION_SEND_MULTIPLE_LIMIT: u32 = 50;
pub const SOLCLIENT_CONTEXT_TIMER_ID_INVALID: u32 = 4294967295;
pub const SOLCLIENT_TRANSACTEDSESSION_MAX_SESSION_NAME_LENGTH: u32 = 64;
pub const SOLCLIENT_MSG_NUMDBQUANTA: u32 = 5;
pub const SOLCLIENT_MSGDUMP_BRIEF: u32 = 0;
pub const SOLCLIENT_MSGDUMP_FULL: u32 = 1;
pub const SOLCLIENT_REPLICATION_GROUP_MESSAGE_ID_SIZE: u32 = 16;
pub const SOLCLIENT_REPLICATION_GROUP_MESSAGE_ID_STRING_LENGTH: u32 = 41;
pub type wint_t = ::std::os::raw::c_uint;
pub type solClient_uint8_t = ::std::os::raw::c_uchar;
pub type solClient_int8_t = ::std::os::raw::c_schar;
pub type solClient_uint16_t = ::std::os::raw::c_ushort;
pub type solClient_int16_t = ::std::os::raw::c_short;
pub type solClient_bool_t = ::std::os::raw::c_uchar;
pub type solClient_wchar_t = wint_t;
pub type solClient_int32_t = ::std::os::raw::c_int;
pub type solClient_uint32_t = ::std::os::raw::c_uint;
pub type solClient_propertyArray_pt = *mut *const ::std::os::raw::c_char;
pub type solClient_int64_t = ::std::os::raw::c_longlong;
pub type solClient_uint64_t = ::std::os::raw::c_ulonglong;
#[doc = " @name Type Definitions for Opaque Pointers\n Various \"objects\" that are created are referred to through opaque pointers, which are passed\n to functions that allow access to the item. For example, a ::solClient_opaqueContext_pt pointer\n is returned from solClient_context_create() when a Context is created, and it is passed into other\n APIs that operate on a Context."]
pub type solClient_opaqueContext_pt = *mut ::std::os::raw::c_void;
pub type solClient_opaqueSession_pt = *mut ::std::os::raw::c_void;
pub type solClient_opaqueFlow_pt = *mut ::std::os::raw::c_void;
pub type solClient_opaqueMsg_pt = *mut ::std::os::raw::c_void;
pub type solClient_opaqueContainer_pt = *mut ::std::os::raw::c_void;
pub type solClient_opaqueDatablock_pt = *mut ::std::os::raw::c_void;
pub type solClient_opaqueTransactedSession_pt = *mut ::std::os::raw::c_void;
pub type solClient_opaquePointer_pt = *mut *mut ::std::os::raw::c_void;
pub const solClient_destinationType_SOLCLIENT_NULL_DESTINATION: solClient_destinationType = -1;
pub const solClient_destinationType_SOLCLIENT_TOPIC_DESTINATION: solClient_destinationType = 0;
pub const solClient_destinationType_SOLCLIENT_QUEUE_DESTINATION: solClient_destinationType = 1;
pub const solClient_destinationType_SOLCLIENT_TOPIC_TEMP_DESTINATION: solClient_destinationType = 2;
pub const solClient_destinationType_SOLCLIENT_QUEUE_TEMP_DESTINATION: solClient_destinationType = 3;
#[doc = " @enum solClient_destinationType\n\n Destination Types that can appear in the ReplyTo."]
pub type solClient_destinationType = ::std::os::raw::c_int;
#[doc = " @enum solClient_destinationType\n\n Destination Types that can appear in the ReplyTo."]
pub use self::solClient_destinationType as solClient_destinationType_t;
#[doc = " @struct solClient_destination\n\n A data structure to represent the message destination. A publisher can\n send messages to topics or queues and solClient_destination specifies\n the details."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct solClient_destination {
    #[doc = "< The type of destination."]
    pub destType: solClient_destinationType_t,
    #[doc = "< The name of the destination (as a NULL-terminated UTF-8 string)."]
    pub dest: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_solClient_destination() {
    const UNINIT: ::std::mem::MaybeUninit<solClient_destination> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<solClient_destination>(),
        16usize,
        concat!("Size of: ", stringify!(solClient_destination))
    );
    assert_eq!(
        ::std::mem::align_of::<solClient_destination>(),
        8usize,
        concat!("Alignment of ", stringify!(solClient_destination))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_destination),
            "::",
            stringify!(destType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dest) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_destination),
            "::",
            stringify!(dest)
        )
    );
}
#[doc = " @struct solClient_destination\n\n A data structure to represent the message destination. A publisher can\n send messages to topics or queues and solClient_destination specifies\n the details."]
pub type solClient_destination_t = solClient_destination;
#[doc = "< Boolean."]
pub const solClient_fieldType_SOLCLIENT_BOOL: solClient_fieldType = 0;
#[doc = "< 8-bit unsigned integer."]
pub const solClient_fieldType_SOLCLIENT_UINT8: solClient_fieldType = 1;
#[doc = "< 8-bit signed integer."]
pub const solClient_fieldType_SOLCLIENT_INT8: solClient_fieldType = 2;
#[doc = "< 16-bit unsigned integer."]
pub const solClient_fieldType_SOLCLIENT_UINT16: solClient_fieldType = 3;
#[doc = "< 16-bit signed integer."]
pub const solClient_fieldType_SOLCLIENT_INT16: solClient_fieldType = 4;
#[doc = "< 32-bit unsigned integer."]
pub const solClient_fieldType_SOLCLIENT_UINT32: solClient_fieldType = 5;
#[doc = "< 32-bit signed integer."]
pub const solClient_fieldType_SOLCLIENT_INT32: solClient_fieldType = 6;
#[doc = "< 64-bit unsigned integer."]
pub const solClient_fieldType_SOLCLIENT_UINT64: solClient_fieldType = 7;
#[doc = "< 64-bit signed integer."]
pub const solClient_fieldType_SOLCLIENT_INT64: solClient_fieldType = 8;
#[doc = "< 16-bit unicode character."]
pub const solClient_fieldType_SOLCLIENT_WCHAR: solClient_fieldType = 9;
#[doc = "< Null terminated string, (ASCII or UTF-8)."]
pub const solClient_fieldType_SOLCLIENT_STRING: solClient_fieldType = 10;
#[doc = "< Byte array."]
pub const solClient_fieldType_SOLCLIENT_BYTEARRAY: solClient_fieldType = 11;
#[doc = "< 32-bit floating point number."]
pub const solClient_fieldType_SOLCLIENT_FLOAT: solClient_fieldType = 12;
#[doc = "< 64-bit floating point number."]
pub const solClient_fieldType_SOLCLIENT_DOUBLE: solClient_fieldType = 13;
#[doc = "< Solace Map (container class)."]
pub const solClient_fieldType_SOLCLIENT_MAP: solClient_fieldType = 14;
#[doc = "< Solace Stream (container class)."]
pub const solClient_fieldType_SOLCLIENT_STREAM: solClient_fieldType = 15;
#[doc = "< NULL field."]
pub const solClient_fieldType_SOLCLIENT_NULL: solClient_fieldType = 16;
#[doc = "< Destination field."]
pub const solClient_fieldType_SOLCLIENT_DESTINATION: solClient_fieldType = 17;
#[doc = "< A complete Solace Message Format (SMF) message is encapsulated in the container."]
pub const solClient_fieldType_SOLCLIENT_SMF: solClient_fieldType = 18;
#[doc = "< A validly formatted, but unrecognized, data type was received."]
pub const solClient_fieldType_SOLCLIENT_UNKNOWN: solClient_fieldType = -1;
#[doc = " @enum solClient_fieldType\n\n Data types that can be transmitted by the machine-independent read and write\n functions."]
pub type solClient_fieldType = ::std::os::raw::c_int;
#[doc = " @enum solClient_fieldType\n\n Data types that can be transmitted by the machine-independent read and write\n functions."]
pub use self::solClient_fieldType as solClient_fieldType_t;
#[doc = " @struct solClient_field\n The general solClient_field structure is returned by generic accessors to\n the container. The application must first check the fieldType to determine\n which member of the union to use."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct solClient_field {
    pub type_: solClient_fieldType_t,
    pub length: solClient_uint32_t,
    pub value: solClient_field__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union solClient_field__bindgen_ty_1 {
    pub boolean: solClient_bool_t,
    pub uint8: solClient_uint8_t,
    pub int8: solClient_int8_t,
    pub uint16: solClient_uint16_t,
    pub int16: solClient_int16_t,
    pub uint32: solClient_uint32_t,
    pub int32: solClient_int32_t,
    pub uint64: solClient_uint64_t,
    pub int64: solClient_int64_t,
    pub wchar: solClient_wchar_t,
    pub float32: f32,
    pub float64: f64,
    pub string: *const ::std::os::raw::c_char,
    pub bytearray: *mut solClient_uint8_t,
    pub map: solClient_opaqueContainer_pt,
    pub stream: solClient_opaqueContainer_pt,
    pub dest: solClient_destination_t,
    pub smf: *mut solClient_uint8_t,
    pub unknownField: *mut solClient_uint8_t,
}
#[test]
fn bindgen_test_layout_solClient_field__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<solClient_field__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<solClient_field__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(solClient_field__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<solClient_field__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(solClient_field__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).boolean) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_field__bindgen_ty_1),
            "::",
            stringify!(boolean)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uint8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_field__bindgen_ty_1),
            "::",
            stringify!(uint8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_field__bindgen_ty_1),
            "::",
            stringify!(int8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uint16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_field__bindgen_ty_1),
            "::",
            stringify!(uint16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_field__bindgen_ty_1),
            "::",
            stringify!(int16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uint32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_field__bindgen_ty_1),
            "::",
            stringify!(uint32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_field__bindgen_ty_1),
            "::",
            stringify!(int32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_field__bindgen_ty_1),
            "::",
            stringify!(uint64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_field__bindgen_ty_1),
            "::",
            stringify!(int64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wchar) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_field__bindgen_ty_1),
            "::",
            stringify!(wchar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).float32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_field__bindgen_ty_1),
            "::",
            stringify!(float32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).float64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_field__bindgen_ty_1),
            "::",
            stringify!(float64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_field__bindgen_ty_1),
            "::",
            stringify!(string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytearray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_field__bindgen_ty_1),
            "::",
            stringify!(bytearray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).map) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_field__bindgen_ty_1),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_field__bindgen_ty_1),
            "::",
            stringify!(stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_field__bindgen_ty_1),
            "::",
            stringify!(dest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).smf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_field__bindgen_ty_1),
            "::",
            stringify!(smf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unknownField) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_field__bindgen_ty_1),
            "::",
            stringify!(unknownField)
        )
    );
}
#[test]
fn bindgen_test_layout_solClient_field() {
    const UNINIT: ::std::mem::MaybeUninit<solClient_field> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<solClient_field>(),
        24usize,
        concat!("Size of: ", stringify!(solClient_field))
    );
    assert_eq!(
        ::std::mem::align_of::<solClient_field>(),
        8usize,
        concat!("Alignment of ", stringify!(solClient_field))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_field),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_field),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_field),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " @struct solClient_field\n The general solClient_field structure is returned by generic accessors to\n the container. The application must first check the fieldType to determine\n which member of the union to use."]
pub type solClient_field_t = solClient_field;
#[doc = "< The API call was successful."]
pub const solClient_returnCode_SOLCLIENT_OK: solClient_returnCode = 0;
#[doc = "< The API call would block, but non-blocking was requested."]
pub const solClient_returnCode_SOLCLIENT_WOULD_BLOCK: solClient_returnCode = 1;
#[doc = "< An API call is in progress (non-blocking mode)."]
pub const solClient_returnCode_SOLCLIENT_IN_PROGRESS: solClient_returnCode = 2;
#[doc = "< The API could not complete as an object is not ready (for example, the Session is not connected)."]
pub const solClient_returnCode_SOLCLIENT_NOT_READY: solClient_returnCode = 3;
#[doc = "< A getNext on a structured container returned End-of-Stream."]
pub const solClient_returnCode_SOLCLIENT_EOS: solClient_returnCode = 4;
#[doc = "< A get for a named field in a MAP was not found in the MAP."]
pub const solClient_returnCode_SOLCLIENT_NOT_FOUND: solClient_returnCode = 5;
#[doc = "< solClient_context_processEventsWait returns this if wait is zero and there is no event to process"]
pub const solClient_returnCode_SOLCLIENT_NOEVENT: solClient_returnCode = 6;
#[doc = "< The API call completed some, but not all, of the requested function."]
pub const solClient_returnCode_SOLCLIENT_INCOMPLETE: solClient_returnCode = 7;
#[doc = "< solClient_transactedSession_commit returns this when the transaction has been rolled back."]
pub const solClient_returnCode_SOLCLIENT_ROLLBACK: solClient_returnCode = 8;
#[doc = "< The API call failed."]
pub const solClient_returnCode_SOLCLIENT_FAIL: solClient_returnCode = -1;
#[doc = " @enum solClient_returnCode\n Return code from API calls.\n A return code can be converted to a string through solClient_returnCodeToString()."]
pub type solClient_returnCode = ::std::os::raw::c_int;
#[doc = " @enum solClient_returnCode\n Return code from API calls.\n A return code can be converted to a string through solClient_returnCodeToString()."]
pub use self::solClient_returnCode as solClient_returnCode_t;
#[doc = "< Normal return - the message is destroyed by the API upon return."]
pub const solClient_rxMsgCallback_returnCode_SOLCLIENT_CALLBACK_OK:
    solClient_rxMsgCallback_returnCode = 0;
#[doc = "< The application is keeping the rxMsg, and it must not be released or reused by the API ."]
pub const solClient_rxMsgCallback_returnCode_SOLCLIENT_CALLBACK_TAKE_MSG:
    solClient_rxMsgCallback_returnCode = 1;
#[doc = " @enum solClient_rxMsgCallback_returnCode\n\n The return code that the application returns to the API on each received message. This is used\n by the message received functions with the prototype of ::solClient_session_rxMsgCallbackFunc_t\n or ::solClient_flow_rxMsgCallbackFunc_t."]
pub type solClient_rxMsgCallback_returnCode = ::std::os::raw::c_uint;
#[doc = " @enum solClient_rxMsgCallback_returnCode\n\n The return code that the application returns to the API on each received message. This is used\n by the message received functions with the prototype of ::solClient_session_rxMsgCallbackFunc_t\n or ::solClient_flow_rxMsgCallbackFunc_t."]
pub use self::solClient_rxMsgCallback_returnCode as solClient_rxMsgCallback_returnCode_t;
#[doc = "< No error."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_OK: solClient_subCode = 0;
#[doc = "< An API call was made with an out-of-range parameter."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_PARAM_OUT_OF_RANGE: solClient_subCode = 1;
#[doc = "< An API call was made with a null or invalid pointer parameter."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_PARAM_NULL_PTR: solClient_subCode = 2;
#[doc = "< An API call was made with a parameter combination that is not valid."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_PARAM_CONFLICT: solClient_subCode = 3;
#[doc = "< An API call failed due to insufficient space to accept more data."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE: solClient_subCode = 4;
#[doc = "< An API call failed due to lack of resources (for example, starting a timer when all timers are in use)."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_OUT_OF_RESOURCES: solClient_subCode = 5;
#[doc = "< An API call had an internal error (not an application fault)."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_INTERNAL_ERROR: solClient_subCode = 6;
#[doc = "< An API call failed due to inability to allocate memory."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_OUT_OF_MEMORY: solClient_subCode = 7;
#[doc = "< An API call failed due to a protocol error with the broker (not an application fault)."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_PROTOCOL_ERROR: solClient_subCode = 8;
#[doc = "< An API call failed due to solClient_initialize() not being called first."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_INIT_NOT_CALLED: solClient_subCode = 9;
#[doc = "< An API call failed due to a timeout."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_TIMEOUT: solClient_subCode = 10;
#[doc = "< The Session Keep-Alive detected a failed Session."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_KEEP_ALIVE_FAILURE: solClient_subCode = 11;
#[doc = "< An API call failed due to the Session not being established."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_SESSION_NOT_ESTABLISHED: solClient_subCode = 12;
#[doc = "< An API call failed due to a failed operating system call; an error string can be retrieved with solClient_getLastErrorInfo()."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_OS_ERROR: solClient_subCode = 13;
#[doc = "< An API call failed due to a communication error. An error string can be retrieved with solClient_getLastErrorInfo()."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_COMMUNICATION_ERROR: solClient_subCode = 14;
#[doc = "< An attempt was made to send a message with user data larger than the maximum that is supported."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_USER_DATA_TOO_LARGE: solClient_subCode = 15;
#[doc = "< An attempt was made to use a Topic that is longer than the maximum that is supported."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_TOPIC_TOO_LARGE: solClient_subCode = 16;
#[doc = "< An attempt was made to use a Topic that has a syntax which is not supported."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_INVALID_TOPIC_SYNTAX: solClient_subCode = 17;
#[doc = "< The broker could not parse an XML message."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_XML_PARSE_ERROR: solClient_subCode = 18;
#[doc = "< The client could not log into the broker (bad username or password)."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_LOGIN_FAILURE: solClient_subCode = 19;
#[doc = "< An attempt was made to connect to the wrong IP address on the broker (must use CVRID if configured) or the broker CVRID has changed and this was detected on reconnect."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_INVALID_VIRTUAL_ADDRESS: solClient_subCode = 20;
#[doc = "< The client login not currently possible as previous instance of same client still being deleted."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_CLIENT_DELETE_IN_PROGRESS: solClient_subCode = 21;
#[doc = "< The client login not currently possible because the maximum number of active clients on broker has already been reached."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_TOO_MANY_CLIENTS: solClient_subCode = 22;
#[doc = "< The client attempted to add a subscription which already exists. This subcode is only returned if the Session property SOLCLIENT_SESSION_PROP_IGNORE_DUP_SUBSCRIPTION_ERROR is not enabled."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_SUBSCRIPTION_ALREADY_PRESENT: solClient_subCode = 23;
#[doc = "< The client attempted to remove a subscription which did not exist. This subcode is only returned if the Session property SOLCLIENT_SESSION_PROP_IGNORE_DUP_SUBSCRIPTION_ERROR is not enabled."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_SUBSCRIPTION_NOT_FOUND: solClient_subCode = 24;
#[doc = "< The client attempted to add/remove a subscription that is not valid."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_SUBSCRIPTION_INVALID: solClient_subCode = 25;
#[doc = "< The broker rejected a subscription add or remove request for a reason not separately enumerated."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_SUBSCRIPTION_OTHER: solClient_subCode = 26;
#[doc = "< The broker rejected a control message for another reason not separately enumerated."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_CONTROL_OTHER: solClient_subCode = 27;
#[doc = "< The broker rejected a data message for another reason not separately enumerated."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_DATA_OTHER: solClient_subCode = 28;
#[doc = "< Could not open the log file name specified by the application for writing (Deprecated - ::SOLCLIENT_SUBCODE_OS_ERROR is used)."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_LOG_FILE_ERROR: solClient_subCode = 29;
#[doc = "< The client attempted to send a message larger than that supported by the broker."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_MESSAGE_TOO_LARGE: solClient_subCode = 30;
#[doc = "< The client attempted to add a subscription that exceeded the maximum number allowed."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_SUBSCRIPTION_TOO_MANY: solClient_subCode = 31;
#[doc = "< An API call failed due to the attempted operation not being valid for the Session."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_INVALID_SESSION_OPERATION: solClient_subCode = 32;
#[doc = "< A send call was made that did not have a Topic in a mode where one is required (for example, client mode)."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_TOPIC_MISSING: solClient_subCode = 33;
#[doc = "< A send call was made to send a Guaranteed message before Guaranteed Delivery is established (Deprecated)."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_ASSURED_MESSAGING_NOT_ESTABLISHED: solClient_subCode =
    34;
#[doc = "< An attempt was made to start Guaranteed Delivery when it is already started."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_ASSURED_MESSAGING_STATE_ERROR: solClient_subCode = 35;
#[doc = "< Both Queue Name and Topic are specified in solClient_session_send."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_QUEUENAME_TOPIC_CONFLICT: solClient_subCode = 36;
#[doc = "< An attempt was made to use a Queue name which is longer than the maximum supported length."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_QUEUENAME_TOO_LARGE: solClient_subCode = 37;
#[doc = "< An attempt was made to use a Queue name on a non-Guaranteed message."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_QUEUENAME_INVALID_MODE: solClient_subCode = 38;
#[doc = "< An attempt was made to send a message with a total size greater than that supported by the protocol."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_MAX_TOTAL_MSGSIZE_EXCEEDED: solClient_subCode = 39;
#[doc = "< An attempt was made to allocate a datablock for a msg element when one already exists."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_DBLOCK_ALREADY_EXISTS: solClient_subCode = 40;
#[doc = "< An attempt was made to create a container to read structured data where none exists."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_NO_STRUCTURED_DATA: solClient_subCode = 41;
#[doc = "< An attempt was made to add a field to a map or stream while a sub map or stream is being built."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_CONTAINER_BUSY: solClient_subCode = 42;
#[doc = "< An attempt was made to retrieve structured data with wrong type."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_INVALID_DATA_CONVERSION: solClient_subCode = 43;
#[doc = "< An attempt was made to modify a property that cannot be modified while Session is not idle."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_CANNOT_MODIFY_WHILE_NOT_IDLE: solClient_subCode = 44;
#[doc = "< The Message VPN name configured for the session does not exist."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_MSG_VPN_NOT_ALLOWED: solClient_subCode = 45;
#[doc = "< The client name chosen has been rejected as invalid by the broker."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_CLIENT_NAME_INVALID: solClient_subCode = 46;
#[doc = "< The Message VPN name set for the Session (or the default Message VPN, if none was set) is currently shutdown on the broker."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_MSG_VPN_UNAVAILABLE: solClient_subCode = 47;
#[doc = "< The username for the client is administratively shutdown on the broker."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_CLIENT_USERNAME_IS_SHUTDOWN: solClient_subCode = 48;
#[doc = "< The username for the Session has not been set and dynamic clients are not allowed."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_DYNAMIC_CLIENTS_NOT_ALLOWED: solClient_subCode = 49;
#[doc = "< The Session is attempting to use a client, publisher name, or subscriber name that is in use by another client, publisher, or subscriber, and the broker is configured to reject the new Session. When Message VPNs are in use, the conflicting client name must be in the same Message VPN."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_CLIENT_NAME_ALREADY_IN_USE: solClient_subCode = 50;
#[doc = "< When the cache request returns ::SOLCLIENT_INCOMPLETE, this subcode indicates there is no cached data in the designated cache."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_CACHE_NO_DATA: solClient_subCode = 51;
#[doc = "< When the designated cache responds to a cache request with suspect data the API returns ::SOLCLIENT_INCOMPLETE with this subcode."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_CACHE_SUSPECT_DATA: solClient_subCode = 52;
#[doc = "< The cache instance has returned an error response to the request."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_CACHE_ERROR_RESPONSE: solClient_subCode = 53;
#[doc = "< The cache session operation failed because the Session has been destroyed."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_CACHE_INVALID_SESSION: solClient_subCode = 54;
#[doc = "< The cache session operation failed because the request timeout expired."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_CACHE_TIMEOUT: solClient_subCode = 55;
#[doc = "< The cache session operation completed when live data arrived on the Topic requested."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_CACHE_LIVEDATA_FULFILL: solClient_subCode = 56;
#[doc = "< A cache request has been made when there is already a cache request outstanding on the same Topic and SOLCLIENT_CACHEREQUEST_FLAGS_LIVEDATA_FLOWTHRU was not set."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_CACHE_ALREADY_IN_PROGRESS: solClient_subCode = 57;
#[doc = "< A message does not have the required reply-to field."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_MISSING_REPLY_TO: solClient_subCode = 58;
#[doc = "< Already bound to the queue, or not authorized to bind to the queue."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_CANNOT_BIND_TO_QUEUE: solClient_subCode = 59;
#[doc = "< An attempt was made to bind to a Topic Endpoint with an invalid topic."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_INVALID_TOPIC_NAME_FOR_TE: solClient_subCode = 60;
#[doc = "< Deprecated name; ::SOLCLIENT_SUBCODE_INVALID_TOPIC_NAME_FOR_TE is preferred."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_INVALID_TOPIC_NAME_FOR_DTE: solClient_subCode = 60;
#[doc = "< An attempt was made to bind to an unknown Queue name (for example, not configured on broker)."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_UNKNOWN_QUEUE_NAME: solClient_subCode = 61;
#[doc = "< An attempt was made to bind to an unknown Topic Endpoint name (for example, not configured on broker)."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_UNKNOWN_TE_NAME: solClient_subCode = 62;
#[doc = "< Deprecated name; ::SOLCLIENT_SUBCODE_UNKNOWN_TE_NAME is preferred."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_UNKNOWN_DTE_NAME: solClient_subCode = 62;
#[doc = "< An attempt was made to bind to a Queue that already has a maximum number of clients."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_MAX_CLIENTS_FOR_QUEUE: solClient_subCode = 63;
#[doc = "< An attempt was made to bind to a Topic Endpoint that already has a maximum number of clients."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_MAX_CLIENTS_FOR_TE: solClient_subCode = 64;
#[doc = "< Deprecated name, ::SOLCLIENT_SUBCODE_MAX_CLIENTS_FOR_TE is preferred."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_MAX_CLIENTS_FOR_DTE: solClient_subCode = 64;
#[doc = "< An unexpected unbind response was received for a Queue or Topic Endpoint (for example, the Queue or Topic Endpoint was deleted from the broker)."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_UNEXPECTED_UNBIND: solClient_subCode = 65;
#[doc = "< The specified Queue was not found when publishing a message."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_QUEUE_NOT_FOUND: solClient_subCode = 66;
#[doc = "< The client login to the broker was denied because the IP address/netmask combination used for the client is designated in the ACL (Access Control List) as a deny connection for the given Message VPN and username."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_CLIENT_ACL_DENIED: solClient_subCode = 67;
#[doc = "< Adding a subscription was denied because it matched a subscription that was defined on the ACL (Access Control List)."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_SUBSCRIPTION_ACL_DENIED: solClient_subCode = 68;
#[doc = "< A message could not be published because its Topic matched a Topic defined on the ACL (Access Control List)."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_PUBLISH_ACL_DENIED: solClient_subCode = 69;
#[doc = "< An attempt was made to set both Deliver-To-One (DTO) and Guaranteed Delivery in the same message. (Deprecated:  DTO will be applied to the corresponding demoted direct message)"]
pub const solClient_subCode_SOLCLIENT_SUBCODE_DELIVER_TO_ONE_INVALID: solClient_subCode = 70;
#[doc = "< Message was not delivered because the Guaranteed message spool is over its allotted space quota."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_SPOOL_OVER_QUOTA: solClient_subCode = 71;
#[doc = "< An attempt was made to operate on a shutdown queue."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_QUEUE_SHUTDOWN: solClient_subCode = 72;
#[doc = "< An attempt was made to bind to a shutdown Topic Endpoint."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_TE_SHUTDOWN: solClient_subCode = 73;
#[doc = "< An attempt was made to bind to a non-durable Queue or Topic Endpoint, and the broker is out of resources."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_NO_MORE_NON_DURABLE_QUEUE_OR_TE: solClient_subCode =
    74;
#[doc = "< An attempt was made to create a Queue or Topic Endpoint that already exists. This subcode is only returned if the provision flag SOLCLIENT_PROVISION_FLAGS_IGNORE_EXIST_ERRORS is not set."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_ENDPOINT_ALREADY_EXISTS: solClient_subCode = 75;
#[doc = "< An attempt was made to delete or create a Queue or Topic Endpoint when the Session does not have authorization for the action. This subcode is also returned when an attempt is made to remove a message from an endpoint when the Session does not have 'consume' authorization, or when an attempt is made to add or remove a Topic subscription from a Queue when the Session does not have 'modify-topic' authorization."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_PERMISSION_NOT_ALLOWED: solClient_subCode = 76;
#[doc = "< An attempt was made to bind to a Queue or Topic Endpoint with an invalid selector."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_INVALID_SELECTOR: solClient_subCode = 77;
#[doc = "< Publishing of message denied because the maximum spooled message count was exceeded."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_MAX_MESSAGE_USAGE_EXCEEDED: solClient_subCode = 78;
#[doc = "< An attempt was made to create a dynamic durable endpoint and it was found to exist with different properties."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_ENDPOINT_PROPERTY_MISMATCH: solClient_subCode = 79;
#[doc = "< An attempt was made to add a subscription to another client when Session does not have subscription manager privileges."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_SUBSCRIPTION_MANAGER_DENIED: solClient_subCode = 80;
#[doc = "< An attempt was made to add a subscription to another client that is unknown on the broker."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_UNKNOWN_CLIENT_NAME: solClient_subCode = 81;
#[doc = "< An attempt was made to provision an endpoint with a quota that is out of range."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_QUOTA_OUT_OF_RANGE: solClient_subCode = 82;
#[doc = "< The client attempted to add a subscription which already exists but it has different properties"]
pub const solClient_subCode_SOLCLIENT_SUBCODE_SUBSCRIPTION_ATTRIBUTES_CONFLICT: solClient_subCode =
    83;
#[doc = "< The client attempted to send a Solace Message Format (SMF) message using solClient_session_sendSmf() or solClient_session_sendMultipleSmf(), but the buffer did not contain a Direct message."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_INVALID_SMF_MESSAGE: solClient_subCode = 84;
#[doc = "< The client attempted to establish a Session or Flow with No Local enabled and the capability is not supported by the broker."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_NO_LOCAL_NOT_SUPPORTED: solClient_subCode = 85;
#[doc = "< The client attempted to unsubscribe a Topic from a Topic Endpoint while there were still Flows bound to the endpoint."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_UNSUBSCRIBE_NOT_ALLOWED_CLIENTS_BOUND:
    solClient_subCode = 86;
#[doc = "< An API function was invoked in the Context thread that would have blocked otherwise. For an example, a call may have been made to send a message when the Session is configured with ::SOLCLIENT_SESSION_PROP_SEND_BLOCKING enabled and the transport (socket or IPC) channel is full. All application callback functions are executed in the Context thread."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_CANNOT_BLOCK_IN_CONTEXT: solClient_subCode = 87;
#[doc = "< The client attempted to establish a Flow with Active Flow Indication (SOLCLIENT_FLOW_PROP_ACTIVE_FLOW_IND) enabled and the capability is not supported by the broker"]
pub const solClient_subCode_SOLCLIENT_SUBCODE_FLOW_ACTIVE_FLOW_INDICATION_UNSUPPORTED:
    solClient_subCode = 88;
#[doc = "< The client failed to connect because the host name could not be resolved."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_UNRESOLVED_HOST: solClient_subCode = 89;
#[doc = "< An attempt was made to create a 'cut-through' Flow on a Session that does not support this capability"]
pub const solClient_subCode_SOLCLIENT_SUBCODE_CUT_THROUGH_UNSUPPORTED: solClient_subCode = 90;
#[doc = "< An attempt was made to create a 'cut-through' Flow on a Session that already has one 'cut-through' Flow"]
pub const solClient_subCode_SOLCLIENT_SUBCODE_CUT_THROUGH_ALREADY_BOUND: solClient_subCode = 91;
#[doc = "< An attempt was made to create a 'cut-through' Flow on a Session with incompatible Session properties. Cut-through may not be enabled on Sessions with SOLCLIENT_SESSION_PROP_TOPIC_DISPATCH enabled."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_CUT_THROUGH_INCOMPATIBLE_WITH_SESSION:
    solClient_subCode = 92;
#[doc = "< An API call failed due to the attempted operation not being valid for the Flow."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_INVALID_FLOW_OPERATION: solClient_subCode = 93;
#[doc = "<The session was disconnected due to loss of the publisher flow state. All (unacked and unsent) messages held by the API were deleted. To connect the session, applications need to call ::solClient_session_connect again."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_UNKNOWN_FLOW_NAME: solClient_subCode = 94;
#[doc = "<An attempt to perform an operation using a VPN that is configured to be STANDBY for replication."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_REPLICATION_IS_STANDBY: solClient_subCode = 95;
#[doc = "<The message was rejected by the broker as one or more matching endpoints exceeded the reject-low-priority-msg-limit."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_LOW_PRIORITY_MSG_CONGESTION: solClient_subCode = 96;
#[doc = "< The client failed to find the library or symbol."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_LIBRARY_NOT_LOADED: solClient_subCode = 97;
#[doc = "< The client failed to load the trust store."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_FAILED_LOADING_TRUSTSTORE: solClient_subCode = 98;
#[doc = "< The client attempted to connect to an broker that has a suspect certficate."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_UNTRUSTED_CERTIFICATE: solClient_subCode = 99;
#[doc = "< The client attempted to connect to an broker that has a suspect common name."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_UNTRUSTED_COMMONNAME: solClient_subCode = 100;
#[doc = "< The client attempted to connect to an broker that does not have a valid certificate date."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_CERTIFICATE_DATE_INVALID: solClient_subCode = 101;
#[doc = "< The client failed to load certificate and/or private key files."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_FAILED_LOADING_CERTIFICATE_AND_KEY:
    solClient_subCode = 102;
#[doc = "<  The client attempted to connect to an broker that has the basic authentication shutdown."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_BASIC_AUTHENTICATION_IS_SHUTDOWN: solClient_subCode =
    103;
#[doc = "<  The client attempted to connect to an broker that has the client certificate authentication shutdown."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_CLIENT_CERTIFICATE_AUTHENTICATION_IS_SHUTDOWN:
    solClient_subCode = 104;
#[doc = "< The client failed to connect to an broker as it has a suspect client certificate."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_UNTRUSTED_CLIENT_CERTIFICATE: solClient_subCode = 105;
#[doc = "< The client failed to connect to an broker as it does not have a valid client certificate date."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_CLIENT_CERTIFICATE_DATE_INVALID: solClient_subCode =
    106;
#[doc = "< The cache request has been cancelled by the client."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_CACHE_REQUEST_CANCELLED: solClient_subCode = 107;
#[doc = "< Attempt was made from a Transacted Session to send a message with the delivery mode SOLCLIENT_DELIVERY_MODE_DIRECT."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_DELIVERY_MODE_UNSUPPORTED: solClient_subCode = 108;
#[doc = "< Client attempted to send a message from a Transacted Session without creating a default publisher flow."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_PUBLISHER_NOT_CREATED: solClient_subCode = 109;
#[doc = "< The client attempted to receive message from an UNBOUND Flow with no queued messages in memory."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_FLOW_UNBOUND: solClient_subCode = 110;
#[doc = "< The client attempted to commit or rollback a transaction with an invalid Transacted Session Id."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_INVALID_TRANSACTED_SESSION_ID: solClient_subCode =
    111;
#[doc = "< The client attempted to commit or rollback a transaction with an invalid transaction Id."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_INVALID_TRANSACTION_ID: solClient_subCode = 112;
#[doc = "< The client failed to open a Transacted Session as it exceeded the max Transacted Sessions."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_MAX_TRANSACTED_SESSIONS_EXCEEDED: solClient_subCode =
    113;
#[doc = "< The client failed to open a Transacted Session as the Transacted Session name provided is being used by another opened session."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_TRANSACTED_SESSION_NAME_IN_USE: solClient_subCode =
    114;
#[doc = "< Guaranteed Delivery services are not enabled on the broker."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_SERVICE_UNAVAILABLE: solClient_subCode = 115;
#[doc = "< The client attempted to commit an unknown transaction."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_NO_TRANSACTION_STARTED: solClient_subCode = 116;
#[doc = "< A send call was made on a transacted session before its publisher is established."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_PUBLISHER_NOT_ESTABLISHED: solClient_subCode = 117;
#[doc = "< The client attempted to commit a transaction with a GD publish failure encountered."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_MESSAGE_PUBLISH_FAILURE: solClient_subCode = 118;
#[doc = "< The client attempted to commit a transaction with too many transaction steps."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_TRANSACTION_FAILURE: solClient_subCode = 119;
#[doc = "< The client attempted to commit a transaction with a consume failure encountered."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_MESSAGE_CONSUME_FAILURE: solClient_subCode = 120;
#[doc = "< The client attempted to commit a transaction with an Endpoint being shutdown or deleted."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_ENDPOINT_MODIFIED: solClient_subCode = 121;
#[doc = "< The client attempted to commit a transaction with an unknown connection ID."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_INVALID_CONNECTION_OWNER: solClient_subCode = 122;
#[doc = "< The client attempted to connect to an broker that has the Kerberos authentication shutdown."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_KERBEROS_AUTHENTICATION_IS_SHUTDOWN:
    solClient_subCode = 123;
#[doc = "< The client attempted to send/receive a message or commit/rollback a transaction when a transaction commit/rollback is in progress."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_COMMIT_OR_ROLLBACK_IN_PROGRESS: solClient_subCode =
    124;
#[doc = "< The application called solClient_flow_destroy() and the unbind-response was not received."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_UNBIND_RESPONSE_LOST: solClient_subCode = 125;
#[doc = "< The client failed to open a Transacted Session as the maximum number of transactions was exceeded."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_MAX_TRANSACTIONS_EXCEEDED: solClient_subCode = 126;
#[doc = "< The commit response was lost due to a transport layer reconnection to an alternate host in the host list."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_COMMIT_STATUS_UNKNOWN: solClient_subCode = 127;
#[doc = "< The host entry did not contain proxy authentication when required by the proxy server."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_PROXY_AUTH_REQUIRED: solClient_subCode = 128;
#[doc = "< The host entry contained invalid proxy authentication when required by the proxy server."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_PROXY_AUTH_FAILURE: solClient_subCode = 129;
#[doc = "< The client attempted to publish a guaranteed message to a topic that did not have any guaranteed subscription matches or only matched a replicated topic."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_NO_SUBSCRIPTION_MATCH: solClient_subCode = 130;
#[doc = "< The client attempted to bind to a non-exclusive topic endpoint that is already bound with a different subscription."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_SUBSCRIPTION_MATCH_ERROR: solClient_subCode = 131;
#[doc = "< The client attempted to bind to a non-exclusive topic endpoint that is already bound with\na different ingress selector."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_SELECTOR_MATCH_ERROR: solClient_subCode = 132;
#[doc = "< Replay is not supported on the Solace Message Router."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_REPLAY_NOT_SUPPORTED: solClient_subCode = 133;
#[doc = "< Replay is not enabled in the message-vpn."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_REPLAY_DISABLED: solClient_subCode = 134;
#[doc = "< The client attempted to start replay on a flow bound to a non-exclusive endpoint."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_CLIENT_INITIATED_REPLAY_NON_EXCLUSIVE_NOT_ALLOWED:
    solClient_subCode = 135;
#[doc = "< The client attempted to start replay on an inactive flow."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_CLIENT_INITIATED_REPLAY_INACTIVE_FLOW_NOT_ALLOWED:
    solClient_subCode = 136;
#[doc = "< The client attempted to bind with both ::SOLCLIENT_FLOW_PROP_BROWSER enabled and ::SOLCLIENT_FLOW_PROP_REPLAY_START_LOCATION set."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_CLIENT_INITIATED_REPLAY_BROWSER_FLOW_NOT_ALLOWED:
    solClient_subCode = 137;
#[doc = "< Replay is not supported on temporary endpoints."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_REPLAY_TEMPORARY_NOT_SUPPORTED: solClient_subCode =
    138;
#[doc = "< The client attempted to start a replay but provided an unknown start location type."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_UNKNOWN_START_LOCATION_TYPE: solClient_subCode = 139;
#[doc = "< A replay in progress on a flow failed because messages to be replayed were trimmed from the replay log."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_REPLAY_MESSAGE_UNAVAILABLE: solClient_subCode = 140;
#[doc = "< A replay was started on the queue/topic endpoint, either by another client or by an administrator on the message router."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_REPLAY_STARTED: solClient_subCode = 141;
#[doc = "< A replay in progress on a flow was administratively cancelled, causing the flow to be unbound."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_REPLAY_CANCELLED: solClient_subCode = 142;
#[doc = "< A replay was requested but the requested start time is not available in the replay log."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_REPLAY_START_TIME_NOT_AVAILABLE: solClient_subCode =
    143;
#[doc = "< The Solace Message Router attempted to replay a message, but the queue/topic endpoint rejected the message to the sender."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_REPLAY_MESSAGE_REJECTED: solClient_subCode = 144;
#[doc = "< A replay in progress on a flow failed because the replay log was modified."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_REPLAY_LOG_MODIFIED: solClient_subCode = 145;
#[doc = "< Endpoint error ID in the bind request does not match the endpoint's error ID."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_MISMATCHED_ENDPOINT_ERROR_ID: solClient_subCode = 146;
#[doc = "< A replay was requested, but the router does not have sufficient resources to fulfill the request, due to too many active replays."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_OUT_OF_REPLAY_RESOURCES: solClient_subCode = 147;
#[doc = "< A replay was in progress on a Durable Topic Endpoint (DTE) when its topic or selector was modified, causing the replay to fail."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_TOPIC_OR_SELECTOR_MODIFIED_ON_DURABLE_TOPIC_ENDPOINT : solClient_subCode = 148 ;
#[doc = "< A replay in progress on a flow failed."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_REPLAY_FAILED: solClient_subCode = 149;
#[doc = "< The client attempted to establish a Session or Flow with ssl and compression, but the capability is not supported by the broker."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_COMPRESSED_SSL_NOT_SUPPORTED: solClient_subCode = 150;
#[doc = "< The client attempted to add a shared subscription, but the capability is not supported by the broker."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_SHARED_SUBSCRIPTIONS_NOT_SUPPORTED:
    solClient_subCode = 151;
#[doc = "< The client attempted to add a shared subscription on a client that is not permitted to use shared subscriptions."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_SHARED_SUBSCRIPTIONS_NOT_ALLOWED: solClient_subCode =
    152;
#[doc = "< The client attempted to add a shared subscription to a queue or topic endpoint."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_SHARED_SUBSCRIPTIONS_ENDPOINT_NOT_ALLOWED:
    solClient_subCode = 153;
#[doc = "< The operation cannot be completed because the object (context, session, flow) for the method has been destroyed in another thread."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_OBJECT_DESTROYED: solClient_subCode = 154;
#[doc = "< The message was received from endpoint that does not support delivery count"]
pub const solClient_subCode_SOLCLIENT_SUBCODE_DELIVERY_COUNT_NOT_SUPPORTED: solClient_subCode = 155;
#[doc = "< A replay was requested but the requested start message is not available in the replay log."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_REPLAY_START_MESSAGE_UNAVAILABLE: solClient_subCode =
    156;
#[doc = "< Replication Group Message Id are not comparable. Messages must be published to the same broker or HA pair for their Replicaton Group Message Id to be comparable."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_MESSAGE_ID_NOT_COMPARABLE: solClient_subCode = 157;
#[doc = "< The client attempted to start replay on a flow bound to an anonymous queue."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_REPLAY_ANONYMOUS_NOT_SUPPORTED: solClient_subCode =
    158;
#[doc = "< Browser flows to Partitioned Queues are not permitted."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_BROWSING_NOT_SUPPORTED_ON_PARTITIONED_QUEUE:
    solClient_subCode = 159;
#[doc = "< Egress selectors are not permitted when binding to a Partitioned Queue."]
pub const solClient_subCode_SOLCLIENT_SUBCODE_SELECTORS_NOT_SUPPORTED_ON_PARTITIONED_QUEUE:
    solClient_subCode = 160;
#[doc = " @enum solClient_subCode\n A subcode that provides more detailed error information. The last subcode is stored\n on a per-thread basis and can be retrieved by an application thread.\n\n <b>NOTE: The error subCode is historic and only updated when an API does not return ::SOLCLIENT_OK. When an API call returns ::SOLCLIENT_OK\n the subCode is not meaningful and might not always be ::SOLCLIENT_SUBCODE_OK.</b>\n\n A subCode is always set when a API call does not return ::SOLCLIENT_OK.\n\n The application must be able to accept any subcode to allow for new subcodes to be\n added in the future and allow for forward compatibility. When examining and\n acting on the subcode, the application should act on any specific subcodes it\n needs to take different actions on, and then must perform a default action for any\n other subcode value.\n A subcode can be converted to a string through solClient_subCodeToString().\n\n The following subcodes can be returned from any API entry point: \\n\n ::SOLCLIENT_SUBCODE_INIT_NOT_CALLED (except for functions documented as being allowed to be called before ::solClient_initialize) \\n\n ::SOLCLIENT_SUBCODE_PARAM_OUT_OF_RANGE \\n\n ::SOLCLIENT_SUBCODE_PARAM_NULL_PTR (functions that accept pointer parameters) \\n\n ::SOLCLIENT_SUBCODE_PARAM_CONFLICT (functions that have interdependent parameters) \\n\n ::SOLCLIENT_SUBCODE_INTERNAL_ERROR \\n\n ::SOLCLIENT_SUBCODE_OS_ERROR \\n\n ::SOLCLIENT_SUBCODE_OUT_OF_MEMORY \\n\n ::SOLCLIENT_SUBCODE_CANNOT_BLOCK_IN_CONTEXT (functions that result in an interaction with the message router) \\n\n\n A complete list of SolClient subCodes, their meaning, and the broker response that caused them (when applicable) follows:\n\n <table>\n <tr> <th width=\"300\">SubCode</th> <th width=\"300\">Description</th> <th width=\"300\">Appliance Error Response</th></tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_OK                                    </td>\n     <td width=\"300\"> No error.                                               </td>\n     <td width=\"300\"> 200 OK                                                  </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_PARAM_OUT_OF_RANGE</td>\n     <td width=\"300\"> An API call was made with an out-of-range parameter.</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_PARAM_NULL_PTR</td>\n     <td width=\"300\"> An API call was made with a NULL pointer parameter.</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_PARAM_CONFLICT</td>\n     <td width=\"300\"> An API call was made with a parameter combination that is not valid.</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE</td>\n     <td width=\"300\"> An API call failed due to insufficient space to accept more data.</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"100\"> SOLCLIENT_SUBCODE_OUT_OF_RESOURCES</td>\n     <td width=\"300\"> An API call failed due to lack of resources (for example, starting a timer when all timers are in use).</td>\n     <td width=\"300\"> 400 Not Enough Space                                    </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INTERNAL_ERROR</td>\n     <td width=\"300\"> An API call had an internal error (not an application fault).</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_OUT_OF_MEMORY</td>\n     <td width=\"300\"> An API call failed due to inability to allocate memory.</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_PROTOCOL_ERROR</td>\n     <td width=\"300\"> An API call failed due to a protocol error with the broker (not an application fault).</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INIT_NOT_CALLED</td>\n     <td width=\"300\"> An API call failed due to solClient_initialize() not being called first.</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_TIMEOUT</td>\n     <td width=\"300\"> An API call failed due to a timeout.</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_KEEP_ALIVE_FAILURE</td>\n     <td width=\"300\"> The Session Keep-Alive detected a failed Session.</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SESSION_NOT_ESTABLISHED</td>\n     <td width=\"300\"> An API call failed due to the Session not being established.</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_OS_ERROR</td>\n     <td width=\"300\"> An API call failed due to a failed operating system call. An error string can be retrieved with solClient_getLastErrorInfo().</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_COMMUNICATION_ERROR</td>\n     <td width=\"300\"> An API call failed due to a communication error. An error string can be retrieved with solClient_getLastErrorInfo().</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_USER_DATA_TOO_LARGE</td>\n     <td width=\"300\"> Attempt to send a message with user data larger than the maximum that is supported.</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_TOPIC_TOO_LARGE</td>\n     <td width=\"300\"> An attempt to use a Topic which is longer than the maximum that is supported.</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INVALID_TOPIC_SYNTAX</td>\n     <td width=\"300\"> An attempt to use a Topic which has a syntax which is not supported.</td>\n     <td width=\"300\"> 400 Topic Parse Error                                   </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_XML_PARSE_ERROR</td>\n     <td width=\"300\"> The broker could not parse an XML message.</td>\n     <td width=\"300\"> 400 XML Parse Error                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_LOGIN_FAILURE</td>\n     <td width=\"300\"> The client could not log into the broker (bad username or password, unknown parameter, etc.)</td>\n     <td width=\"300\"> All 400, 401, 403 and 404 error codes from broker                  </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INVALID_VIRTUAL_ADDRESS</td>\n     <td width=\"300\"> An attempt to connect to the wrong IP address on the broker (must use CVRID if configured), or the broker CVRID has changed and this was detected on reconnect.</td>\n     <td width=\"300\"> 403 Invalid Virtual Router Address                       </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CLIENT_DELETE_IN_PROGRESS</td>\n     <td width=\"300\"> The client login not currently possible as previous instance of same client still being deleted.</td>\n     <td width=\"300\"> 503 Subscriber Delete In Progress                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_TOO_MANY_CLIENTS</td>\n     <td width=\"300\"> The client login not currently possible due to maximum number of active clients on broker has already been reached.</td>\n     <td width=\"300\"> \"503 Too Many Clients\" \"503 Too Many Publishers\" \"503 Too Many Subscribers\" \"400 Too Many Subscribers\"</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SUBSCRIPTION_ALREADY_PRESENT</td>\n     <td width=\"300\"> The client attempted to add a subscription which already exists - this subcode is only returned if the Session property SOLCLIENT_SESSION_PROP_IGNORE_DUP_SUBSCRIPTION_ERROR is not enabled.</td>\n     <td width=\"300\"> \"400 already exists\" \"400 Subscription Already Exists\"   </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SUBSCRIPTION_NOT_FOUND</td>\n     <td width=\"300\"> The client attempted to remove a subscription which did not exist - this subcode is only returned if the Session property SOLCLIENT_SESSION_PROP_IGNORE_DUP_SUBSCRIPTION_ERROR is not enabled.</td>\n     <td width=\"300\"> \"400 not found\" \"400 Subscription Not Found\"             </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SUBSCRIPTION_INVALID</td>\n     <td width=\"300\"> The client attempted to add/remove a subscription that is not valid.</td>\n     <td width=\"300\"> \"400 not supported\" \"400 parse error\" \"400 Subscription Parse Error\"</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SUBSCRIPTION_OTHER</td>\n     <td width=\"300\"> The broker rejected a subscription add or remove request for a reason not separately enumerated.</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CONTROL_OTHER</td>\n     <td width=\"300\"> The broker rejected a control message for another reason not separately enumerated.</td>\n     <td width=\"300\"> Default error subCode for broker error responses</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_DATA_OTHER</td>\n     <td width=\"300\"> The broker rejected a data message for another reason not separately enumerated.</td>\n     <td width=\"300\"> Default error subCode for error response to published data</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_LOG_FILE_ERROR</td>\n     <td width=\"300\"> Could not open the log file name specified by the application for writing (Deprecated - ::SOLCLIENT_SUBCODE_OS_ERROR is used).</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_MESSAGE_TOO_LARGE</td>\n     <td width=\"300\"> The client attempted to send a message larger than that supported by the broker.</td>\n     <td width=\"300\"> \"400 Document Is Too Large\" \"400 Message Too Long\"         </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SUBSCRIPTION_TOO_MANY</td>\n     <td width=\"300\"> The client attempted to add a subscription that exceeded the maximum number allowed. </td>\n     <td width=\"300\"> \"400 Max Num Subscriptions Exceeded\"                       </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INVALID_SESSION_OPERATION</td>\n     <td width=\"300\"> An API call failed due to the attempted operation not being valid for the Session. </td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_TOPIC_MISSING</td>\n     <td width=\"300\"> A send call was made that did not have a Topic in a mode where one is required (for example, client mode).</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_ASSURED_MESSAGING_NOT_ESTABLISHED</td>\n     <td width=\"300\"> A send call was made to send a Guaranteed message before Guaranteed Mesaging is established (Deprecated).</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_ASSURED_MESSAGING_STATE_ERROR</td>\n     <td width=\"300\"> An attempt was made to start Guaranteed Messaging when it is already started.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_QUEUENAME_TOPIC_CONFLICT</td>\n     <td width=\"300\"> Both Queue name and Topic are specified in solClient_session_send.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_QUEUENAME_TOO_LARGE</td>\n     <td width=\"300\"> An attempt was made to use a Queue name which is longer than the maximum supported length.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_QUEUENAME_INVALID_MODE</td>\n     <td width=\"300\"> An attempt was made to use a Queue name on a non-Guaranteed (that is, Direct) message.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_MAX_TOTAL_MSGSIZE_EXCEEDED</td>\n     <td width=\"300\"> An attempt was made to send a message with a total size greater than that supported by the protocol.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_DBLOCK_ALREADY_EXISTS</td>\n     <td width=\"300\"> An attempt was made to allocate a datablock for a msg element when one already exists.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_NO_STRUCTURED_DATA</td>\n     <td width=\"300\"> An attempt was made to create a container to read structured data where none exists.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CONTAINER_BUSY</td>\n     <td width=\"300\"> An attempt was made to add a field to a map or stream while a submap or substream is being built.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INVALID_DATA_CONVERSION</td>\n     <td width=\"300\"> An attempt was made to retrieve structured data with the wrong type.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CANNOT_MODIFY_WHILE_NOT_IDLE</td>\n     <td width=\"300\"> An attempt was made to modify a property that cannot be modified while Session is not idle.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_MSG_VPN_NOT_ALLOWED</td>\n     <td width=\"300\"> The Message VPN name configured for the session does not exist.</td>\n     <td width=\"300\"> 403 Message VPN Not Allowed</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CLIENT_NAME_INVALID</td>\n     <td width=\"300\"> The client name chosen has been rejected as invalid by the broker.</td>\n     <td width=\"300\"> 400 Client Name Parse Error</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_MSG_VPN_UNAVAILABLE</td>\n     <td width=\"300\"> The Message VPN name set for the Session (or the default VPN if none was set) is currently shutdown on the broker.</td>\n     <td width=\"300\"> 503 Message VPN Unavailable</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CLIENT_USERNAME_IS_SHUTDOWN</td>\n     <td width=\"300\"> The username for the client is administratively shutdown on the broker.</td>\n     <td width=\"300\"> 403 Client Username Is Shutdown </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_DYNAMIC_CLIENTS_NOT_ALLOWED</td>\n     <td width=\"300\"> The username for the Session has not been set and dynamic clients are not allowed.</td>\n     <td width=\"300\"> 403 Dynamic Clients Not Allowed</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CLIENT_NAME_ALREADY_IN_USE</td>\n     <td width=\"300\"> The Session is attempting to use a client, publisher, or subscriber name that is in use by another client, publisher or subscriber and the broker is configured to reject the new Session. When Message VPNs are in use, the conflicting client name must be in the same Message VPN.</td>\n     <td width=\"300\"> \"403 Client Name Already In Use\" \"403 Publisher Name Already In Use\" \"403 Subscriber Name Already In Use\"</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CACHE_NO_DATA</td>\n     <td width=\"300\"> When the cache request returns ::SOLCLIENT_INCOMPLETE, this subcode indicates there is no cached data in the designated cache.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CACHE_SUSPECT_DATA</td>\n     <td width=\"300\"> When the designated cache responds to a cache request with suspect data the API returns ::SOLCLIENT_INCOMPLETE with this subcode.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CACHE_ERROR_RESPONSE</td>\n     <td width=\"300\"> The cache instance has returned an error response to the request.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CACHE_INVALID_SESSION</td>\n     <td width=\"300\"> The cache session operation failed because the Session has been destroyed.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CACHE_TIMEOUT</td>\n     <td width=\"300\"> The cache session operation failed because the request timeout expired.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CACHE_LIVEDATA_FULFILL</td>\n     <td width=\"300\"> The cache session operation completed when live data arrived on the requested topic.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CACHE_ALREADY_IN_PROGRESS</td>\n     <td width=\"300\"> A cache request has been made when there is already a cache request outstanding on the same Topic and SOLCLIENT_CACHEREQUEST_FLAGS_LIVEDATA_FLOWTHRU was not set.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_MISSING_REPLY_TO</td>\n     <td width=\"300\"> A message does not have a required reply-to field.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CANNOT_BIND_TO_QUEUE</td>\n     <td width=\"300\"> Already bound to the Queue or not authorized to bind to the Queue.</td>\n     <td width=\"300\"> \"400 Cannot bind to another subscriber's topic queue\" \"400 Already Bound\"</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INVALID_TOPIC_NAME_FOR_TE</td>\n     <td width=\"300\"> An attempt was made to bind to a Guaranteed Delivery Topic Endpoint with an invalid topic.</td>\n     <td width=\"300\"> 400 Invalid Topic Name                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_UNKNOWN_QUEUE_NAME</td>\n     <td width=\"300\"> An attempt was made to bind to an unknown Queue name (for example, not configured on broker).</td>\n     <td width=\"300\"> 503 Unknown Queue                                          </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_UNKNOWN_TE_NAME</td>\n     <td width=\"300\"> An attempt was made to bind to an unknown Guaranteed Delivery Topic Endpoint name (for example, not configured on broker).</td>\n     <td width=\"300\"> \"503 Unknown Durable Topic Endpoint\"                       </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_MAX_CLIENTS_FOR_QUEUE</td>\n     <td width=\"300\"> An attempt was made to bind to a Guaranteed Delivery Queue which already has a maximum number of clients.</td>\n     <td width=\"300\"> 503 Max clients exceeded for Queue                         </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_MAX_CLIENTS_FOR_TE</td>\n     <td width=\"300\"> An attempt was made to bind to a Guaranteed Delivery Topic Endpoint that already has a maximum number of clients.</td>\n     <td width=\"300\"> 503 Max clients exceeded for durable Topic Endpoint        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_UNEXPECTED_UNBIND</td>\n     <td width=\"300\"> An unexpected unbind response was received for a Guaranteed Delivery Queue or Topic Endpoint (for example, Queue or Topic Endpoint was deleted from the broker).</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_QUEUE_NOT_FOUND</td>\n     <td width=\"300\"> The specified Guaranteed Delivery Queue was not found when publishing a message.</td>\n     <td width=\"300\"> 400 Queue Not Found                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CLIENT_ACL_DENIED</td>\n     <td width=\"300\"> The client login to the broker was denied because the IP address/netmask combination used for the client is designated in the ACL (Access Control List) as a deny connection for the given Message VPN and username.</td>\n     <td width=\"300\"> 403 Forbidden                                              </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SUBSCRIPTION_ACL_DENIED</td>\n     <td width=\"300\"> The adding of a subscription was denied because it matched a subscription that was defined on the ACL (Access Control List).</td>\n     <td width=\"300\"> 403 Subscription ACL Denied                                </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_PUBLISH_ACL_DENIED</td>\n     <td width=\"300\"> A message could not be published because its Topic matched that of a Topic defined on the ACL (Access Control List).</td>\n     <td width=\"300\"> 403 Publish ACL Denied                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_DELIVER_TO_ONE_INVALID</td>\n     <td width=\"300\"> An attempt was made to set both Deliver-To-One and Guaranteed Delivery in the same message.\n         (Deprecated: DTO will be applied to the corresponding demoted direct message)\n     </td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SPOOL_OVER_QUOTA</td>\n     <td width=\"300\"> Message was not delivered because the Guaranteed Message spool is over its allotted space quota.</td>\n     <td width=\"300\"> 503 Spool Over Quota                                       </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_QUEUE_SHUTDOWN</td>\n     <td width=\"300\"> An attempt was made to operate on a shutdown Guaranteed Delivery queue.</td>\n     <td width=\"300\"> 503 Queue Shutdown                                         </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_TE_SHUTDOWN</td>\n     <td width=\"300\"> An attempt was made to operate on a shutdown Guaranteed Delivery Topic Endpoint.</td>\n     <td width=\"300\"> 503 Durable Topic Endpoint Shutdown, 503 TE Shutdown, 503 Endpoint Shutdown                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_NO_MORE_NON_DURABLE_QUEUE_OR_TE</td>\n     <td width=\"300\"> An attempt was made to bind to a non-durable Guaranteed Delivery Queue or Topic Endpoint, and the broker is out of resources.</td>\n     <td width=\"300\"> 503 No More Non-Durable Queue or Topic Endpoint            </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_ENDPOINT_ALREADY_EXISTS</td>\n     <td width=\"300\"> An attempt was made to create a Queue or Topic Endpoint that already exists. This subcode is only returned if the provision flag SOLCLIENT_PROVISION_FLAGS_IGNORE_EXIST_ERRORS is not set in solClient_session_endpointProvision.</td>\n     <td width=\"300\"> 400 Endpoint Already Exists                                </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_PERMISSION_NOT_ALLOWED</td>\n     <td width=\"300\"> An attempt was made to delete or create a Queue or Topic Endpoint when the Session does not have authorization for the action. This subcode is also returned when an attempt is made to remove a message from an endpoint when the Session does not have 'consume' authorization, or when an attempt is made to add or remove a Topic subscription from a Queue when the Session does not have 'modify-topic' authorization.</td>\n     <td width=\"300\"> 403 Permission Denied                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INVALID_SELECTOR</td>\n     <td width=\"300\"> An attempt was made to bind to a Queue or Topic Endpoint with an invalid selector.</td>\n     <td width=\"300\"> 406 Invalid Selector                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_MAX_MESSAGE_USAGE_EXCEEDED</td>\n     <td width=\"300\"> Publishing the message was denied due to exceeding the maximum spooled message count.</td>\n     <td width=\"300\"> 503 Max message usage exceeded</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_ENDPOINT_PROPERTY_MISMATCH</td>\n     <td width=\"300\"> An attempt was made to create a dynamic durable endpoint, and it was found to exist with different properties. </td>\n     <td width=\"300\"> 401 Endpoint Property Mismatch</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SUBSCRIPTION_MANAGER_DENIED</td>\n     <td width=\"300\"> An attempt was made to add a subscription to another client when the Session does not have subscription manager privileges.</td>\n     <td width=\"300\"> 403 Subscription Manager Denied</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_UNKNOWN_CLIENT_NAME</td>\n     <td width=\"300\"> An attempt was made to add a subscription to another client that is unknown on the broker.</td>\n     <td width=\"300\"> 403 Unknown Client Name </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_QUOTA_OUT_OF_RANGE</td>\n     <td width=\"300\"> An attempt was made to provision an endpoint with a quota that is out of range.</td>\n     <td width=\"300\"> 400 Quota Out Of Range </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SUBSCRIPTION_ATTRIBUTES_CONFLICT</td>\n     <td width=\"300\"> The client attempted to add a subscription which already exists but it has different properties. </td>\n     <td width=\"300\"> 400 Subscription Attributes Conflict With Existing Subscription</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INVALID_SMF_MESSAGE</td>\n     <td width=\"300\"> The client attempted to send a Solace Message Format (SMF) message using solClient_session_sendSmf() or solClient_session_sendMultipleSmf(), but the buffer did not contain a Direct message.\n     </td>\n     <td width=\"300\"> N/A</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_NO_LOCAL_NOT_SUPPORTED</td>\n     <td width=\"300\"> The client attempted to establish a Session or Flow with No Local enabled and the capability is not supported by the broker.\n     </td>\n     <td width=\"300\"> N/A</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_UNSUBSCRIBE_NOT_ALLOWED_CLIENTS_BOUND</td>\n     <td width=\"300\"> The client attempted to unsubscribe a Topic from a Topic Endpoint while there were still Flows bound to the endpoint.\n     </td>\n     <td width=\"300\"> 400 Unsubscribe not allowed, client(s) bound to DTE.</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CANNOT_BLOCK_IN_CONTEXT</td>\n     <td width=\"300\"> An API function was invoked in the Context thread that would have blocked otherwise. For example, a call was made to send a message when the Session is configured with ::SOLCLIENT_SESSION_PROP_SEND_BLOCKING enabled and the transport (socket or IPC) channel is full. All application callback functions are executed in the Context thread.</td>\n     <td width=\"200\"> N/A.</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_FLOW_ACTIVE_FLOW_INDICATION_UNSUPPORTED</td>\n     <td width=\"300\"> Reserved For Future Use. </td>\n     <td width=\"200\"> N/A.</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_UNRESOLVED_HOST</td>\n     <td width=\"300\"> The client failed to connect because the host name could not be resolved. </td>\n     <td width=\"200\"> N/A.</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CUT_THROUGH_UNSUPPORTED</td>\n     <td width=\"300\"> An attempt was made to create a 'cut-through' Flow on a Session that does not support this capability. </td>\n     <td width=\"200\"> N/A.</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CUT_THROUGH_ALREADY_BOUND</td>\n     <td width=\"300\">  An attempt was made to create a 'cut-through' Flow on a Session that already has one 'cut-through' Flow. </td>\n     <td width=\"200\"> N/A.</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CUT_THROUGH_INCOMPATIBLE_WITH_SESSION</td>\n     <td width=\"300\"> An attempt was made to create a 'cut-through' Flow on a Session with incompatible Session properties. Cut-through may not be enabled on Sessions with SOLCLIENT_SESSION_PROP_TOPIC_DISPATCH enabled.</td>\n     <td width=\"200\"> N/A.</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INVALID_FLOW_OPERATION</td>\n     <td width=\"300\"> An API call failed due to the attempted operation not being valid for the Flow.</td>\n     <td width=\"200\"> N/A.</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_UNKNOWN_FLOW_NAME</td>\n     <td width=\"300\"> The session was disconnected due to loss of the publisher flow state. All (unacked and unsent) messages held by the API were deleted. To connect the session, applications need to call ::solClient_session_connect again.</td>\n     <td width=\"200\">  400 Unknown Flow Name</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_REPLICATION_IS_STANDBY</td>\n     <td width=\"300\"> An attempt to perform an operation using a VPN that is configured to be STANDBY for replication.</td>\n     <td width=\"200\"> 403 Replication Is Standby</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_LOW_PRIORITY_MSG_CONGESTION</td>\n     <td width=\"300\"> The message was rejected by the broker as one or more matching endpoints exceeded the reject-low-priority-msg-limit.</td>\n     <td width=\"200\"> 503 Low Priority Msg Congestion</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_FAILED_LOADING_TRUSTSTORE</td>\n     <td width=\"300\"> The client failed to load the trust store.</td>\n     <td width=\"200\"> N/A.</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_UNTRUSTED_CERTIFICATE</td>\n     <td width=\"300\"> The client attempted to connect to an broker that has a suspect certficate.</td>\n     <td width=\"200\"> N/A.</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CERTIFICATE_DATE_INVALID</td>\n     <td width=\"300\"> The client attempted to connect to an broker that does not have a valid certificate date.</td>\n     <td width=\"200\"> N/A.</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_LIBRARY_NOT_LOADED</td>\n     <td width=\"300\"> The client failed to find the library or symbol.</td>\n     <td width=\"200\"> N/A.</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_UNTRUSTED_COMMONNAME</td>\n     <td width=\"300\"> The client attempted to connect to an broker that has a suspect common name.</td>\n     <td width=\"200\"> N/A.</td>\n </tr>\n <tr>\n     <td width=\"300\">SOLCLIENT_SUBCODE_FAILED_LOADING_CERTIFICATE_AND_KEY</td>\n     <td width=\"300\">The client failed to load certificate and/or private key files. </td>\n     <td width=\"200\"> N/A.</td>\n </tr>\n <tr>\n     <td width=\"300\">SOLCLIENT_SUBCODE_BASIC_AUTHENTICATION_IS_SHUTDOWN </td>\n     <td width=\"300\">The client attempted to connect to an broker that has the basic authentication shutdown. </td>\n     <td width=\"200\"> 403 Basic Authentication is Shutdown</td>\n </tr>\n <tr>\n     <td width=\"300\">SOLCLIENT_SUBCODE_CLIENT_CERTIFICATE_AUTHENTICATION_IS_SHUTDOWN </td>\n     <td width=\"300\">The client attempted to connect to an broker that has the client certificate authentication shutdown. </td>\n     <td width=\"200\"> 403 Client Certificate Authentication is Shutdown</td>\n </tr>\n <tr>\n     <td width=\"300\">SOLCLIENT_SUBCODE_KERBEROS_AUTHENTICATION_IS_SHUTDOWN </td>\n     <td width=\"300\">The client attempted to connect to an broker that has the Kerberos authentication shutdown. </td>\n     <td width=\"200\"> 403 Kerberos Authentication is Shutdown</td>\n </tr>\n <tr>\n     <td width=\"300\">SOLCLIENT_SUBCODE_UNTRUSTED_CLIENT_CERTIFICATE </td>\n     <td width=\"300\"> The client failed to connect to an broker as it has a suspect client certificate.</td>\n     <td width=\"200\"> \"403 Untrusted Certificate\"  \"403 Certificate Chain Too Long\" \"403 Certificate Error\"</td>\n </tr>\n <tr>\n     <td width=\"300\">SOLCLIENT_SUBCODE_CLIENT_CERTIFICATE_DATE_INVALID </td>\n     <td width=\"300\"> The client failed to connect to an broker as it does not have a valid client certificate date. </td>\n     <td width=\"200\"> \"403 Certificate Not Yet Valid\" \"403 Certificate Expired\"</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CACHE_REQUEST_CANCELLED</td>\n     <td width=\"300\"> The cache session operation failed because the request has been cancelled.</td>\n     <td width=\"300\"> N/A. </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_DELIVERY_MODE_UNSUPPORTED</td>\n     <td width=\"300\"> Attempt was made from a Transacted Session to send a message with the delivery mode SOLCLIENT_DELIVERY_MODE_DIRECT.</td>\n     <td width=\"300\"> N/A. </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_PUBLISHER_NOT_CREATED</td>\n     <td width=\"300\"> Client attempted to send a message from a Transacted Session without creating a default publisher flow.</td>\n     <td width=\"300\"> N/A. </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_FLOW_UNBOUND</td>\n     <td width=\"300\"> The client attempted to receive message from an UNBOUND Flow with no queued messages in memory.</td>\n     <td width=\"300\"> N/A. </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INVALID_TRANSACTED_SESSION_ID</td>\n     <td width=\"300\"> The client attempted to commit or rollback a transaction with an invalid Transacted Session Id.</td>\n     <td width=\"300\"> N/A. </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INVALID_TRANSACTION_ID</td>\n     <td width=\"300\"> The client attempted to commit or rollback a transaction with an invalid transaction Id.</td>\n     <td width=\"300\"> N/A. </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_MAX_TRANSACTED_SESSIONS_EXCEEDED</td>\n     <td width=\"300\"> The client failed to open a Transacted Session as it exceeded the max Transacted Sessions.</td>\n     <td width=\"300\"> N/A. </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_TRANSACTED_SESSION_NAME_IN_USE</td>\n     <td width=\"300\"> The client failed to open a Transacted Session as the Transacted Session name provided is being used by another opened session.</td>\n     <td width=\"300\"> N/A. </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SERVICE_UNAVAILABLE</td>\n     <td width=\"300\"> Guaranteed Delivery services are not enabled on the broker.</td>\n     <td width=\"300\"> 503 Service Unavailable</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_NO_TRANSACTION_STARTED</td>\n     <td width=\"300\"> The client attempted to commit an unknown transaction.</td>\n     <td width=\"300\"> 400 No transaction started</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_PUBLISHER_NOT_ESTABLISHED</td>\n     <td width=\"300\"> A send call was made on a transacted session before its publisher is established.</td>\n     <td width=\"300\"> N/A. </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_MESSAGE_PUBLISH_FAILURE</td>\n     <td width=\"300\"> The client attempted to commit a transaction with a GD publish failure encountered.</td>\n     <td width=\"300\"> 503 Message Publish Failure</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_TRANSACTION_FAILURE</td>\n     <td width=\"300\"> The client attempted to commit a transaction with too many transaction steps.</td>\n     <td width=\"300\"> 503 Transaction Failure </td>\n </tr>\n <tr>\n     <td width=\"300\">SOLCLIENT_SUBCODE_MESSAGE_CONSUME_FAILURE </td>\n     <td width=\"300\"> The client attempted to commit a transaction with a consume failure encountered. </td>\n     <td width=\"300\"> 503 Message Consume Failure </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_ENDPOINT_MODIFIED</td>\n     <td width=\"300\"> The client attempted to commit a transaction with an Endpoint being shutdown or deleted. </td>\n     <td width=\"300\"> 503 Endpoint Modified </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INVALID_CONNECTION_OWNER </td>\n     <td width=\"300\"> The client attempted to commit a transaction with an unknown connection ID. </td>\n     <td width=\"300\"> 400 Invalid Connection Owner </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_COMMIT_OR_ROLLBACK_IN_PROGRESS </td>\n     <td width=\"300\">  The client attempted to send/receive a message or commit/rollback a transaction when a transaction commit/rollback is in progress. </td>\n     <td width=\"300\"> N/A</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_UNBIND_RESPONSE_LOST </td>\n     <td width=\"300\"> The application called solClient_flow_destroy() and the unbind-response was not received. </td>\n     <td width=\"300\"> N/A</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_MAX_TRANSACTIONS_EXCEEDED</td>\n     <td width=\"300\"> The client failed to open a Transacted Session as the maximum number of transactions was exceeded.</td>\n     <td width=\"300\"> N/A. </td>\n </tr>\n <tr>\n    <td width=\"300\"> SOLCLIENT_SUBCODE_COMMIT_STATUS_UNKNOWN</td>\n    <td width=\"300\"> The commit response was lost due to a transport layer reconnection to an alternate host in the host list.</td>\n    <td width=\"300\"> N/A. </td>\n </tr>\n <tr>\n    <td width=\"300\"> SOLCLIENT_SUBCODE_PROXY_AUTH_REQUIRED</td>\n    <td width=\"300\"> The host entry did not contain proxy authentication when required by the proxy server.</td>\n    <td width=\"300\"> 407 Proxy Authentication Required</td>\n </tr>\n <tr>\n    <td width=\"300\"> SOLCLIENT_SUBCODE_PROXY_AUTH_FAILURE</td>\n    <td width=\"300\"> The host entry did contained invalid proxy authentication when required by the proxy server.</td>\n    <td width=\"300\"> 407 Proxy Authentication Required</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_NO_SUBSCRIPTION_MATCH </td>\n     <td width=\"300\"> The client attempted to publish a guaranteed message to a topic that did not have any guaranteed subscription matches or only matched a replicated topic. </td>\n     <td width=\"300\"> 503 No Subscription Match </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SUBSCRIPTION_MATCH_ERROR </td>\n     <td width=\"300\"> The client attempted to bind to a non-exclusive topic endpoint that is already bound with a different subscription.</td>\n     <td width=\"300\"> 503 Subscription Does Not Match </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SELECTOR_MATCH_ERROR </td>\n     <td width=\"300\"> The client attempted to bind to a non-exclusive topic endpoint that is already bound with a different ingress selector.</td>\n     <td width=\"300\"> 503 Selector Does Not Match </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_REPLAY_NOT_SUPPORTED </td>\n     <td width=\"300\"> Replay is not supported in the Solace Message Router. </td>\n     <td width=\"300\"> N/A </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_REPLAY_DISABLED </td>\n     <td width=\"300\"> Replay is not enabled in the message-vpn. </td>\n     <td width=\"300\"> 503 Replay Disabled </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CLIENT_INITIATED_REPLAY_NON_EXCLUSIVE_NOT_ALLOWED </td>\n     <td width=\"300\"> The client attempted to start replay on a flow bound to a non-exclusive endpoint. </td>\n     <td width=\"300\"> 403 Client Initiated Replay Not Allowed on Non-Exclusive Topic Endpoint, 403 Client Initiated Replay Not Allowed on Non-Exclusive Queue </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CLIENT_INITIATED_REPLAY_INACTIVE_FLOW_NOT_ALLOWED </td>\n     <td width=\"300\"> The client attempted to start replay on an inactive flow. </td>\n     <td width=\"300\"> 403 Client Initiated Replay from Inactive Flow Not Allowed</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CLIENT_INITIATED_REPLAY_BROWSER_FLOW_NOT_ALLOWED </td>\n     <td width=\"300\"> The client attempted to bind with both ::SOLCLIENT_FLOW_PROP_BROWSER enabled and ::SOLCLIENT_FLOW_PROP_REPLAY_START_LOCATION set. </td>\n     <td width=\"300\"> 403 Client Initiated Replay from Browser Flow Not Allowed </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_REPLAY_TEMPORARY_NOT_SUPPORTED  </td>\n     <td width=\"300\"> Replay is not supported on temporary endpoints. </td>\n     <td width=\"300\"> 403 Replay Not Supported on Temporary Queue, 403 Replay Not Supported on Temporary Topic Endpoint </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_UNKNOWN_START_LOCATION_TYPE  </td>\n     <td width=\"300\"> The client attempted to start a replay but provided an unknown start location type. </td>\n     <td width=\"300\"> 403 Unknown Start Location Type </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_REPLAY_CANCELLED </td>\n     <td width=\"300\"> A replay in progress on a flow was administratively cancelled, causing the flow to be unbound. </td>\n     <td width=\"300\"> 503 Replay Cancelled </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_REPLAY_MESSAGE_UNAVAILABLE                     </td>\n     <td width=\"300\"> A replay in progress on a flow failed because messages to be replayed were trimmed from the replay log. </td>\n     <td width=\"300\"> 503 Replay Message Unavailable </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_REPLAY_STARTED                     </td>\n     <td width=\"300\"> A replay was started on the queue/topic endpoint, either by another client or by an administrator on the message router. </td>\n     <td width=\"300\"> 503 Replay Started </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_REPLAY_START_TIME_NOT_AVAILABLE                </td>\n     <td width=\"300\"> A replay was requested but the requested start time is not available in the replay log. </td>\n     <td width=\"300\"> 503 Replay Start Time Not Available </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_REPLAY_MESSAGE_REJECTED                        </td>\n     <td width=\"300\"> The Solace Message Router attempted to replay a message, but the queue/topic endpoint rejected the message to the sender. </td>\n     <td width=\"300\"> 503 Replayed Message Rejected by Queue, 503 Replayed Message Rejected by Topic Endpoint </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_REPLAY_LOG_MODIFIED                            </td>\n     <td width=\"300\"> A replay in progress on a flow failed because the replay log was modified. </td>\n     <td width=\"300\"> 503 Replay Log Modified </td>\n </tr>\n\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_MISMATCHED_ENDPOINT_ERROR_ID                   </td>\n     <td width=\"300\"> Endpoint error ID in the bind request does not match the endpoint's error ID. </td>\n     <td width=\"300\"> 503 Mismatched Endpoint Error ID </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_OUT_OF_REPLAY_RESOURCES                        </td>\n     <td width=\"300\"> A replay was requested, but the router does not have sufficient resources to fulfill the request, due to too many active replays. </td>\n     <td width=\"300\"> 503 Out of Replay Resources </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_TOPIC_OR_SELECTOR_MODIFIED_ON_DURABLE_TOPIC_ENDPOINT </td>\n     <td width=\"300\"> A replay was in progress on a Durable Topic Endpoint (DTE) when its topic or selector was modified, causing the replay to fail. </td>\n     <td width=\"300\"> 503 Topic or Selector Modified on Durable Topic Endpoint </td>\n </tr>\n\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_REPLAY_FAILED                                  </td>\n     <td width=\"300\"> A replay in progress on a flow failed. </td>\n     <td width=\"300\"> 503 Replay Failed </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_COMPRESSED_SSL_NOT_SUPPORTED </td>\n     <td width=\"300\"> The client attempted to establish a Session or Flow with ssl and compression, but the capability is not supported by the broker.</td>\n     <td width=\"300\"> N/A </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SHARED_SUBSCRIPTIONS_NOT_SUPPORTED </td>\n     <td width=\"300\"> The client attempted to add a shared subscription, but the capability is not supported by the broker.</td>\n     <td width=\"300\"> N/A </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SHARED_SUBSCRIPTIONS_NOT_ALLOWED </td>\n     <td width=\"300\"> The client attempted to add a shared subscription on a client that is not permitted to use shared subscriptions.</td>\n     <td width=\"300\"> 403 Shared Subscription Permission Denied </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SHARED_SUBSCRIPTIONS_ENDPOINT_NOT_ALLOWED </td>\n     <td width=\"300\"> The client attempted to add a shared subscription to a queue or topic endpoint.</td>\n     <td width=\"300\"> 403 Shared Subscriptions Not Supported On Queues, 403 Shared Subscriptions Not Supported On Topic Endpoints </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_OBJECT_DESTROYED</td>\n     <td width=\"300\"> The operation cannot be completed because the object (context, session, flow) for the method has been destroyed in another thread.</td>\n     <td width=\"300\"> N/A </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_DELIVERY_COUNT_NOT_SUPPORTED</td>\n     <td width=\"300\"> The message was received from endpoint that does not support delivery count</td>\n     <td width=\"300\"> N/A </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_REPLAY_START_MESSAGE_UNAVAILABLE </td>\n     <td width=\"300\"> A replay was requested but the requested start message is not available in the replay log. </td>\n     <td width=\"300\"> 403 Replay Start Message Unavailable </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_MESSAGE_ID_NOT_COMPARABLE </td>\n     <td width=\"300\"> Replication Group Message Id are not comparable. Messages must be published to the same broker or HA pair for their Replicaton Group Message Id to be comparable. </td>\n     <td width=\"300\"> N/A </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_REPLAY_ANONYMOUS_NOT_SUPPORTED </td>\n     <td width=\"300\"> The client attempted to start replay on a flow bound to an anonymous queue. </td>\n     <td width=\"300\"> 403 Replay Not Supported on Anonymous Queue </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_BROWSING_NOT_SUPPORTED_ON_PARTITIONED_QUEUE </td>\n     <td width=\"300\"> Browser flows to Partitioned Queues are not permitted. </td>\n     <td width=\"300\"> 403 Browsing Not Supported on Partitioned Queue </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SELECTORS_NOT_SUPPORTED_ON_PARTITIONED_QUEUE </td>\n     <td width=\"300\"> Egress selectors are not permitted when binding to a Partitioned Queue. </td>\n     <td width=\"300\"> 403 Selectors Not Supported on Partititoned Queue </td>\n </tr>\n </table>"]
pub type solClient_subCode = ::std::os::raw::c_uint;
#[doc = " @enum solClient_subCode\n A subcode that provides more detailed error information. The last subcode is stored\n on a per-thread basis and can be retrieved by an application thread.\n\n <b>NOTE: The error subCode is historic and only updated when an API does not return ::SOLCLIENT_OK. When an API call returns ::SOLCLIENT_OK\n the subCode is not meaningful and might not always be ::SOLCLIENT_SUBCODE_OK.</b>\n\n A subCode is always set when a API call does not return ::SOLCLIENT_OK.\n\n The application must be able to accept any subcode to allow for new subcodes to be\n added in the future and allow for forward compatibility. When examining and\n acting on the subcode, the application should act on any specific subcodes it\n needs to take different actions on, and then must perform a default action for any\n other subcode value.\n A subcode can be converted to a string through solClient_subCodeToString().\n\n The following subcodes can be returned from any API entry point: \\n\n ::SOLCLIENT_SUBCODE_INIT_NOT_CALLED (except for functions documented as being allowed to be called before ::solClient_initialize) \\n\n ::SOLCLIENT_SUBCODE_PARAM_OUT_OF_RANGE \\n\n ::SOLCLIENT_SUBCODE_PARAM_NULL_PTR (functions that accept pointer parameters) \\n\n ::SOLCLIENT_SUBCODE_PARAM_CONFLICT (functions that have interdependent parameters) \\n\n ::SOLCLIENT_SUBCODE_INTERNAL_ERROR \\n\n ::SOLCLIENT_SUBCODE_OS_ERROR \\n\n ::SOLCLIENT_SUBCODE_OUT_OF_MEMORY \\n\n ::SOLCLIENT_SUBCODE_CANNOT_BLOCK_IN_CONTEXT (functions that result in an interaction with the message router) \\n\n\n A complete list of SolClient subCodes, their meaning, and the broker response that caused them (when applicable) follows:\n\n <table>\n <tr> <th width=\"300\">SubCode</th> <th width=\"300\">Description</th> <th width=\"300\">Appliance Error Response</th></tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_OK                                    </td>\n     <td width=\"300\"> No error.                                               </td>\n     <td width=\"300\"> 200 OK                                                  </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_PARAM_OUT_OF_RANGE</td>\n     <td width=\"300\"> An API call was made with an out-of-range parameter.</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_PARAM_NULL_PTR</td>\n     <td width=\"300\"> An API call was made with a NULL pointer parameter.</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_PARAM_CONFLICT</td>\n     <td width=\"300\"> An API call was made with a parameter combination that is not valid.</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE</td>\n     <td width=\"300\"> An API call failed due to insufficient space to accept more data.</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"100\"> SOLCLIENT_SUBCODE_OUT_OF_RESOURCES</td>\n     <td width=\"300\"> An API call failed due to lack of resources (for example, starting a timer when all timers are in use).</td>\n     <td width=\"300\"> 400 Not Enough Space                                    </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INTERNAL_ERROR</td>\n     <td width=\"300\"> An API call had an internal error (not an application fault).</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_OUT_OF_MEMORY</td>\n     <td width=\"300\"> An API call failed due to inability to allocate memory.</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_PROTOCOL_ERROR</td>\n     <td width=\"300\"> An API call failed due to a protocol error with the broker (not an application fault).</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INIT_NOT_CALLED</td>\n     <td width=\"300\"> An API call failed due to solClient_initialize() not being called first.</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_TIMEOUT</td>\n     <td width=\"300\"> An API call failed due to a timeout.</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_KEEP_ALIVE_FAILURE</td>\n     <td width=\"300\"> The Session Keep-Alive detected a failed Session.</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SESSION_NOT_ESTABLISHED</td>\n     <td width=\"300\"> An API call failed due to the Session not being established.</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_OS_ERROR</td>\n     <td width=\"300\"> An API call failed due to a failed operating system call. An error string can be retrieved with solClient_getLastErrorInfo().</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_COMMUNICATION_ERROR</td>\n     <td width=\"300\"> An API call failed due to a communication error. An error string can be retrieved with solClient_getLastErrorInfo().</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_USER_DATA_TOO_LARGE</td>\n     <td width=\"300\"> Attempt to send a message with user data larger than the maximum that is supported.</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_TOPIC_TOO_LARGE</td>\n     <td width=\"300\"> An attempt to use a Topic which is longer than the maximum that is supported.</td>\n     <td width=\"300\"> N/A                                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INVALID_TOPIC_SYNTAX</td>\n     <td width=\"300\"> An attempt to use a Topic which has a syntax which is not supported.</td>\n     <td width=\"300\"> 400 Topic Parse Error                                   </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_XML_PARSE_ERROR</td>\n     <td width=\"300\"> The broker could not parse an XML message.</td>\n     <td width=\"300\"> 400 XML Parse Error                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_LOGIN_FAILURE</td>\n     <td width=\"300\"> The client could not log into the broker (bad username or password, unknown parameter, etc.)</td>\n     <td width=\"300\"> All 400, 401, 403 and 404 error codes from broker                  </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INVALID_VIRTUAL_ADDRESS</td>\n     <td width=\"300\"> An attempt to connect to the wrong IP address on the broker (must use CVRID if configured), or the broker CVRID has changed and this was detected on reconnect.</td>\n     <td width=\"300\"> 403 Invalid Virtual Router Address                       </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CLIENT_DELETE_IN_PROGRESS</td>\n     <td width=\"300\"> The client login not currently possible as previous instance of same client still being deleted.</td>\n     <td width=\"300\"> 503 Subscriber Delete In Progress                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_TOO_MANY_CLIENTS</td>\n     <td width=\"300\"> The client login not currently possible due to maximum number of active clients on broker has already been reached.</td>\n     <td width=\"300\"> \"503 Too Many Clients\" \"503 Too Many Publishers\" \"503 Too Many Subscribers\" \"400 Too Many Subscribers\"</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SUBSCRIPTION_ALREADY_PRESENT</td>\n     <td width=\"300\"> The client attempted to add a subscription which already exists - this subcode is only returned if the Session property SOLCLIENT_SESSION_PROP_IGNORE_DUP_SUBSCRIPTION_ERROR is not enabled.</td>\n     <td width=\"300\"> \"400 already exists\" \"400 Subscription Already Exists\"   </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SUBSCRIPTION_NOT_FOUND</td>\n     <td width=\"300\"> The client attempted to remove a subscription which did not exist - this subcode is only returned if the Session property SOLCLIENT_SESSION_PROP_IGNORE_DUP_SUBSCRIPTION_ERROR is not enabled.</td>\n     <td width=\"300\"> \"400 not found\" \"400 Subscription Not Found\"             </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SUBSCRIPTION_INVALID</td>\n     <td width=\"300\"> The client attempted to add/remove a subscription that is not valid.</td>\n     <td width=\"300\"> \"400 not supported\" \"400 parse error\" \"400 Subscription Parse Error\"</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SUBSCRIPTION_OTHER</td>\n     <td width=\"300\"> The broker rejected a subscription add or remove request for a reason not separately enumerated.</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CONTROL_OTHER</td>\n     <td width=\"300\"> The broker rejected a control message for another reason not separately enumerated.</td>\n     <td width=\"300\"> Default error subCode for broker error responses</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_DATA_OTHER</td>\n     <td width=\"300\"> The broker rejected a data message for another reason not separately enumerated.</td>\n     <td width=\"300\"> Default error subCode for error response to published data</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_LOG_FILE_ERROR</td>\n     <td width=\"300\"> Could not open the log file name specified by the application for writing (Deprecated - ::SOLCLIENT_SUBCODE_OS_ERROR is used).</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_MESSAGE_TOO_LARGE</td>\n     <td width=\"300\"> The client attempted to send a message larger than that supported by the broker.</td>\n     <td width=\"300\"> \"400 Document Is Too Large\" \"400 Message Too Long\"         </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SUBSCRIPTION_TOO_MANY</td>\n     <td width=\"300\"> The client attempted to add a subscription that exceeded the maximum number allowed. </td>\n     <td width=\"300\"> \"400 Max Num Subscriptions Exceeded\"                       </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INVALID_SESSION_OPERATION</td>\n     <td width=\"300\"> An API call failed due to the attempted operation not being valid for the Session. </td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_TOPIC_MISSING</td>\n     <td width=\"300\"> A send call was made that did not have a Topic in a mode where one is required (for example, client mode).</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_ASSURED_MESSAGING_NOT_ESTABLISHED</td>\n     <td width=\"300\"> A send call was made to send a Guaranteed message before Guaranteed Mesaging is established (Deprecated).</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_ASSURED_MESSAGING_STATE_ERROR</td>\n     <td width=\"300\"> An attempt was made to start Guaranteed Messaging when it is already started.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_QUEUENAME_TOPIC_CONFLICT</td>\n     <td width=\"300\"> Both Queue name and Topic are specified in solClient_session_send.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_QUEUENAME_TOO_LARGE</td>\n     <td width=\"300\"> An attempt was made to use a Queue name which is longer than the maximum supported length.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_QUEUENAME_INVALID_MODE</td>\n     <td width=\"300\"> An attempt was made to use a Queue name on a non-Guaranteed (that is, Direct) message.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_MAX_TOTAL_MSGSIZE_EXCEEDED</td>\n     <td width=\"300\"> An attempt was made to send a message with a total size greater than that supported by the protocol.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_DBLOCK_ALREADY_EXISTS</td>\n     <td width=\"300\"> An attempt was made to allocate a datablock for a msg element when one already exists.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_NO_STRUCTURED_DATA</td>\n     <td width=\"300\"> An attempt was made to create a container to read structured data where none exists.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CONTAINER_BUSY</td>\n     <td width=\"300\"> An attempt was made to add a field to a map or stream while a submap or substream is being built.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INVALID_DATA_CONVERSION</td>\n     <td width=\"300\"> An attempt was made to retrieve structured data with the wrong type.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CANNOT_MODIFY_WHILE_NOT_IDLE</td>\n     <td width=\"300\"> An attempt was made to modify a property that cannot be modified while Session is not idle.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_MSG_VPN_NOT_ALLOWED</td>\n     <td width=\"300\"> The Message VPN name configured for the session does not exist.</td>\n     <td width=\"300\"> 403 Message VPN Not Allowed</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CLIENT_NAME_INVALID</td>\n     <td width=\"300\"> The client name chosen has been rejected as invalid by the broker.</td>\n     <td width=\"300\"> 400 Client Name Parse Error</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_MSG_VPN_UNAVAILABLE</td>\n     <td width=\"300\"> The Message VPN name set for the Session (or the default VPN if none was set) is currently shutdown on the broker.</td>\n     <td width=\"300\"> 503 Message VPN Unavailable</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CLIENT_USERNAME_IS_SHUTDOWN</td>\n     <td width=\"300\"> The username for the client is administratively shutdown on the broker.</td>\n     <td width=\"300\"> 403 Client Username Is Shutdown </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_DYNAMIC_CLIENTS_NOT_ALLOWED</td>\n     <td width=\"300\"> The username for the Session has not been set and dynamic clients are not allowed.</td>\n     <td width=\"300\"> 403 Dynamic Clients Not Allowed</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CLIENT_NAME_ALREADY_IN_USE</td>\n     <td width=\"300\"> The Session is attempting to use a client, publisher, or subscriber name that is in use by another client, publisher or subscriber and the broker is configured to reject the new Session. When Message VPNs are in use, the conflicting client name must be in the same Message VPN.</td>\n     <td width=\"300\"> \"403 Client Name Already In Use\" \"403 Publisher Name Already In Use\" \"403 Subscriber Name Already In Use\"</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CACHE_NO_DATA</td>\n     <td width=\"300\"> When the cache request returns ::SOLCLIENT_INCOMPLETE, this subcode indicates there is no cached data in the designated cache.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CACHE_SUSPECT_DATA</td>\n     <td width=\"300\"> When the designated cache responds to a cache request with suspect data the API returns ::SOLCLIENT_INCOMPLETE with this subcode.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CACHE_ERROR_RESPONSE</td>\n     <td width=\"300\"> The cache instance has returned an error response to the request.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CACHE_INVALID_SESSION</td>\n     <td width=\"300\"> The cache session operation failed because the Session has been destroyed.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CACHE_TIMEOUT</td>\n     <td width=\"300\"> The cache session operation failed because the request timeout expired.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CACHE_LIVEDATA_FULFILL</td>\n     <td width=\"300\"> The cache session operation completed when live data arrived on the requested topic.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CACHE_ALREADY_IN_PROGRESS</td>\n     <td width=\"300\"> A cache request has been made when there is already a cache request outstanding on the same Topic and SOLCLIENT_CACHEREQUEST_FLAGS_LIVEDATA_FLOWTHRU was not set.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_MISSING_REPLY_TO</td>\n     <td width=\"300\"> A message does not have a required reply-to field.</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CANNOT_BIND_TO_QUEUE</td>\n     <td width=\"300\"> Already bound to the Queue or not authorized to bind to the Queue.</td>\n     <td width=\"300\"> \"400 Cannot bind to another subscriber's topic queue\" \"400 Already Bound\"</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INVALID_TOPIC_NAME_FOR_TE</td>\n     <td width=\"300\"> An attempt was made to bind to a Guaranteed Delivery Topic Endpoint with an invalid topic.</td>\n     <td width=\"300\"> 400 Invalid Topic Name                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_UNKNOWN_QUEUE_NAME</td>\n     <td width=\"300\"> An attempt was made to bind to an unknown Queue name (for example, not configured on broker).</td>\n     <td width=\"300\"> 503 Unknown Queue                                          </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_UNKNOWN_TE_NAME</td>\n     <td width=\"300\"> An attempt was made to bind to an unknown Guaranteed Delivery Topic Endpoint name (for example, not configured on broker).</td>\n     <td width=\"300\"> \"503 Unknown Durable Topic Endpoint\"                       </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_MAX_CLIENTS_FOR_QUEUE</td>\n     <td width=\"300\"> An attempt was made to bind to a Guaranteed Delivery Queue which already has a maximum number of clients.</td>\n     <td width=\"300\"> 503 Max clients exceeded for Queue                         </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_MAX_CLIENTS_FOR_TE</td>\n     <td width=\"300\"> An attempt was made to bind to a Guaranteed Delivery Topic Endpoint that already has a maximum number of clients.</td>\n     <td width=\"300\"> 503 Max clients exceeded for durable Topic Endpoint        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_UNEXPECTED_UNBIND</td>\n     <td width=\"300\"> An unexpected unbind response was received for a Guaranteed Delivery Queue or Topic Endpoint (for example, Queue or Topic Endpoint was deleted from the broker).</td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_QUEUE_NOT_FOUND</td>\n     <td width=\"300\"> The specified Guaranteed Delivery Queue was not found when publishing a message.</td>\n     <td width=\"300\"> 400 Queue Not Found                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CLIENT_ACL_DENIED</td>\n     <td width=\"300\"> The client login to the broker was denied because the IP address/netmask combination used for the client is designated in the ACL (Access Control List) as a deny connection for the given Message VPN and username.</td>\n     <td width=\"300\"> 403 Forbidden                                              </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SUBSCRIPTION_ACL_DENIED</td>\n     <td width=\"300\"> The adding of a subscription was denied because it matched a subscription that was defined on the ACL (Access Control List).</td>\n     <td width=\"300\"> 403 Subscription ACL Denied                                </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_PUBLISH_ACL_DENIED</td>\n     <td width=\"300\"> A message could not be published because its Topic matched that of a Topic defined on the ACL (Access Control List).</td>\n     <td width=\"300\"> 403 Publish ACL Denied                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_DELIVER_TO_ONE_INVALID</td>\n     <td width=\"300\"> An attempt was made to set both Deliver-To-One and Guaranteed Delivery in the same message.\n         (Deprecated: DTO will be applied to the corresponding demoted direct message)\n     </td>\n     <td width=\"300\"> N/A                                                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SPOOL_OVER_QUOTA</td>\n     <td width=\"300\"> Message was not delivered because the Guaranteed Message spool is over its allotted space quota.</td>\n     <td width=\"300\"> 503 Spool Over Quota                                       </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_QUEUE_SHUTDOWN</td>\n     <td width=\"300\"> An attempt was made to operate on a shutdown Guaranteed Delivery queue.</td>\n     <td width=\"300\"> 503 Queue Shutdown                                         </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_TE_SHUTDOWN</td>\n     <td width=\"300\"> An attempt was made to operate on a shutdown Guaranteed Delivery Topic Endpoint.</td>\n     <td width=\"300\"> 503 Durable Topic Endpoint Shutdown, 503 TE Shutdown, 503 Endpoint Shutdown                        </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_NO_MORE_NON_DURABLE_QUEUE_OR_TE</td>\n     <td width=\"300\"> An attempt was made to bind to a non-durable Guaranteed Delivery Queue or Topic Endpoint, and the broker is out of resources.</td>\n     <td width=\"300\"> 503 No More Non-Durable Queue or Topic Endpoint            </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_ENDPOINT_ALREADY_EXISTS</td>\n     <td width=\"300\"> An attempt was made to create a Queue or Topic Endpoint that already exists. This subcode is only returned if the provision flag SOLCLIENT_PROVISION_FLAGS_IGNORE_EXIST_ERRORS is not set in solClient_session_endpointProvision.</td>\n     <td width=\"300\"> 400 Endpoint Already Exists                                </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_PERMISSION_NOT_ALLOWED</td>\n     <td width=\"300\"> An attempt was made to delete or create a Queue or Topic Endpoint when the Session does not have authorization for the action. This subcode is also returned when an attempt is made to remove a message from an endpoint when the Session does not have 'consume' authorization, or when an attempt is made to add or remove a Topic subscription from a Queue when the Session does not have 'modify-topic' authorization.</td>\n     <td width=\"300\"> 403 Permission Denied                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INVALID_SELECTOR</td>\n     <td width=\"300\"> An attempt was made to bind to a Queue or Topic Endpoint with an invalid selector.</td>\n     <td width=\"300\"> 406 Invalid Selector                                     </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_MAX_MESSAGE_USAGE_EXCEEDED</td>\n     <td width=\"300\"> Publishing the message was denied due to exceeding the maximum spooled message count.</td>\n     <td width=\"300\"> 503 Max message usage exceeded</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_ENDPOINT_PROPERTY_MISMATCH</td>\n     <td width=\"300\"> An attempt was made to create a dynamic durable endpoint, and it was found to exist with different properties. </td>\n     <td width=\"300\"> 401 Endpoint Property Mismatch</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SUBSCRIPTION_MANAGER_DENIED</td>\n     <td width=\"300\"> An attempt was made to add a subscription to another client when the Session does not have subscription manager privileges.</td>\n     <td width=\"300\"> 403 Subscription Manager Denied</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_UNKNOWN_CLIENT_NAME</td>\n     <td width=\"300\"> An attempt was made to add a subscription to another client that is unknown on the broker.</td>\n     <td width=\"300\"> 403 Unknown Client Name </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_QUOTA_OUT_OF_RANGE</td>\n     <td width=\"300\"> An attempt was made to provision an endpoint with a quota that is out of range.</td>\n     <td width=\"300\"> 400 Quota Out Of Range </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SUBSCRIPTION_ATTRIBUTES_CONFLICT</td>\n     <td width=\"300\"> The client attempted to add a subscription which already exists but it has different properties. </td>\n     <td width=\"300\"> 400 Subscription Attributes Conflict With Existing Subscription</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INVALID_SMF_MESSAGE</td>\n     <td width=\"300\"> The client attempted to send a Solace Message Format (SMF) message using solClient_session_sendSmf() or solClient_session_sendMultipleSmf(), but the buffer did not contain a Direct message.\n     </td>\n     <td width=\"300\"> N/A</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_NO_LOCAL_NOT_SUPPORTED</td>\n     <td width=\"300\"> The client attempted to establish a Session or Flow with No Local enabled and the capability is not supported by the broker.\n     </td>\n     <td width=\"300\"> N/A</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_UNSUBSCRIBE_NOT_ALLOWED_CLIENTS_BOUND</td>\n     <td width=\"300\"> The client attempted to unsubscribe a Topic from a Topic Endpoint while there were still Flows bound to the endpoint.\n     </td>\n     <td width=\"300\"> 400 Unsubscribe not allowed, client(s) bound to DTE.</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CANNOT_BLOCK_IN_CONTEXT</td>\n     <td width=\"300\"> An API function was invoked in the Context thread that would have blocked otherwise. For example, a call was made to send a message when the Session is configured with ::SOLCLIENT_SESSION_PROP_SEND_BLOCKING enabled and the transport (socket or IPC) channel is full. All application callback functions are executed in the Context thread.</td>\n     <td width=\"200\"> N/A.</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_FLOW_ACTIVE_FLOW_INDICATION_UNSUPPORTED</td>\n     <td width=\"300\"> Reserved For Future Use. </td>\n     <td width=\"200\"> N/A.</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_UNRESOLVED_HOST</td>\n     <td width=\"300\"> The client failed to connect because the host name could not be resolved. </td>\n     <td width=\"200\"> N/A.</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CUT_THROUGH_UNSUPPORTED</td>\n     <td width=\"300\"> An attempt was made to create a 'cut-through' Flow on a Session that does not support this capability. </td>\n     <td width=\"200\"> N/A.</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CUT_THROUGH_ALREADY_BOUND</td>\n     <td width=\"300\">  An attempt was made to create a 'cut-through' Flow on a Session that already has one 'cut-through' Flow. </td>\n     <td width=\"200\"> N/A.</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CUT_THROUGH_INCOMPATIBLE_WITH_SESSION</td>\n     <td width=\"300\"> An attempt was made to create a 'cut-through' Flow on a Session with incompatible Session properties. Cut-through may not be enabled on Sessions with SOLCLIENT_SESSION_PROP_TOPIC_DISPATCH enabled.</td>\n     <td width=\"200\"> N/A.</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INVALID_FLOW_OPERATION</td>\n     <td width=\"300\"> An API call failed due to the attempted operation not being valid for the Flow.</td>\n     <td width=\"200\"> N/A.</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_UNKNOWN_FLOW_NAME</td>\n     <td width=\"300\"> The session was disconnected due to loss of the publisher flow state. All (unacked and unsent) messages held by the API were deleted. To connect the session, applications need to call ::solClient_session_connect again.</td>\n     <td width=\"200\">  400 Unknown Flow Name</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_REPLICATION_IS_STANDBY</td>\n     <td width=\"300\"> An attempt to perform an operation using a VPN that is configured to be STANDBY for replication.</td>\n     <td width=\"200\"> 403 Replication Is Standby</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_LOW_PRIORITY_MSG_CONGESTION</td>\n     <td width=\"300\"> The message was rejected by the broker as one or more matching endpoints exceeded the reject-low-priority-msg-limit.</td>\n     <td width=\"200\"> 503 Low Priority Msg Congestion</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_FAILED_LOADING_TRUSTSTORE</td>\n     <td width=\"300\"> The client failed to load the trust store.</td>\n     <td width=\"200\"> N/A.</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_UNTRUSTED_CERTIFICATE</td>\n     <td width=\"300\"> The client attempted to connect to an broker that has a suspect certficate.</td>\n     <td width=\"200\"> N/A.</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CERTIFICATE_DATE_INVALID</td>\n     <td width=\"300\"> The client attempted to connect to an broker that does not have a valid certificate date.</td>\n     <td width=\"200\"> N/A.</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_LIBRARY_NOT_LOADED</td>\n     <td width=\"300\"> The client failed to find the library or symbol.</td>\n     <td width=\"200\"> N/A.</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_UNTRUSTED_COMMONNAME</td>\n     <td width=\"300\"> The client attempted to connect to an broker that has a suspect common name.</td>\n     <td width=\"200\"> N/A.</td>\n </tr>\n <tr>\n     <td width=\"300\">SOLCLIENT_SUBCODE_FAILED_LOADING_CERTIFICATE_AND_KEY</td>\n     <td width=\"300\">The client failed to load certificate and/or private key files. </td>\n     <td width=\"200\"> N/A.</td>\n </tr>\n <tr>\n     <td width=\"300\">SOLCLIENT_SUBCODE_BASIC_AUTHENTICATION_IS_SHUTDOWN </td>\n     <td width=\"300\">The client attempted to connect to an broker that has the basic authentication shutdown. </td>\n     <td width=\"200\"> 403 Basic Authentication is Shutdown</td>\n </tr>\n <tr>\n     <td width=\"300\">SOLCLIENT_SUBCODE_CLIENT_CERTIFICATE_AUTHENTICATION_IS_SHUTDOWN </td>\n     <td width=\"300\">The client attempted to connect to an broker that has the client certificate authentication shutdown. </td>\n     <td width=\"200\"> 403 Client Certificate Authentication is Shutdown</td>\n </tr>\n <tr>\n     <td width=\"300\">SOLCLIENT_SUBCODE_KERBEROS_AUTHENTICATION_IS_SHUTDOWN </td>\n     <td width=\"300\">The client attempted to connect to an broker that has the Kerberos authentication shutdown. </td>\n     <td width=\"200\"> 403 Kerberos Authentication is Shutdown</td>\n </tr>\n <tr>\n     <td width=\"300\">SOLCLIENT_SUBCODE_UNTRUSTED_CLIENT_CERTIFICATE </td>\n     <td width=\"300\"> The client failed to connect to an broker as it has a suspect client certificate.</td>\n     <td width=\"200\"> \"403 Untrusted Certificate\"  \"403 Certificate Chain Too Long\" \"403 Certificate Error\"</td>\n </tr>\n <tr>\n     <td width=\"300\">SOLCLIENT_SUBCODE_CLIENT_CERTIFICATE_DATE_INVALID </td>\n     <td width=\"300\"> The client failed to connect to an broker as it does not have a valid client certificate date. </td>\n     <td width=\"200\"> \"403 Certificate Not Yet Valid\" \"403 Certificate Expired\"</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CACHE_REQUEST_CANCELLED</td>\n     <td width=\"300\"> The cache session operation failed because the request has been cancelled.</td>\n     <td width=\"300\"> N/A. </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_DELIVERY_MODE_UNSUPPORTED</td>\n     <td width=\"300\"> Attempt was made from a Transacted Session to send a message with the delivery mode SOLCLIENT_DELIVERY_MODE_DIRECT.</td>\n     <td width=\"300\"> N/A. </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_PUBLISHER_NOT_CREATED</td>\n     <td width=\"300\"> Client attempted to send a message from a Transacted Session without creating a default publisher flow.</td>\n     <td width=\"300\"> N/A. </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_FLOW_UNBOUND</td>\n     <td width=\"300\"> The client attempted to receive message from an UNBOUND Flow with no queued messages in memory.</td>\n     <td width=\"300\"> N/A. </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INVALID_TRANSACTED_SESSION_ID</td>\n     <td width=\"300\"> The client attempted to commit or rollback a transaction with an invalid Transacted Session Id.</td>\n     <td width=\"300\"> N/A. </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INVALID_TRANSACTION_ID</td>\n     <td width=\"300\"> The client attempted to commit or rollback a transaction with an invalid transaction Id.</td>\n     <td width=\"300\"> N/A. </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_MAX_TRANSACTED_SESSIONS_EXCEEDED</td>\n     <td width=\"300\"> The client failed to open a Transacted Session as it exceeded the max Transacted Sessions.</td>\n     <td width=\"300\"> N/A. </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_TRANSACTED_SESSION_NAME_IN_USE</td>\n     <td width=\"300\"> The client failed to open a Transacted Session as the Transacted Session name provided is being used by another opened session.</td>\n     <td width=\"300\"> N/A. </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SERVICE_UNAVAILABLE</td>\n     <td width=\"300\"> Guaranteed Delivery services are not enabled on the broker.</td>\n     <td width=\"300\"> 503 Service Unavailable</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_NO_TRANSACTION_STARTED</td>\n     <td width=\"300\"> The client attempted to commit an unknown transaction.</td>\n     <td width=\"300\"> 400 No transaction started</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_PUBLISHER_NOT_ESTABLISHED</td>\n     <td width=\"300\"> A send call was made on a transacted session before its publisher is established.</td>\n     <td width=\"300\"> N/A. </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_MESSAGE_PUBLISH_FAILURE</td>\n     <td width=\"300\"> The client attempted to commit a transaction with a GD publish failure encountered.</td>\n     <td width=\"300\"> 503 Message Publish Failure</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_TRANSACTION_FAILURE</td>\n     <td width=\"300\"> The client attempted to commit a transaction with too many transaction steps.</td>\n     <td width=\"300\"> 503 Transaction Failure </td>\n </tr>\n <tr>\n     <td width=\"300\">SOLCLIENT_SUBCODE_MESSAGE_CONSUME_FAILURE </td>\n     <td width=\"300\"> The client attempted to commit a transaction with a consume failure encountered. </td>\n     <td width=\"300\"> 503 Message Consume Failure </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_ENDPOINT_MODIFIED</td>\n     <td width=\"300\"> The client attempted to commit a transaction with an Endpoint being shutdown or deleted. </td>\n     <td width=\"300\"> 503 Endpoint Modified </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_INVALID_CONNECTION_OWNER </td>\n     <td width=\"300\"> The client attempted to commit a transaction with an unknown connection ID. </td>\n     <td width=\"300\"> 400 Invalid Connection Owner </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_COMMIT_OR_ROLLBACK_IN_PROGRESS </td>\n     <td width=\"300\">  The client attempted to send/receive a message or commit/rollback a transaction when a transaction commit/rollback is in progress. </td>\n     <td width=\"300\"> N/A</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_UNBIND_RESPONSE_LOST </td>\n     <td width=\"300\"> The application called solClient_flow_destroy() and the unbind-response was not received. </td>\n     <td width=\"300\"> N/A</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_MAX_TRANSACTIONS_EXCEEDED</td>\n     <td width=\"300\"> The client failed to open a Transacted Session as the maximum number of transactions was exceeded.</td>\n     <td width=\"300\"> N/A. </td>\n </tr>\n <tr>\n    <td width=\"300\"> SOLCLIENT_SUBCODE_COMMIT_STATUS_UNKNOWN</td>\n    <td width=\"300\"> The commit response was lost due to a transport layer reconnection to an alternate host in the host list.</td>\n    <td width=\"300\"> N/A. </td>\n </tr>\n <tr>\n    <td width=\"300\"> SOLCLIENT_SUBCODE_PROXY_AUTH_REQUIRED</td>\n    <td width=\"300\"> The host entry did not contain proxy authentication when required by the proxy server.</td>\n    <td width=\"300\"> 407 Proxy Authentication Required</td>\n </tr>\n <tr>\n    <td width=\"300\"> SOLCLIENT_SUBCODE_PROXY_AUTH_FAILURE</td>\n    <td width=\"300\"> The host entry did contained invalid proxy authentication when required by the proxy server.</td>\n    <td width=\"300\"> 407 Proxy Authentication Required</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_NO_SUBSCRIPTION_MATCH </td>\n     <td width=\"300\"> The client attempted to publish a guaranteed message to a topic that did not have any guaranteed subscription matches or only matched a replicated topic. </td>\n     <td width=\"300\"> 503 No Subscription Match </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SUBSCRIPTION_MATCH_ERROR </td>\n     <td width=\"300\"> The client attempted to bind to a non-exclusive topic endpoint that is already bound with a different subscription.</td>\n     <td width=\"300\"> 503 Subscription Does Not Match </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SELECTOR_MATCH_ERROR </td>\n     <td width=\"300\"> The client attempted to bind to a non-exclusive topic endpoint that is already bound with a different ingress selector.</td>\n     <td width=\"300\"> 503 Selector Does Not Match </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_REPLAY_NOT_SUPPORTED </td>\n     <td width=\"300\"> Replay is not supported in the Solace Message Router. </td>\n     <td width=\"300\"> N/A </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_REPLAY_DISABLED </td>\n     <td width=\"300\"> Replay is not enabled in the message-vpn. </td>\n     <td width=\"300\"> 503 Replay Disabled </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CLIENT_INITIATED_REPLAY_NON_EXCLUSIVE_NOT_ALLOWED </td>\n     <td width=\"300\"> The client attempted to start replay on a flow bound to a non-exclusive endpoint. </td>\n     <td width=\"300\"> 403 Client Initiated Replay Not Allowed on Non-Exclusive Topic Endpoint, 403 Client Initiated Replay Not Allowed on Non-Exclusive Queue </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CLIENT_INITIATED_REPLAY_INACTIVE_FLOW_NOT_ALLOWED </td>\n     <td width=\"300\"> The client attempted to start replay on an inactive flow. </td>\n     <td width=\"300\"> 403 Client Initiated Replay from Inactive Flow Not Allowed</td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_CLIENT_INITIATED_REPLAY_BROWSER_FLOW_NOT_ALLOWED </td>\n     <td width=\"300\"> The client attempted to bind with both ::SOLCLIENT_FLOW_PROP_BROWSER enabled and ::SOLCLIENT_FLOW_PROP_REPLAY_START_LOCATION set. </td>\n     <td width=\"300\"> 403 Client Initiated Replay from Browser Flow Not Allowed </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_REPLAY_TEMPORARY_NOT_SUPPORTED  </td>\n     <td width=\"300\"> Replay is not supported on temporary endpoints. </td>\n     <td width=\"300\"> 403 Replay Not Supported on Temporary Queue, 403 Replay Not Supported on Temporary Topic Endpoint </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_UNKNOWN_START_LOCATION_TYPE  </td>\n     <td width=\"300\"> The client attempted to start a replay but provided an unknown start location type. </td>\n     <td width=\"300\"> 403 Unknown Start Location Type </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_REPLAY_CANCELLED </td>\n     <td width=\"300\"> A replay in progress on a flow was administratively cancelled, causing the flow to be unbound. </td>\n     <td width=\"300\"> 503 Replay Cancelled </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_REPLAY_MESSAGE_UNAVAILABLE                     </td>\n     <td width=\"300\"> A replay in progress on a flow failed because messages to be replayed were trimmed from the replay log. </td>\n     <td width=\"300\"> 503 Replay Message Unavailable </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_REPLAY_STARTED                     </td>\n     <td width=\"300\"> A replay was started on the queue/topic endpoint, either by another client or by an administrator on the message router. </td>\n     <td width=\"300\"> 503 Replay Started </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_REPLAY_START_TIME_NOT_AVAILABLE                </td>\n     <td width=\"300\"> A replay was requested but the requested start time is not available in the replay log. </td>\n     <td width=\"300\"> 503 Replay Start Time Not Available </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_REPLAY_MESSAGE_REJECTED                        </td>\n     <td width=\"300\"> The Solace Message Router attempted to replay a message, but the queue/topic endpoint rejected the message to the sender. </td>\n     <td width=\"300\"> 503 Replayed Message Rejected by Queue, 503 Replayed Message Rejected by Topic Endpoint </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_REPLAY_LOG_MODIFIED                            </td>\n     <td width=\"300\"> A replay in progress on a flow failed because the replay log was modified. </td>\n     <td width=\"300\"> 503 Replay Log Modified </td>\n </tr>\n\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_MISMATCHED_ENDPOINT_ERROR_ID                   </td>\n     <td width=\"300\"> Endpoint error ID in the bind request does not match the endpoint's error ID. </td>\n     <td width=\"300\"> 503 Mismatched Endpoint Error ID </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_OUT_OF_REPLAY_RESOURCES                        </td>\n     <td width=\"300\"> A replay was requested, but the router does not have sufficient resources to fulfill the request, due to too many active replays. </td>\n     <td width=\"300\"> 503 Out of Replay Resources </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_TOPIC_OR_SELECTOR_MODIFIED_ON_DURABLE_TOPIC_ENDPOINT </td>\n     <td width=\"300\"> A replay was in progress on a Durable Topic Endpoint (DTE) when its topic or selector was modified, causing the replay to fail. </td>\n     <td width=\"300\"> 503 Topic or Selector Modified on Durable Topic Endpoint </td>\n </tr>\n\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_REPLAY_FAILED                                  </td>\n     <td width=\"300\"> A replay in progress on a flow failed. </td>\n     <td width=\"300\"> 503 Replay Failed </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_COMPRESSED_SSL_NOT_SUPPORTED </td>\n     <td width=\"300\"> The client attempted to establish a Session or Flow with ssl and compression, but the capability is not supported by the broker.</td>\n     <td width=\"300\"> N/A </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SHARED_SUBSCRIPTIONS_NOT_SUPPORTED </td>\n     <td width=\"300\"> The client attempted to add a shared subscription, but the capability is not supported by the broker.</td>\n     <td width=\"300\"> N/A </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SHARED_SUBSCRIPTIONS_NOT_ALLOWED </td>\n     <td width=\"300\"> The client attempted to add a shared subscription on a client that is not permitted to use shared subscriptions.</td>\n     <td width=\"300\"> 403 Shared Subscription Permission Denied </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SHARED_SUBSCRIPTIONS_ENDPOINT_NOT_ALLOWED </td>\n     <td width=\"300\"> The client attempted to add a shared subscription to a queue or topic endpoint.</td>\n     <td width=\"300\"> 403 Shared Subscriptions Not Supported On Queues, 403 Shared Subscriptions Not Supported On Topic Endpoints </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_OBJECT_DESTROYED</td>\n     <td width=\"300\"> The operation cannot be completed because the object (context, session, flow) for the method has been destroyed in another thread.</td>\n     <td width=\"300\"> N/A </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_DELIVERY_COUNT_NOT_SUPPORTED</td>\n     <td width=\"300\"> The message was received from endpoint that does not support delivery count</td>\n     <td width=\"300\"> N/A </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_REPLAY_START_MESSAGE_UNAVAILABLE </td>\n     <td width=\"300\"> A replay was requested but the requested start message is not available in the replay log. </td>\n     <td width=\"300\"> 403 Replay Start Message Unavailable </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_MESSAGE_ID_NOT_COMPARABLE </td>\n     <td width=\"300\"> Replication Group Message Id are not comparable. Messages must be published to the same broker or HA pair for their Replicaton Group Message Id to be comparable. </td>\n     <td width=\"300\"> N/A </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_REPLAY_ANONYMOUS_NOT_SUPPORTED </td>\n     <td width=\"300\"> The client attempted to start replay on a flow bound to an anonymous queue. </td>\n     <td width=\"300\"> 403 Replay Not Supported on Anonymous Queue </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_BROWSING_NOT_SUPPORTED_ON_PARTITIONED_QUEUE </td>\n     <td width=\"300\"> Browser flows to Partitioned Queues are not permitted. </td>\n     <td width=\"300\"> 403 Browsing Not Supported on Partitioned Queue </td>\n </tr>\n <tr>\n     <td width=\"300\"> SOLCLIENT_SUBCODE_SELECTORS_NOT_SUPPORTED_ON_PARTITIONED_QUEUE </td>\n     <td width=\"300\"> Egress selectors are not permitted when binding to a Partitioned Queue. </td>\n     <td width=\"300\"> 403 Selectors Not Supported on Partititoned Queue </td>\n </tr>\n </table>"]
pub use self::solClient_subCode as solClient_subCode_t;
#[doc = "< This level is not used by the API."]
pub const solClient_log_level_SOLCLIENT_LOG_EMERGENCY: solClient_log_level = 0;
#[doc = "< This level is not used by the API."]
pub const solClient_log_level_SOLCLIENT_LOG_ALERT: solClient_log_level = 1;
#[doc = "< A serious error that can make the API unusable."]
pub const solClient_log_level_SOLCLIENT_LOG_CRITICAL: solClient_log_level = 2;
#[doc = "< An unexpected condition within the API that can affect its operation."]
pub const solClient_log_level_SOLCLIENT_LOG_ERROR: solClient_log_level = 3;
#[doc = "< An unexpected condition within the API that is not expected to affect its operation."]
pub const solClient_log_level_SOLCLIENT_LOG_WARNING: solClient_log_level = 4;
#[doc = "< Significant informational messages about the normal operation of the API. These messages are never output in the normal process of sending or receiving a message from the broker."]
pub const solClient_log_level_SOLCLIENT_LOG_NOTICE: solClient_log_level = 5;
#[doc = "< Informational messages about the normal operation of the API. These might include information related to sending or receiving messages from the broker."]
pub const solClient_log_level_SOLCLIENT_LOG_INFO: solClient_log_level = 6;
#[doc = "< Debugging information generally useful to API developers (very verbose)."]
pub const solClient_log_level_SOLCLIENT_LOG_DEBUG: solClient_log_level = 7;
#[doc = " @enum solClient_log_level\n Definition of SolClient log levels.\n To avoid affecting performance, do not set the API log filter level to\n SOLCLIENT_LOG_INFO or SOLCLIENT_LOG_DEBUG unless required for debugging.\n A log level can be converted to a string through solClient_log_levelToString()."]
pub type solClient_log_level = ::std::os::raw::c_uint;
#[doc = " @enum solClient_log_level\n Definition of SolClient log levels.\n To avoid affecting performance, do not set the API log filter level to\n SOLCLIENT_LOG_INFO or SOLCLIENT_LOG_DEBUG unless required for debugging.\n A log level can be converted to a string through solClient_log_levelToString()."]
pub use self::solClient_log_level as solClient_log_level_t;
#[doc = "< Set log level filter for all categories."]
pub const solClient_log_category_SOLCLIENT_LOG_CATEGORY_ALL: solClient_log_category = 0;
#[doc = "< Set log level filter for API internal logs."]
pub const solClient_log_category_SOLCLIENT_LOG_CATEGORY_SDK: solClient_log_category = 1;
#[doc = "< Set log level filter for application logs."]
pub const solClient_log_category_SOLCLIENT_LOG_CATEGORY_APP: solClient_log_category = 2;
#[doc = " @enum solClient_log_category\n Definition of SolClient log categories, which is used for log level filter control.\n Each category can have its log level set independently.\n SOLCLIENT_LOG_CATEGORY_SDK refers to logs which are generated internally within the C\n API. SOLCLIENT_LOG_CATEGORY_APP refers to logs raised by the application through\n solClient_log().\n A log category can be converted to a string through solClient_log_categoryToString()."]
pub type solClient_log_category = ::std::os::raw::c_uint;
#[doc = " @enum solClient_log_category\n Definition of SolClient log categories, which is used for log level filter control.\n Each category can have its log level set independently.\n SOLCLIENT_LOG_CATEGORY_SDK refers to logs which are generated internally within the C\n API. SOLCLIENT_LOG_CATEGORY_APP refers to logs raised by the application through\n solClient_log().\n A log category can be converted to a string through solClient_log_categoryToString()."]
pub use self::solClient_log_category as solClient_log_category_t;
pub type solClient_fd_t = ::std::os::raw::c_int;
pub type solClient_fdEvent_t = solClient_uint32_t;
pub type solClient_subscribeFlags_t = solClient_uint32_t;
pub type solClient_session_responseCode_t = solClient_uint32_t;
pub type solClient_msgId_t = solClient_uint64_t;
pub type solClient_modifyPropFlags_t = solClient_uint32_t;
#[doc = " @struct solClient_uuid\n\n A structure used to hold a UUID (Universally Unique Identifier), as per IETF RFC 4122. The structure\n is 128 bits. A UUID can be generated through solClient_generateUUID(). A string form of a UUID\n can be generated through solClient_generateUUIDString()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct solClient_uuid {
    #[doc = "< As defined in IETF RFC 4122."]
    pub timeLow: solClient_uint32_t,
    #[doc = "< As defined in IETF RFC 4122."]
    pub timeMid: solClient_uint16_t,
    #[doc = "< As defined in IETF RFC 4122."]
    pub timeHiAndVersion: solClient_uint16_t,
    #[doc = "< As defined in IETF RFC 4122."]
    pub clockSeqHiAndReserved: solClient_uint8_t,
    #[doc = "< As defined in IETF RFC 4122."]
    pub clockSeqLow: solClient_uint8_t,
    #[doc = "< As defined in IETF RFC 4122."]
    pub node: [solClient_uint8_t; 6usize],
}
#[test]
fn bindgen_test_layout_solClient_uuid() {
    const UNINIT: ::std::mem::MaybeUninit<solClient_uuid> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<solClient_uuid>(),
        16usize,
        concat!("Size of: ", stringify!(solClient_uuid))
    );
    assert_eq!(
        ::std::mem::align_of::<solClient_uuid>(),
        4usize,
        concat!("Alignment of ", stringify!(solClient_uuid))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeLow) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_uuid),
            "::",
            stringify!(timeLow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeMid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_uuid),
            "::",
            stringify!(timeMid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeHiAndVersion) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_uuid),
            "::",
            stringify!(timeHiAndVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clockSeqHiAndReserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_uuid),
            "::",
            stringify!(clockSeqHiAndReserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clockSeqLow) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_uuid),
            "::",
            stringify!(clockSeqLow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_uuid),
            "::",
            stringify!(node)
        )
    );
}
#[doc = " @struct solClient_uuid\n\n A structure used to hold a UUID (Universally Unique Identifier), as per IETF RFC 4122. The structure\n is 128 bits. A UUID can be generated through solClient_generateUUID(). A string form of a UUID\n can be generated through solClient_generateUUIDString()."]
pub type solClient_uuid_t = solClient_uuid;
#[doc = "< The Session is established."]
pub const solClient_session_event_SOLCLIENT_SESSION_EVENT_UP_NOTICE: solClient_session_event = 0;
#[doc = "< The Session was established and then went down."]
pub const solClient_session_event_SOLCLIENT_SESSION_EVENT_DOWN_ERROR: solClient_session_event = 1;
#[doc = "< The Session attempted to connect but was unsuccessful."]
pub const solClient_session_event_SOLCLIENT_SESSION_EVENT_CONNECT_FAILED_ERROR:
    solClient_session_event = 2;
#[doc = "< The broker rejected a published message."]
pub const solClient_session_event_SOLCLIENT_SESSION_EVENT_REJECTED_MSG_ERROR:
    solClient_session_event = 3;
#[doc = "< The broker rejected a subscription (add or remove)."]
pub const solClient_session_event_SOLCLIENT_SESSION_EVENT_SUBSCRIPTION_ERROR:
    solClient_session_event = 4;
#[doc = "< The API discarded a received message that exceeded the Session buffer size."]
pub const solClient_session_event_SOLCLIENT_SESSION_EVENT_RX_MSG_TOO_BIG_ERROR:
    solClient_session_event = 5;
#[doc = "< The oldest transmitted Persistent/Non-Persistent message that has been acknowledged."]
pub const solClient_session_event_SOLCLIENT_SESSION_EVENT_ACKNOWLEDGEMENT: solClient_session_event =
    6;
#[doc = "< Deprecated -- see notes in solClient_session_startAssuredPublishing. The AD Handshake (that is, Guaranteed Delivery handshake) has completed for the publisher and Guaranteed messages can be sent."]
pub const solClient_session_event_SOLCLIENT_SESSION_EVENT_ASSURED_PUBLISHING_UP:
    solClient_session_event = 7;
#[doc = "< Deprecated -- see notes in solClient_session_startAssuredPublishing. The broker rejected the AD Handshake to start Guaranteed publishing. Use ::SOLCLIENT_SESSION_EVENT_ASSURED_DELIVERY_DOWN instead."]
pub const solClient_session_event_SOLCLIENT_SESSION_EVENT_ASSURED_CONNECT_FAILED:
    solClient_session_event = 8;
#[doc = "< Guaranteed Delivery publishing is not available. The guaranteed delivery capability on the session has been disabled by some action on the broker."]
pub const solClient_session_event_SOLCLIENT_SESSION_EVENT_ASSURED_DELIVERY_DOWN:
    solClient_session_event = 8;
#[doc = "< The Topic Endpoint unsubscribe command failed."]
pub const solClient_session_event_SOLCLIENT_SESSION_EVENT_TE_UNSUBSCRIBE_ERROR:
    solClient_session_event = 9;
#[doc = "< Deprecated name; ::SOLCLIENT_SESSION_EVENT_TE_UNSUBSCRIBE_ERROR is preferred"]
pub const solClient_session_event_SOLCLIENT_SESSION_EVENT_DTE_UNSUBSCRIBE_ERROR:
    solClient_session_event = 9;
#[doc = "< The Topic Endpoint unsubscribe completed."]
pub const solClient_session_event_SOLCLIENT_SESSION_EVENT_TE_UNSUBSCRIBE_OK:
    solClient_session_event = 10;
#[doc = "< Deprecated name; ::SOLCLIENT_SESSION_EVENT_TE_UNSUBSCRIBE_OK is preferred"]
pub const solClient_session_event_SOLCLIENT_SESSION_EVENT_DTE_UNSUBSCRIBE_OK:
    solClient_session_event = 10;
#[doc = "< The send is no longer blocked."]
pub const solClient_session_event_SOLCLIENT_SESSION_EVENT_CAN_SEND: solClient_session_event = 11;
#[doc = "< The Session has gone down, and an automatic reconnect attempt is in progress."]
pub const solClient_session_event_SOLCLIENT_SESSION_EVENT_RECONNECTING_NOTICE:
    solClient_session_event = 12;
#[doc = "< The automatic reconnect of the Session was successful, and the Session was established again."]
pub const solClient_session_event_SOLCLIENT_SESSION_EVENT_RECONNECTED_NOTICE:
    solClient_session_event = 13;
#[doc = "< The endpoint create/delete command failed."]
pub const solClient_session_event_SOLCLIENT_SESSION_EVENT_PROVISION_ERROR: solClient_session_event =
    14;
#[doc = "< The endpoint create/delete command completed."]
pub const solClient_session_event_SOLCLIENT_SESSION_EVENT_PROVISION_OK: solClient_session_event =
    15;
#[doc = "< The subscribe or unsubscribe operation has succeeded."]
pub const solClient_session_event_SOLCLIENT_SESSION_EVENT_SUBSCRIPTION_OK: solClient_session_event =
    16;
#[doc = "< The broker's Virtual Router Name changed during a reconnect operation. This could render existing queues or temporary topics invalid."]
pub const solClient_session_event_SOLCLIENT_SESSION_EVENT_VIRTUAL_ROUTER_NAME_CHANGED:
    solClient_session_event = 17;
#[doc = "< The session property modification completed."]
pub const solClient_session_event_SOLCLIENT_SESSION_EVENT_MODIFYPROP_OK: solClient_session_event =
    18;
#[doc = "< The session property modification failed."]
pub const solClient_session_event_SOLCLIENT_SESSION_EVENT_MODIFYPROP_FAIL: solClient_session_event =
    19;
#[doc = "< After successfully reconnecting a disconnected session, the SDK received an unknown publisher flow name response when reconnecting the GD publisher flow. If configured to auto-retry (See ::SOLCLIENT_SESSION_PROP_GD_RECONNECT_FAIL_ACTION.) this event is generated to indicate how many unacknowledged messages are retransmitted on success. As the publisher state has been lost on failover, receiving this event may indicate that some messages have been duplicated in the system."]
pub const solClient_session_event_SOLCLIENT_SESSION_EVENT_REPUBLISH_UNACKED_MESSAGES:
    solClient_session_event = 20;
#[doc = " @enum solClient_session_event\n Session events that can be given to the Session event callback routine registered for\n a Session. The Session event callback is registered when a Session is created\n through solClient_session_create(), and it has the prototype ::solClient_session_eventCallbackFunc_t.\n A Session event can be converted to a string value through solClient_session_eventToString()."]
pub type solClient_session_event = ::std::os::raw::c_uint;
#[doc = " @enum solClient_session_event\n Session events that can be given to the Session event callback routine registered for\n a Session. The Session event callback is registered when a Session is created\n through solClient_session_create(), and it has the prototype ::solClient_session_eventCallbackFunc_t.\n A Session event can be converted to a string value through solClient_session_eventToString()."]
pub use self::solClient_session_event as solClient_session_event_t;
#[doc = "< The Flow is established."]
pub const solClient_flow_event_SOLCLIENT_FLOW_EVENT_UP_NOTICE: solClient_flow_event = 0;
#[doc = "< The Flow was established and then disconnected by the broker, due to an operator action. The Flow must be destroyed."]
pub const solClient_flow_event_SOLCLIENT_FLOW_EVENT_DOWN_ERROR: solClient_flow_event = 1;
#[doc = "< The Flow attempted to connect but was unsuccessful."]
pub const solClient_flow_event_SOLCLIENT_FLOW_EVENT_BIND_FAILED_ERROR: solClient_flow_event = 2;
#[doc = "< This event is deprecated and will never be raised."]
pub const solClient_flow_event_SOLCLIENT_FLOW_EVENT_REJECTED_MSG_ERROR: solClient_flow_event = 3;
#[doc = "< The Session for the Flow was disconnected. The Flow will rebound automatically when the Session is reconnected."]
pub const solClient_flow_event_SOLCLIENT_FLOW_EVENT_SESSION_DOWN: solClient_flow_event = 4;
#[doc = "< The flow has become active"]
pub const solClient_flow_event_SOLCLIENT_FLOW_EVENT_ACTIVE: solClient_flow_event = 5;
#[doc = "< The flow has become inactive"]
pub const solClient_flow_event_SOLCLIENT_FLOW_EVENT_INACTIVE: solClient_flow_event = 6;
#[doc = "< The Flow was established and then disconnected by the broker, due to operator action, either 'Replay Started' or 'shutdown' on the queue, topic endpoint, or message spool.  The API is attempting to reconnect the flow automatically"]
pub const solClient_flow_event_SOLCLIENT_FLOW_EVENT_RECONNECTING: solClient_flow_event = 7;
#[doc = "< The Flow was successfully reconnected to the broker"]
pub const solClient_flow_event_SOLCLIENT_FLOW_EVENT_RECONNECTED: solClient_flow_event = 8;
#[doc = " @enum solClient_flow_event\n Flow events that can be given to the Flow event callback routine registered for\n a Flow. The Flow event callback is registered when a Flow is created through\n solClient_session_createFlow() and has the prototype ::solClient_flow_eventCallbackFunc_t.\n A Flow event can be converted to a string value through solClient_flow_eventToString()."]
pub type solClient_flow_event = ::std::os::raw::c_uint;
#[doc = " @enum solClient_flow_event\n Flow events that can be given to the Flow event callback routine registered for\n a Flow. The Flow event callback is registered when a Flow is created through\n solClient_session_createFlow() and has the prototype ::solClient_flow_eventCallbackFunc_t.\n A Flow event can be converted to a string value through solClient_flow_eventToString()."]
pub use self::solClient_flow_event as solClient_flow_event_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct solClient_errorInfo {
    #[doc = "< A subcode indicating the type of error."]
    pub subCode: solClient_subCode_t,
    #[doc = "< A response code that is returned for some subcodes; otherwise zero."]
    pub responseCode: solClient_session_responseCode_t,
    #[doc = "< An information string (max length ::SOLCLIENT_ERRORINFO_STR_SIZE) for certain types of subcodes (empty string, if not used)."]
    pub errorStr: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_solClient_errorInfo() {
    const UNINIT: ::std::mem::MaybeUninit<solClient_errorInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<solClient_errorInfo>(),
        264usize,
        concat!("Size of: ", stringify!(solClient_errorInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<solClient_errorInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(solClient_errorInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_errorInfo),
            "::",
            stringify!(subCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).responseCode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_errorInfo),
            "::",
            stringify!(responseCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errorStr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_errorInfo),
            "::",
            stringify!(errorStr)
        )
    );
}
pub type solClient_errorInfo_pt = *mut solClient_errorInfo;
#[doc = " @struct solClient_bufInfo\n A structure used to point to a message part and indicate the size of that part\n (in bytes)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct solClient_bufInfo {
    #[doc = "< A pointer to buffer."]
    pub buf_p: *mut ::std::os::raw::c_void,
    #[doc = "< The number of valid bytes in buffer."]
    pub bufSize: solClient_uint32_t,
}
#[test]
fn bindgen_test_layout_solClient_bufInfo() {
    const UNINIT: ::std::mem::MaybeUninit<solClient_bufInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<solClient_bufInfo>(),
        16usize,
        concat!("Size of: ", stringify!(solClient_bufInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<solClient_bufInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(solClient_bufInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_bufInfo),
            "::",
            stringify!(buf_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bufSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_bufInfo),
            "::",
            stringify!(bufSize)
        )
    );
}
#[doc = " @struct solClient_bufInfo\n A structure used to point to a message part and indicate the size of that part\n (in bytes)."]
pub type solClient_bufInfo_t = solClient_bufInfo;
pub type solClient_bufInfo_pt = *mut solClient_bufInfo_t;
pub type solClient_stats_pt = *mut solClient_uint64_t;
#[doc = "< The number of bytes received."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_DIRECT_BYTES: solClient_stats_rx = 0;
#[doc = "< Deprecated name, ::SOLCLIENT_STATS_RX_DIRECT_BYTES is preferred"]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_BYTES: solClient_stats_rx = 0;
#[doc = "< The number of messages received."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_DIRECT_MSGS: solClient_stats_rx = 1;
#[doc = "< Deprecated name, ::SOLCLIENT_STATS_RX_DIRECT_MSGS is preferred."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_MSGS: solClient_stats_rx = 1;
#[doc = "< The number of non-empty reads."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_READS: solClient_stats_rx = 2;
#[doc = "< The number of receive messages with discard indication set."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_DISCARD_IND: solClient_stats_rx = 3;
#[doc = "< The number of messages discarded due to the presence of an unknown element or unknown protocol in the Solace Message Format (SMF) header."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_DISCARD_SMF_UNKNOWN_ELEMENT: solClient_stats_rx = 4;
#[doc = "< Deprecated, use the more accurately named SOLCLIENT_STATS_RX_DISCARD_SMF_UNKNOWN_ELEMENT instead."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_DISCARD_MSG_HDR_ERROR: solClient_stats_rx = 4;
#[doc = "< The number of messages discarded due to msg too large."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_DISCARD_MSG_TOO_BIG: solClient_stats_rx = 5;
#[doc = "< The number of acknowledgments sent for Guaranteed messages."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_ACKED: solClient_stats_rx = 6;
#[doc = "< The number of Guaranteed messages dropped for being duplicates."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_DISCARD_DUPLICATE: solClient_stats_rx = 7;
#[doc = "< The number of Guaranteed messages discarded due to no match on the flowId."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_DISCARD_NO_MATCHING_FLOW: solClient_stats_rx = 8;
#[doc = "< The number of Guaranteed messages discarded for being received out of order."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_DISCARD_OUTOFORDER: solClient_stats_rx = 9;
#[doc = "< The number of Persistent bytes received on the Flow. On the Session, it is the total number of Persistent bytes received across all Flows."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_PERSISTENT_BYTES: solClient_stats_rx = 10;
#[doc = "< The number of Persistent messages received on the Flow. On the Session, it is the total number of Persistent messages received across all Flows."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_PERSISTENT_MSGS: solClient_stats_rx = 11;
#[doc = "< The number of Persistent bytes received on the Flow. On the Session, it is the total number of Persistent bytes received across all Flows."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_NONPERSISTENT_BYTES: solClient_stats_rx = 12;
#[doc = "< The number of Persistent messages received on the Flow. On the Session, it is the total number of Persistent messages received across all Flows."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_NONPERSISTENT_MSGS: solClient_stats_rx = 13;
#[doc = "< The number of control (non-data) messages received."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_CTL_MSGS: solClient_stats_rx = 14;
#[doc = "< The number of bytes received in control (non-data) messages."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_CTL_BYTES: solClient_stats_rx = 15;
#[doc = "< The total number of data bytes received."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_TOTAL_DATA_BYTES: solClient_stats_rx = 16;
#[doc = "< The total number of data messages received."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_TOTAL_DATA_MSGS: solClient_stats_rx = 17;
#[doc = "< The number of bytes received before decompression."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_COMPRESSED_BYTES: solClient_stats_rx = 18;
#[doc = "<  The reply messages received."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_REPLY_MSG: solClient_stats_rx = 19;
#[doc = "<  The reply messages (including cache request response) discarded due to errors in response format or no outstanding request."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_REPLY_MSG_DISCARD: solClient_stats_rx = 20;
#[doc = "< Cache requests completed OK."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_CACHEREQUEST_OK_RESPONSE: solClient_stats_rx = 21;
#[doc = "< Cache requests fulfilled by live data."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_CACHEREQUEST_FULFILL_DATA: solClient_stats_rx = 22;
#[doc = "< Cache requests failed due to solCache error response."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_CACHEREQUEST_ERROR_RESPONSE: solClient_stats_rx =
    23;
#[doc = "< Cache request response discarded due to errors in response format or no outstanding cache request."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_CACHEREQUEST_DISCARD_RESPONSE: solClient_stats_rx =
    24;
#[doc = "< Cached messages delivered to application."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_CACHEMSG: solClient_stats_rx = 25;
#[doc = "< Deprecated - Not Supported - On a cut-through Flow, the number of times the Flow entered cut-through delivery mode."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_FOUND_CTSYNC: solClient_stats_rx = 26;
#[doc = "< Deprecated - Not Supported - On a cut-through Flow, the number of times the Flow left cut-through delivery mode to resynchronize with the Guaranteed message storage on the broker"]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_LOST_CTSYNC: solClient_stats_rx = 27;
#[doc = "< Deprecated - Not Supported - On a cut-through Flow, the number of times the Flow left cut-through delivery mode to resynchronize with the Guaranteed message storage due to receiving a Guaranteed message that was not previously received as Direct."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_LOST_CTSYNC_GM: solClient_stats_rx = 28;
#[doc = "< Deprecated - Not Supported - On a cut-through Flow, the number of times the synchronization buffer overflowed, delaying synchronization."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_OVERFLOW_CTSYNC_BUFFER: solClient_stats_rx = 29;
#[doc = "< Deprecated - Not Supported - On a cut-through Flow, the number of Guaranteed messages discarded because they had already been received on the cut-through Flow."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_ALREADY_CUT_THROUGH: solClient_stats_rx = 30;
#[doc = "< Deprecated - Not Supported - On a cut-through Flow, the number of messages discarded from the synchronization list other than those discarded due to overflow."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_DISCARD_FROM_CTSYNC: solClient_stats_rx = 31;
#[doc = "< On a transacted flow, the number of messages discarded because the flow is in a UNBOUND pending state."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_DISCARD_MSG_FLOW_UNBOUND_PENDING:
    solClient_stats_rx = 32;
#[doc = "< On a transacted flow, the number of messages discarded after a transaction rollback and becomes a message comes in with prevMsgId=0."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_DISCARD_MSG_TRANSACTION_ROLLBACK:
    solClient_stats_rx = 33;
#[doc = "< On a transacted session, the number of transaction responses discarded due to reconnection."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_DISCARD_TRANSACTION_RESPONSE: solClient_stats_rx =
    34;
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_SSL_READ_EVENTS: solClient_stats_rx = 35;
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_SSL_READ_CALLS: solClient_stats_rx = 36;
#[doc = "< The size of receive stats array."]
pub const solClient_stats_rx_SOLCLIENT_STATS_RX_NUM_STATS: solClient_stats_rx = 37;
#[doc = " @enum solClient_stats_rx\n Receive statistics (64-bit counters). Index into array of receive statistics."]
pub type solClient_stats_rx = ::std::os::raw::c_uint;
#[doc = " @enum solClient_stats_rx\n Receive statistics (64-bit counters). Index into array of receive statistics."]
pub use self::solClient_stats_rx as solClient_stats_rx_t;
#[doc = "< The number of data bytes transmitted in total."]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_TOTAL_DATA_BYTES: solClient_stats_tx = 0;
#[doc = "< Deprecated name; ::SOLCLIENT_STATS_TX_TOTAL_DATA_BYTES is preferred"]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_BYTES: solClient_stats_tx = 0;
#[doc = "< The number of data messages transmitted in total."]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_TOTAL_DATA_MSGS: solClient_stats_tx = 1;
#[doc = "< Deprecated name; ::SOLCLIENT_STATS_TX_TOTAL_DATA_MSGS is preferred"]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_MSGS: solClient_stats_tx = 1;
#[doc = "< The number of messages not accepted due to would block (non-blocking only)."]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_WOULD_BLOCK: solClient_stats_tx = 2;
#[doc = "< The number of times the socket was full when send done (data buffered)."]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_SOCKET_FULL: solClient_stats_tx = 3;
#[doc = "< The number of bytes transmitted in Direct messages."]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_DIRECT_BYTES: solClient_stats_tx = 4;
#[doc = "< The number of Direct messages transmitted."]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_DIRECT_MSGS: solClient_stats_tx = 5;
#[doc = "< The number of bytes transmitted in Persistent messages."]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_PERSISTENT_BYTES: solClient_stats_tx = 6;
#[doc = "< The number of bytes transmitted in Non-Persistent messages."]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_NONPERSISTENT_BYTES: solClient_stats_tx = 7;
#[doc = "< The number of Persistent messages transmitted."]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_PERSISTENT_MSGS: solClient_stats_tx = 8;
#[doc = "< The number of Non-Persistent messages transmitted."]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_NONPERSISTENT_MSGS: solClient_stats_tx = 9;
#[doc = "< The number of Persistent messages redelivered."]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_PERSISTENT_REDELIVERED: solClient_stats_tx = 10;
#[doc = "< The number of Non-Persistent messages redelivered."]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_NONPERSISTENT_REDELIVERED: solClient_stats_tx = 11;
#[doc = "< The number of bytes redelivered in Persistent messages."]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_PERSISTENT_BYTES_REDELIVERED: solClient_stats_tx =
    12;
#[doc = "< The number of bytes redelivered in Non-Persistent messages."]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_NONPERSISTENT_BYTES_REDELIVERED:
    solClient_stats_tx = 13;
#[doc = "< The number of acknowledgments received."]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_ACKS_RXED: solClient_stats_tx = 14;
#[doc = "< The number of times the transmit window closed."]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_WINDOW_CLOSE: solClient_stats_tx = 15;
#[doc = "< The number of times the acknowledgment timer expired."]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_ACK_TIMEOUT: solClient_stats_tx = 16;
#[doc = "< The number of control (non-data) messages transmitted."]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_CTL_MSGS: solClient_stats_tx = 17;
#[doc = "< The number of bytes transmitted in control (non-data) messages."]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_CTL_BYTES: solClient_stats_tx = 18;
#[doc = "< The number of bytes transmitted after compression."]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_COMPRESSED_BYTES: solClient_stats_tx = 19;
#[doc = "< The total number of TCP connections attempted by this Session."]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_TOTAL_CONNECTION_ATTEMPTS: solClient_stats_tx = 20;
#[doc = "< The request messages sent."]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_REQUEST_SENT: solClient_stats_tx = 21;
#[doc = "< The request messages sent that did not receive a reply due to timeout."]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_REQUEST_TIMEOUT: solClient_stats_tx = 22;
#[doc = "< The cache requests sent."]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_CACHEREQUEST_SENT: solClient_stats_tx = 23;
#[doc = "< Guaranteed messages (Persistent/Non-Persistent) published that have been acknowledged."]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_GUARANTEED_MSGS_SENT_CONFIRMED: solClient_stats_tx =
    24;
#[doc = "< When the IPC add-on is in use, the counter of messages discarded due to no subscription match with connected peers"]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_DISCARD_NO_MATCH: solClient_stats_tx = 25;
#[doc = "< Messages discarded due to channel failure"]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_DISCARD_CHANNEL_ERROR: solClient_stats_tx = 26;
#[doc = "< The number of times Session blocked on socket full (blocking only) occurred."]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_BLOCKED_ON_SEND: solClient_stats_tx = 27;
#[doc = "< The size of transmit stats array."]
pub const solClient_stats_tx_SOLCLIENT_STATS_TX_NUM_STATS: solClient_stats_tx = 28;
#[doc = " @enum solClient_stats_tx\n Transmit statistics (64-bit counters). Index into array of transmit statistics."]
pub type solClient_stats_tx = ::std::os::raw::c_uint;
#[doc = " @enum solClient_stats_tx\n Transmit statistics (64-bit counters). Index into array of transmit statistics."]
pub use self::solClient_stats_tx as solClient_stats_tx_t;
#[doc = " @struct solClient_session_eventCallbackInfo\n\n A structure that is returned (as a pointer) for each event in the event\n callback for a Session. A structure is used so that new fields\n can be added in the future without affecting existing applications.\n For a sessionEvent of ::SOLCLIENT_SESSION_EVENT_ACKNOWLEDGEMENT, info_p\n will be the pointer or value set by ::solClient_msg_setCorrelationTag()\n or ::solClient_msg_setCorrelationTagPtr() in the message that is being\n acknowledged. This is used to correlate a published message to\n the acknowledgment received from\n the broker. In all other events info_p is a pointer to a NULL-terminated\n string."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct solClient_session_eventCallbackInfo {
    #[doc = "< The Session event that has occurred."]
    pub sessionEvent: solClient_session_event_t,
    #[doc = "< A response code that is returned for some events, otherwise zero."]
    pub responseCode: solClient_session_responseCode_t,
    #[doc = "< Except for ::SOLCLIENT_SESSION_EVENT_ACKNOWLEDGEMENT (see Detailed Description above), a pointer to a NULL-terminated string providing further information about the event, when available. This pointer is never NULL"]
    pub info_p: *const ::std::os::raw::c_char,
    #[doc = "< Application-supplied correlation pointer where applicable. Used when acknowledging or rejecting Guaranteed messages, in responses to any function calls that pass a correlationTag that will be returned in a Session Event."]
    pub correlation_p: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_solClient_session_eventCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<solClient_session_eventCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<solClient_session_eventCallbackInfo>(),
        24usize,
        concat!("Size of: ", stringify!(solClient_session_eventCallbackInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<solClient_session_eventCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(solClient_session_eventCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sessionEvent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_session_eventCallbackInfo),
            "::",
            stringify!(sessionEvent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).responseCode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_session_eventCallbackInfo),
            "::",
            stringify!(responseCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info_p) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_session_eventCallbackInfo),
            "::",
            stringify!(info_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).correlation_p) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_session_eventCallbackInfo),
            "::",
            stringify!(correlation_p)
        )
    );
}
#[doc = " @struct solClient_session_eventCallbackInfo\n\n A structure that is returned (as a pointer) for each event in the event\n callback for a Session. A structure is used so that new fields\n can be added in the future without affecting existing applications.\n For a sessionEvent of ::SOLCLIENT_SESSION_EVENT_ACKNOWLEDGEMENT, info_p\n will be the pointer or value set by ::solClient_msg_setCorrelationTag()\n or ::solClient_msg_setCorrelationTagPtr() in the message that is being\n acknowledged. This is used to correlate a published message to\n the acknowledgment received from\n the broker. In all other events info_p is a pointer to a NULL-terminated\n string."]
pub type solClient_session_eventCallbackInfo_pt = *mut solClient_session_eventCallbackInfo;
#[doc = " @struct solClient_flow_eventCallbackInfo\n\n A structure that is returned (as a pointer) for each event in the event callback\n callback for a Flow. A structure is used so that new fields can be added\n in the future without affecting existing applications."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct solClient_flow_eventCallbackInfo {
    #[doc = "< The Session event that has occurred."]
    pub flowEvent: solClient_flow_event_t,
    #[doc = "< A response code that is returned for some events; otherwise zero."]
    pub responseCode: solClient_session_responseCode_t,
    #[doc = "< A pointer to a NULL-terminated string providing further information about the event, when available. This pointer is never NULL."]
    pub info_p: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_solClient_flow_eventCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<solClient_flow_eventCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<solClient_flow_eventCallbackInfo>(),
        16usize,
        concat!("Size of: ", stringify!(solClient_flow_eventCallbackInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<solClient_flow_eventCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(solClient_flow_eventCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flowEvent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_flow_eventCallbackInfo),
            "::",
            stringify!(flowEvent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).responseCode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_flow_eventCallbackInfo),
            "::",
            stringify!(responseCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info_p) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_flow_eventCallbackInfo),
            "::",
            stringify!(info_p)
        )
    );
}
#[doc = " @struct solClient_flow_eventCallbackInfo\n\n A structure that is returned (as a pointer) for each event in the event callback\n callback for a Flow. A structure is used so that new fields can be added\n in the future without affecting existing applications."]
pub type solClient_flow_eventCallbackInfo_pt = *mut solClient_flow_eventCallbackInfo;
#[doc = " A callback prototype for Session events. The callback with this prototype that is\n registered for a Session is called for each Session event that occurs.\n\n When a Session event is received that indicates an error condition (such as the Session going down), additional\n error information is recorded and can be retrieved through ::solClient_getLastErrorInfo.\n @subcodes\n @li ::SOLCLIENT_SUBCODE_COMMUNICATION_ERROR - The underlying connection failed.\n @li ::SOLCLIENT_SUBCODE_OUT_OF_RESOURCES - The broker cannot accept any more Topic subscriptions. (This subcode only occurs when using the Topic Routing Blade.)\n @li ::SOLCLIENT_SUBCODE_PROTOCOL_ERROR - A protocol error occurred between the API and the broker.\n @li ::SOLCLIENT_SUBCODE_KEEP_ALIVE_FAILURE - The Session went down due to a Keep-Alive failure.\n @li ::SOLCLIENT_SUBCODE_INVALID_TOPIC_SYNTAX - A subscription was rejected by the broker due to invalid Topic syntax.\n @li ::SOLCLIENT_SUBCODE_XML_PARSE_ERROR - The broker rejected a published XML message due to an XML parse error.\n @li ::SOLCLIENT_SUBCODE_TIMEOUT - A timeout occurred on the Session connection.\n @li ::SOLCLIENT_SUBCODE_LOGIN_FAILURE\n @li ::SOLCLIENT_SUBCODE_MSG_VPN_NOT_ALLOWED\n @li ::SOLCLIENT_SUBCODE_MSG_VPN_UNAVAILABLE\n @li ::SOLCLIENT_SUBCODE_CLIENT_USERNAME_IS_SHUTDOWN\n @li ::SOLCLIENT_SUBCODE_DYNAMIC_CLIENTS_NOT_ALLOWED\n @li ::SOLCLIENT_SUBCODE_CLIENT_NAME_ALREADY_IN_USE\n @li ::SOLCLIENT_SUBCODE_INVALID_VIRTUAL_ADDRESS\n @li ::SOLCLIENT_SUBCODE_CLIENT_DELETE_IN_PROGRESS\n @li ::SOLCLIENT_SUBCODE_TOO_MANY_CLIENTS\n @li ::SOLCLIENT_SUBCODE_SUBSCRIPTION_ALREADY_PRESENT (see ::SOLCLIENT_SESSION_PROP_IGNORE_DUP_SUBSCRIPTION_ERROR)\n @li ::SOLCLIENT_SUBCODE_SUBSCRIPTION_NOT_FOUND (see ::SOLCLIENT_SESSION_PROP_IGNORE_DUP_SUBSCRIPTION_ERROR)\n @li ::SOLCLIENT_SUBCODE_SUBSCRIPTION_INVALID\n @li ::SOLCLIENT_SUBCODE_SUBSCRIPTION_TOO_MANY\n @li ::SOLCLIENT_SUBCODE_SUBSCRIPTION_ACL_DENIED\n @li ::SOLCLIENT_SUBCODE_SUBSCRIPTION_OTHER\n @li ::SOLCLIENT_SUBCODE_CONTROL_OTHER\n @li ::SOLCLIENT_SUBCODE_DATA_OTHER\n @li ::SOLCLIENT_SUBCODE_MESSAGE_TOO_LARGE\n @li ::SOLCLIENT_SUBCODE_INVALID_TOPIC_NAME_FOR_TE\n @li ::SOLCLIENT_SUBCODE_UNKNOWN_QUEUE_NAME\n @li ::SOLCLIENT_SUBCODE_UNKNOWN_TE_NAME\n @li ::SOLCLIENT_SUBCODE_MAX_CLIENTS_FOR_QUEUE\n @li ::SOLCLIENT_SUBCODE_MAX_CLIENTS_FOR_TE\n @li ::SOLCLIENT_SUBCODE_UNEXPECTED_UNBIND\n @li ::SOLCLIENT_SUBCODE_QUEUE_NOT_FOUND\n @li ::SOLCLIENT_SUBCODE_PUBLISH_ACL_DENIED\n @li ::SOLCLIENT_SUBCODE_CLIENT_ACL_DENIED\n @li ::SOLCLIENT_SUBCODE_SUBSCRIPTION_ACL_DENIED\n @li ::SOLCLIENT_SUBCODE_SPOOL_OVER_QUOTA\n @li ::SOLCLIENT_SUBCODE_QUEUE_SHUTDOWN\n @li ::SOLCLIENT_SUBCODE_TE_SHUTDOWN\n @li ::SOLCLIENT_SUBCODE_NO_MORE_NON_DURABLE_QUEUE_OR_TE\n @li ::solClient_subCode for a description of all subcodes.\n\n @param opaqueSession_p A pointer to the Session to which the event applies. This pointer is never NULL.\n @param eventInfo_p     A pointer to information about the Session event, such as the event type. This pointer is never NULL.\n @param user_p          A pointer to opaque user data provided when the callback is registered.\n @see solClient_session_create()"]
pub type solClient_session_eventCallbackFunc_t = ::std::option::Option<
    unsafe extern "C" fn(
        opaqueSession_p: solClient_opaqueSession_pt,
        eventInfo_p: solClient_session_eventCallbackInfo_pt,
        user_p: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " A callback prototype for Flow events. The callback with this prototype that is\n registered for a Flow is called for each Flow event that occurs.\n\n When a Flow event is received that indicates an error condition (such as a bind failure), additional\n error information is recorded and can be retrieved through ::solClient_getLastErrorInfo.\n @subcodes\n @li ::SOLCLIENT_SUBCODE_COMMUNICATION_ERROR - The underlying connection failed\n @li ::SOLCLIENT_SUBCODE_PROTOCOL_ERROR - A protocol error occurred between the API and the broker.\n @li ::SOLCLIENT_SUBCODE_KEEP_ALIVE_FAILURE - The Session went down due to a Keep-Alive failure.\n @li ::SOLCLIENT_SUBCODE_TIMEOUT - A timeout occurred on an operation such as binding to a Flow.\n @li ::solClient_subCode for a description of all subcodes.\n\n @param opaqueFlow_p    A pointer to the Flow to which the event applies. This pointer is never NULL.\n @param eventInfo_p     A pointer to information about the Flow event, such as the event type. This pointer is never NULL.\n @param user_p          A pointer to opaque user data provided when callback is registered.\n @see solClient_session_createFlow()"]
pub type solClient_flow_eventCallbackFunc_t = ::std::option::Option<
    unsafe extern "C" fn(
        opaqueFlow_p: solClient_opaqueFlow_pt,
        eventInfo_p: solClient_flow_eventCallbackInfo_pt,
        user_p: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " A callback prototype for file descriptor events. The callback with this prototype that is\n registered for a file descriptor event is called for each file descriptor event that occurs.\n Multiple registered file descriptor events can be returned in a single callback.\n @param opaqueContext_p A pointer to the Context under which the file descriptor event occurred. This pointer is never NULL.\n @param fd The file descriptor for which the event has occurred.\n @param events A bit vector containing the file descriptor events that have occurred ORed together.\n @param user_p A pointer to opaque user data, provided when the callback registered.\n @see solClient_context_registerForFdEvents()"]
pub type solClient_context_fdCallbackFunc_t = ::std::option::Option<
    unsafe extern "C" fn(
        opaqueContext_p: solClient_opaqueContext_pt,
        fd: solClient_fd_t,
        events: solClient_fdEvent_t,
        user_p: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " A callback prototype for received messages. A callback with this prototype\n can be registered for a Session. If an application registers this callback, it\n is called for each received message.\n When the callback is invoked for a received message, the application can use\n all the structured data accessors on the received message. It can also choose\n to keep all or part of the received message for later use.\n\n If the application requires a message (or some of its parts) after this\n callback returns, the application has several options available:\n @li The application may duplicate the message (solClient_msg_dup), which creates a copy of the message but uses the same data area. The message can be used to access the data in the future.\n @li The application may keep the 'msg' entirely by returning ::SOLCLIENT_CALLBACK_TAKE_MSG from this function.\n\n In these cases, the application must call solClient_msg_free() to release the\n msg that was created by solClient_msg_dup. If the application takes control of the\n received msg it must later call solClient_msg_free() for that msg.\n\n The implementation of this callback must return ::SOLCLIENT_CALLBACK_OK or ::SOLCLIENT_CALLBACK_TAKE_MSG\n @param opaqueSession_p A pointer to the Session for which the message has been received. This pointer is never NULL.\n @param msg_p A pointer to an opaque message pointer (solClient_opaqueMsg_pt) for the received message. This pointer is never NULL.\n @param user_p A pointer to opaque user data provided when callback registered.\n @see solClient_session_create()"]
pub type solClient_session_rxMsgCallbackFunc_t = ::std::option::Option<
    unsafe extern "C" fn(
        opaqueSession_p: solClient_opaqueSession_pt,
        msg_p: solClient_opaqueMsg_pt,
        user_p: *mut ::std::os::raw::c_void,
    ) -> solClient_rxMsgCallback_returnCode_t,
>;
#[doc = " A callback prototype for received messages on a Flow. A callback with this prototype\n can be registered for a Flow. If an application registers this callback it\n is called for each received message.\n When the callback is invoked for a received message, the application can use\n all the structured data accessors on the received message. It may also choose\n to keep all or part of the received message for later use.\n\n If the application requires a message (or some of its parts) after this\n callback returns, the application has several options available:\n @li The application may duplicate the message (solClient_msg_dup), which creates a copy of the message but uses the same data area. The message can be used to access the data in the future.\n @li The application can keep the 'msg' entirely by returning ::SOLCLIENT_CALLBACK_TAKE_MSG from this function.\n\n In these cases, the application must call solClient_msg_free() to release the\n msg that was created by solClient_msg_dup. If the application takes control of the\n received msg it must later call solClient_msg_free() for that msg.\n\n The implementation of this callback must return ::SOLCLIENT_CALLBACK_OK or ::SOLCLIENT_CALLBACK_TAKE_MSG\n @param opaqueFlow_p A pointer to the Flow for which the message has been received. This pointer is never NULL.\n @param msg_p A pointer to an opaque message pointer (solClient_opaqueMsg_pt) for the received message. This pointer is never NULL.\n @param user_p A pointer to opaque user data provided when the callback registered.\n @see solClient_session_create()"]
pub type solClient_flow_rxMsgCallbackFunc_t = ::std::option::Option<
    unsafe extern "C" fn(
        opaqueFlow_p: solClient_opaqueFlow_pt,
        msg_p: solClient_opaqueMsg_pt,
        user_p: *mut ::std::os::raw::c_void,
    ) -> solClient_rxMsgCallback_returnCode_t,
>;
#[doc = " @struct solClient_log_callbackInfo_t\n\n A structure that is returned (as a pointer) for each log to the log callback routine\n that has been optionally registered. A structure is used so that new fields can be added\n in the future without affecting existing applications."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct solClient_log_callbackInfo {
    #[doc = "< The log category associated with the log being generated."]
    pub category: solClient_log_category_t,
    #[doc = "< The log level associated with the log being generated."]
    pub level: solClient_log_level_t,
    #[doc = "< A pointer to the log message text, which is NULL terminated. This pointer is never NULL."]
    pub msg_p: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_solClient_log_callbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<solClient_log_callbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<solClient_log_callbackInfo>(),
        16usize,
        concat!("Size of: ", stringify!(solClient_log_callbackInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<solClient_log_callbackInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(solClient_log_callbackInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).category) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_log_callbackInfo),
            "::",
            stringify!(category)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_log_callbackInfo),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_p) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_log_callbackInfo),
            "::",
            stringify!(msg_p)
        )
    );
}
#[doc = " @struct solClient_log_callbackInfo_t\n\n A structure that is returned (as a pointer) for each log to the log callback routine\n that has been optionally registered. A structure is used so that new fields can be added\n in the future without affecting existing applications."]
pub type solClient_log_callbackInfo_pt = *mut solClient_log_callbackInfo;
#[doc = " A callback prototype for generated logs. The callback with this prototype that is\n optionally globally registered is called for each log generated. Logs are\n filtered according to the log filter level set, and this routine is only called for\n logs that pass the level filter criteria. The log text must be used before\n the callback returns, as the pointer is no longer valid once the callback returns.\n @param logInfo A pointer to information about the log being generated, such as level and message. This pointer is never NULL.\n @param user_p  A pointer to opaque user data provided when the callback registered.\n @see solClient_log_setFilterLevel()"]
pub type solClient_log_callbackFunc_t = ::std::option::Option<
    unsafe extern "C" fn(
        logInfo_p: solClient_log_callbackInfo_pt,
        user_p: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " A callback prototype for timer expiry. The callback with this prototype that is\n registered when a timer is started.\n @param opaqueContext_p A pointer to Context under which the timer was started previously. This pointer is never NULL.\n @param user_p          A pointer to opaque user data that is provided when timer started.\n @see solClient_context_startTimer()"]
pub type solClient_context_timerCallbackFunc_t = ::std::option::Option<
    unsafe extern "C" fn(
        opaqueContext_p: solClient_opaqueContext_pt,
        user_p: *mut ::std::os::raw::c_void,
    ),
>;
pub type solClient_context_timerId_t = solClient_uint32_t;
#[doc = "< The timer expires once and then is automatically stopped."]
pub const solClient_context_timerMode_SOLCLIENT_CONTEXT_TIMER_ONE_SHOT:
    solClient_context_timerMode = 0;
#[doc = "< The timer is automatically rescheduled for the same duration upon expiry until stopped."]
pub const solClient_context_timerMode_SOLCLIENT_CONTEXT_TIMER_REPEAT: solClient_context_timerMode =
    1;
#[doc = " @enum solClient_context_timerMode\n The type of timer to start through solClient_context_startTimer()."]
pub type solClient_context_timerMode = ::std::os::raw::c_uint;
#[doc = " @enum solClient_context_timerMode\n The type of timer to start through solClient_context_startTimer()."]
pub use self::solClient_context_timerMode as solClient_context_timerMode_t;
#[doc = "< Callback on the dispatch function immediately when a message arrives"]
pub const solClient_dispatchType_SOLCLIENT_DISPATCH_TYPE_CALLBACK: solClient_dispatchType = 1;
#[doc = " @enum solClient_dispatchType\n Type of dispatch function to perform for messages received on the\n topic. see \\ref ::solClient_session_rxMsgDispatchFuncInfo and \\ref ::solClient_flow_rxMsgDispatchFuncInfo"]
pub type solClient_dispatchType = ::std::os::raw::c_uint;
#[doc = " @enum solClient_dispatchType\n Type of dispatch function to perform for messages received on the\n topic. see \\ref ::solClient_session_rxMsgDispatchFuncInfo and \\ref ::solClient_flow_rxMsgDispatchFuncInfo"]
pub use self::solClient_dispatchType as solClient_dispatchType_t;
#[doc = " A function prototype for OPTIONAL application-supplied file descriptor registration service.\n @param app_p      The opaque pointer that was supplied when the file descriptor register function was configured.\n                   This pointer was passed in as user_p through solClient_context_registerFdFuncInfo_t.\n @param fd         The file descriptor for which events are being registered.\n @param events     File descriptor events of interest, OR'ed together. These events must be added to any\n existing events registered for this file descriptor.\n @param callback_p The event function to call when events occur on the file descriptor. This pointer is never NULL.\n @param user_p     An opaque pointer to be supplied to the callback routine when invoked.\n @returns          ::SOLCLIENT_OK or ::SOLCLIENT_FAIL\n @see solClient_context_create()"]
pub type solClient_context_registerFdFunc_t = ::std::option::Option<
    unsafe extern "C" fn(
        app_p: *mut ::std::os::raw::c_void,
        fd: solClient_fd_t,
        events: solClient_fdEvent_t,
        callback_p: solClient_context_fdCallbackFunc_t,
        user_p: *mut ::std::os::raw::c_void,
    ) -> solClient_returnCode_t,
>;
#[doc = " A function prototype for OPTIONAL application-supplied file descriptor unregistration service.\n @param app_p      An opaque pointer supplied when the file descriptor unregister function was configured.\n                   This pointer was passed in as user_p through solClient_context_registerFdFuncInfo_t.\n @param fd         The file descriptor for which events are being unregistered.\n @param events     Events no longer of interest, OR'ed together.\n @returns          ::SOLCLIENT_OK or ::SOLCLIENT_FAIL\n @see solClient_context_create()"]
pub type solClient_context_unregisterFdFunc_t = ::std::option::Option<
    unsafe extern "C" fn(
        app_p: *mut ::std::os::raw::c_void,
        fd: solClient_fd_t,
        events: solClient_fdEvent_t,
    ) -> solClient_returnCode_t,
>;
#[doc = " @struct solClient_context_createRegisterFdFuncInfo\n\n Function information for file descriptor registration and file descriptor unregistration functions.\n This is set on a per-Context basis. Providing these functions is optional. If provided, both\n must be non-NULL, and if not provided, both must be NULL.\n\n These functions are used when the application wants to own event generation, and they supply\n file descriptor events to the API. Such applications typically want to poll several different devices, of\n which the API is only one. When these functions are provided, the API does not manage its own\n devices. Instead, when a device is created, the provided 'register' function is called to register the\n device file descriptor for read and/or write events. It is the responsibility of the application to call back\n into API when the appropriate event occurs on the device file descriptor. The API callback is\n provided to the register function (see ::solClient_context_registerFdFunc_t). If this interface is chosen,\n the application <b>must</b> also call solClient_context_timerTick() at regular intervals.\n\n Normally these are not used, and the API owns event registrations. If an internal Context thread is used\n by enabling ::SOLCLIENT_CONTEXT_PROP_CREATE_THREAD  (see also ::SOLCLIENT_CONTEXT_PROPS_DEFAULT_WITH_CREATE_THREAD),\n the API takes care of all devices and timers and no action is required by the application. If the internal thread is\n not enabled, the application must call solClient_context_processEvents() to provide scheduling time to the API.\n\n When the API owns event registrations, it also provides file descriptor register/unregister service to the application.\n solClient_context_registerForFdEvents() and solClient_context_unregisterForFdEvents() can be used by applications to\n pass file descriptors to the API for managing, keeping event generation localized to the internal thread or the thread\n that calls solClient_context_processEvents()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct solClient_context_createRegisterFdFuncInfo {
    pub regFdFunc_p: solClient_context_registerFdFunc_t,
    pub unregFdFunc_p: solClient_context_unregisterFdFunc_t,
    pub user_p: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_solClient_context_createRegisterFdFuncInfo() {
    const UNINIT: ::std::mem::MaybeUninit<solClient_context_createRegisterFdFuncInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<solClient_context_createRegisterFdFuncInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(solClient_context_createRegisterFdFuncInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<solClient_context_createRegisterFdFuncInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(solClient_context_createRegisterFdFuncInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regFdFunc_p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_context_createRegisterFdFuncInfo),
            "::",
            stringify!(regFdFunc_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unregFdFunc_p) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_context_createRegisterFdFuncInfo),
            "::",
            stringify!(unregFdFunc_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_p) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_context_createRegisterFdFuncInfo),
            "::",
            stringify!(user_p)
        )
    );
}
#[doc = " @struct solClient_context_createRegisterFdFuncInfo\n\n Function information for file descriptor registration and file descriptor unregistration functions.\n This is set on a per-Context basis. Providing these functions is optional. If provided, both\n must be non-NULL, and if not provided, both must be NULL.\n\n These functions are used when the application wants to own event generation, and they supply\n file descriptor events to the API. Such applications typically want to poll several different devices, of\n which the API is only one. When these functions are provided, the API does not manage its own\n devices. Instead, when a device is created, the provided 'register' function is called to register the\n device file descriptor for read and/or write events. It is the responsibility of the application to call back\n into API when the appropriate event occurs on the device file descriptor. The API callback is\n provided to the register function (see ::solClient_context_registerFdFunc_t). If this interface is chosen,\n the application <b>must</b> also call solClient_context_timerTick() at regular intervals.\n\n Normally these are not used, and the API owns event registrations. If an internal Context thread is used\n by enabling ::SOLCLIENT_CONTEXT_PROP_CREATE_THREAD  (see also ::SOLCLIENT_CONTEXT_PROPS_DEFAULT_WITH_CREATE_THREAD),\n the API takes care of all devices and timers and no action is required by the application. If the internal thread is\n not enabled, the application must call solClient_context_processEvents() to provide scheduling time to the API.\n\n When the API owns event registrations, it also provides file descriptor register/unregister service to the application.\n solClient_context_registerForFdEvents() and solClient_context_unregisterForFdEvents() can be used by applications to\n pass file descriptors to the API for managing, keeping event generation localized to the internal thread or the thread\n that calls solClient_context_processEvents()."]
pub type solClient_context_createRegisterFdFuncInfo_t = solClient_context_createRegisterFdFuncInfo;
#[doc = " @struct solClient_context_createFuncInfo\n\n Function information for Context creation. This is set on a per-Context basis."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct solClient_context_createFuncInfo {
    pub regFdInfo: solClient_context_createRegisterFdFuncInfo_t,
}
#[test]
fn bindgen_test_layout_solClient_context_createFuncInfo() {
    const UNINIT: ::std::mem::MaybeUninit<solClient_context_createFuncInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<solClient_context_createFuncInfo>(),
        24usize,
        concat!("Size of: ", stringify!(solClient_context_createFuncInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<solClient_context_createFuncInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(solClient_context_createFuncInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regFdInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_context_createFuncInfo),
            "::",
            stringify!(regFdInfo)
        )
    );
}
#[doc = " @struct solClient_context_createFuncInfo\n\n Function information for Context creation. This is set on a per-Context basis."]
pub type solClient_context_createFuncInfo_t = solClient_context_createFuncInfo;
#[doc = " @struct solClient_session_createRxCallbackFuncInfo\n\n <b>DEPRECATED</b>. Applications should use solClient_session_createRxMsgCallbackFuncInfo.\n Callback information for Session message receive callback. This is set on a per-Session basis."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct solClient_session_createRxCallbackFuncInfo {
    pub callback_p: *mut ::std::os::raw::c_void,
    pub user_p: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_solClient_session_createRxCallbackFuncInfo() {
    const UNINIT: ::std::mem::MaybeUninit<solClient_session_createRxCallbackFuncInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<solClient_session_createRxCallbackFuncInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(solClient_session_createRxCallbackFuncInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<solClient_session_createRxCallbackFuncInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(solClient_session_createRxCallbackFuncInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback_p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_session_createRxCallbackFuncInfo),
            "::",
            stringify!(callback_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_p) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_session_createRxCallbackFuncInfo),
            "::",
            stringify!(user_p)
        )
    );
}
#[doc = " @struct solClient_session_createRxCallbackFuncInfo\n\n <b>DEPRECATED</b>. Applications should use solClient_session_createRxMsgCallbackFuncInfo.\n Callback information for Session message receive callback. This is set on a per-Session basis."]
pub type solClient_session_createRxCallbackFuncInfo_t = solClient_session_createRxCallbackFuncInfo;
#[doc = " @struct solClient_session_createRxMsgCallbackFuncInfo\n\n Callback information for Session message receive callbacks. This is set on a per-Session basis."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct solClient_session_createRxMsgCallbackFuncInfo {
    pub callback_p: solClient_session_rxMsgCallbackFunc_t,
    pub user_p: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_solClient_session_createRxMsgCallbackFuncInfo() {
    const UNINIT: ::std::mem::MaybeUninit<solClient_session_createRxMsgCallbackFuncInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<solClient_session_createRxMsgCallbackFuncInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(solClient_session_createRxMsgCallbackFuncInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<solClient_session_createRxMsgCallbackFuncInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(solClient_session_createRxMsgCallbackFuncInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback_p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_session_createRxMsgCallbackFuncInfo),
            "::",
            stringify!(callback_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_p) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_session_createRxMsgCallbackFuncInfo),
            "::",
            stringify!(user_p)
        )
    );
}
#[doc = " @struct solClient_session_createRxMsgCallbackFuncInfo\n\n Callback information for Session message receive callbacks. This is set on a per-Session basis."]
pub type solClient_session_createRxMsgCallbackFuncInfo_t =
    solClient_session_createRxMsgCallbackFuncInfo;
#[doc = " @struct solClient_session_createEventCallbackFuncInfo\n\n Callback information for Session event callback. This is set on a per-Session basis."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct solClient_session_createEventCallbackFuncInfo {
    pub callback_p: solClient_session_eventCallbackFunc_t,
    pub user_p: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_solClient_session_createEventCallbackFuncInfo() {
    const UNINIT: ::std::mem::MaybeUninit<solClient_session_createEventCallbackFuncInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<solClient_session_createEventCallbackFuncInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(solClient_session_createEventCallbackFuncInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<solClient_session_createEventCallbackFuncInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(solClient_session_createEventCallbackFuncInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback_p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_session_createEventCallbackFuncInfo),
            "::",
            stringify!(callback_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_p) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_session_createEventCallbackFuncInfo),
            "::",
            stringify!(user_p)
        )
    );
}
#[doc = " @struct solClient_session_createEventCallbackFuncInfo\n\n Callback information for Session event callback. This is set on a per-Session basis."]
pub type solClient_session_createEventCallbackFuncInfo_t =
    solClient_session_createEventCallbackFuncInfo;
#[doc = " @struct solClient_session_rxMsgDispatchFuncInfo\n\n Callback information for Session message receive dispatch. This can be set on a per-subscription basis.\n This structure is used with ::solClient_session_topicSubscribeWithDispatch and ::solClient_session_topicUnsubscribeWithDispatch.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct solClient_session_rxMsgDispatchFuncInfo {
    #[doc = "< The type of dispatch described."]
    pub dispatchType: solClient_dispatchType_t,
    #[doc = "< An application-defined callback function; may be NULL if there is no callback."]
    pub callback_p: solClient_session_rxMsgCallbackFunc_t,
    #[doc = "< A user pointer to return with the callback; must be NULL if callback_p is NULL."]
    pub user_p: *mut ::std::os::raw::c_void,
    #[doc = "< Reserved for Future use; must be NULL."]
    pub rfu_p: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_solClient_session_rxMsgDispatchFuncInfo() {
    const UNINIT: ::std::mem::MaybeUninit<solClient_session_rxMsgDispatchFuncInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<solClient_session_rxMsgDispatchFuncInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(solClient_session_rxMsgDispatchFuncInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<solClient_session_rxMsgDispatchFuncInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(solClient_session_rxMsgDispatchFuncInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dispatchType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_session_rxMsgDispatchFuncInfo),
            "::",
            stringify!(dispatchType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback_p) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_session_rxMsgDispatchFuncInfo),
            "::",
            stringify!(callback_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_p) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_session_rxMsgDispatchFuncInfo),
            "::",
            stringify!(user_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rfu_p) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_session_rxMsgDispatchFuncInfo),
            "::",
            stringify!(rfu_p)
        )
    );
}
#[doc = " @struct solClient_session_rxMsgDispatchFuncInfo\n\n Callback information for Session message receive dispatch. This can be set on a per-subscription basis.\n This structure is used with ::solClient_session_topicSubscribeWithDispatch and ::solClient_session_topicUnsubscribeWithDispatch.\n"]
pub type solClient_session_rxMsgDispatchFuncInfo_t = solClient_session_rxMsgDispatchFuncInfo;
#[doc = " @struct solClient_flow_createRxCallbackFuncInfo\n\n Callback information for Flow message receive callback. This is set on a per-Flow basis."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct solClient_flow_createRxCallbackFuncInfo {
    pub callback_p: *mut ::std::os::raw::c_void,
    pub user_p: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_solClient_flow_createRxCallbackFuncInfo() {
    const UNINIT: ::std::mem::MaybeUninit<solClient_flow_createRxCallbackFuncInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<solClient_flow_createRxCallbackFuncInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(solClient_flow_createRxCallbackFuncInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<solClient_flow_createRxCallbackFuncInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(solClient_flow_createRxCallbackFuncInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback_p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_flow_createRxCallbackFuncInfo),
            "::",
            stringify!(callback_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_p) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_flow_createRxCallbackFuncInfo),
            "::",
            stringify!(user_p)
        )
    );
}
#[doc = " @struct solClient_flow_createRxCallbackFuncInfo\n\n Callback information for Flow message receive callback. This is set on a per-Flow basis."]
pub type solClient_flow_createRxCallbackFuncInfo_t = solClient_flow_createRxCallbackFuncInfo;
#[doc = " @struct solClient_flow_createRxMsgCallbackFuncInfo\n\n Callback information for Flow message receive callback. This is set on a per-Flow basis."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct solClient_flow_createRxMsgCallbackFuncInfo {
    pub callback_p: solClient_flow_rxMsgCallbackFunc_t,
    pub user_p: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_solClient_flow_createRxMsgCallbackFuncInfo() {
    const UNINIT: ::std::mem::MaybeUninit<solClient_flow_createRxMsgCallbackFuncInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<solClient_flow_createRxMsgCallbackFuncInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(solClient_flow_createRxMsgCallbackFuncInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<solClient_flow_createRxMsgCallbackFuncInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(solClient_flow_createRxMsgCallbackFuncInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback_p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_flow_createRxMsgCallbackFuncInfo),
            "::",
            stringify!(callback_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_p) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_flow_createRxMsgCallbackFuncInfo),
            "::",
            stringify!(user_p)
        )
    );
}
#[doc = " @struct solClient_flow_createRxMsgCallbackFuncInfo\n\n Callback information for Flow message receive callback. This is set on a per-Flow basis."]
pub type solClient_flow_createRxMsgCallbackFuncInfo_t = solClient_flow_createRxMsgCallbackFuncInfo;
#[doc = " @struct solClient_flow_rxMsgDispatchFuncInfo\n\n Callback information for Flow message receive dispatch. This can be set on a per-subscription basis.\n This structure is used with ::solClient_flow_topicSubscribeWithDispatch and ::solClient_flow_topicUnsubscribeWithDispatch."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct solClient_flow_rxMsgDispatchFuncInfo {
    #[doc = "< The type of dispatch described"]
    pub dispatchType: solClient_dispatchType_t,
    #[doc = "< An application-defined callback function; may be NULL if there is no callback"]
    pub callback_p: solClient_flow_rxMsgCallbackFunc_t,
    #[doc = "< A user pointer to return with the callback; must be NULL if callback_p is NULL"]
    pub user_p: *mut ::std::os::raw::c_void,
    #[doc = "< Reserved for future use; must be NULL."]
    pub rfu_p: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_solClient_flow_rxMsgDispatchFuncInfo() {
    const UNINIT: ::std::mem::MaybeUninit<solClient_flow_rxMsgDispatchFuncInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<solClient_flow_rxMsgDispatchFuncInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(solClient_flow_rxMsgDispatchFuncInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<solClient_flow_rxMsgDispatchFuncInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(solClient_flow_rxMsgDispatchFuncInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dispatchType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_flow_rxMsgDispatchFuncInfo),
            "::",
            stringify!(dispatchType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback_p) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_flow_rxMsgDispatchFuncInfo),
            "::",
            stringify!(callback_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_p) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_flow_rxMsgDispatchFuncInfo),
            "::",
            stringify!(user_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rfu_p) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_flow_rxMsgDispatchFuncInfo),
            "::",
            stringify!(rfu_p)
        )
    );
}
#[doc = " @struct solClient_flow_rxMsgDispatchFuncInfo\n\n Callback information for Flow message receive dispatch. This can be set on a per-subscription basis.\n This structure is used with ::solClient_flow_topicSubscribeWithDispatch and ::solClient_flow_topicUnsubscribeWithDispatch."]
pub type solClient_flow_rxMsgDispatchFuncInfo_t = solClient_flow_rxMsgDispatchFuncInfo;
#[doc = " @struct solClient_flow_createEventCallbackFuncInfo\n\n Callback information for Flow event callback. This is set on a per-Flow basis."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct solClient_flow_createEventCallbackFuncInfo {
    pub callback_p: solClient_flow_eventCallbackFunc_t,
    pub user_p: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_solClient_flow_createEventCallbackFuncInfo() {
    const UNINIT: ::std::mem::MaybeUninit<solClient_flow_createEventCallbackFuncInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<solClient_flow_createEventCallbackFuncInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(solClient_flow_createEventCallbackFuncInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<solClient_flow_createEventCallbackFuncInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(solClient_flow_createEventCallbackFuncInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback_p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_flow_createEventCallbackFuncInfo),
            "::",
            stringify!(callback_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_p) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_flow_createEventCallbackFuncInfo),
            "::",
            stringify!(user_p)
        )
    );
}
#[doc = " @struct solClient_flow_createEventCallbackFuncInfo\n\n Callback information for Flow event callback. This is set on a per-Flow basis."]
pub type solClient_flow_createEventCallbackFuncInfo_t = solClient_flow_createEventCallbackFuncInfo;
#[doc = " @struct solClient_session_createFuncInfo\n\n Function information for Session creation. This is set on a per-Session basis.\n\n The application must set the eventInfo callback information. All Sessions must have an event callback registered.\n\n The application must set one, and only one, message callback information. The <i>rxInfo</i> message callback interface is\n <b>deprecated</b> and should be set to NULL. All applications should prefer to use the <i>rxMsgInfo</i> callback interface.\n The application has available to it a ::solClient_opaqueMsg_pt, which can be kept for later processing and provides a\n structured interface for accessing elements of the received message. The application callback routine then has the signature\n (see ::solClient_session_rxMsgCallbackFunc_t) :\n\n <code style=\"font-size:90%\">\nsolClient_rxMsgCallback_returnCode_t\napplicationRxMsgCallback (solClient_opaqueSession_pt  opaqueSession_p,\nsolClient_opaqueMsg_pt      msg_p,\nvoid                       *user_p);\n </code>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct solClient_session_createFuncInfo {
    pub rxInfo: solClient_session_createRxCallbackFuncInfo_t,
    pub eventInfo: solClient_session_createEventCallbackFuncInfo_t,
    pub rxMsgInfo: solClient_session_createRxMsgCallbackFuncInfo_t,
}
#[test]
fn bindgen_test_layout_solClient_session_createFuncInfo() {
    const UNINIT: ::std::mem::MaybeUninit<solClient_session_createFuncInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<solClient_session_createFuncInfo>(),
        48usize,
        concat!("Size of: ", stringify!(solClient_session_createFuncInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<solClient_session_createFuncInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(solClient_session_createFuncInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rxInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_session_createFuncInfo),
            "::",
            stringify!(rxInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eventInfo) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_session_createFuncInfo),
            "::",
            stringify!(eventInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rxMsgInfo) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_session_createFuncInfo),
            "::",
            stringify!(rxMsgInfo)
        )
    );
}
#[doc = " @struct solClient_session_createFuncInfo\n\n Function information for Session creation. This is set on a per-Session basis.\n\n The application must set the eventInfo callback information. All Sessions must have an event callback registered.\n\n The application must set one, and only one, message callback information. The <i>rxInfo</i> message callback interface is\n <b>deprecated</b> and should be set to NULL. All applications should prefer to use the <i>rxMsgInfo</i> callback interface.\n The application has available to it a ::solClient_opaqueMsg_pt, which can be kept for later processing and provides a\n structured interface for accessing elements of the received message. The application callback routine then has the signature\n (see ::solClient_session_rxMsgCallbackFunc_t) :\n\n <code style=\"font-size:90%\">\nsolClient_rxMsgCallback_returnCode_t\napplicationRxMsgCallback (solClient_opaqueSession_pt  opaqueSession_p,\nsolClient_opaqueMsg_pt      msg_p,\nvoid                       *user_p);\n </code>"]
pub type solClient_session_createFuncInfo_t = solClient_session_createFuncInfo;
#[doc = " @struct solClient_flow_createFuncInfo\n\n Function information for Flow creation. This is set on a per-Flow basis.\n The application must set the eventInfo callback information. All Flows must have an event callback registered.\n\n The application must set the <i>rxMsgInfo</i> callback interface.  The <i>rxInfo</i> interface is deprecated it the pointer\n must be set to NULL.\n\n Applications will use the <i>rxMsgInfo</i> callback interface. The application has available to it a\n ::solClient_opaqueMsg_pt, which can be kept for later processing and provides a structured interface for accessing elements of the\n received message. The application callback routine then has the signature (see ::solClient_flow_rxMsgCallbackFunc_t):\n\n <code style=\"font-size:90%\">\nsolClient_rxMsgCallback_returnCode_t\napplicationRxMsgCallback (solClient_opaqueFlow_pt     opaqueFlow_p,\nsolClient_opaqueMsg_pt      msg_p,\nvoid                       *user_p);\n </code>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct solClient_flow_createFuncInfo {
    pub rxInfo: solClient_flow_createRxCallbackFuncInfo_t,
    pub eventInfo: solClient_flow_createEventCallbackFuncInfo_t,
    pub rxMsgInfo: solClient_flow_createRxMsgCallbackFuncInfo_t,
}
#[test]
fn bindgen_test_layout_solClient_flow_createFuncInfo() {
    const UNINIT: ::std::mem::MaybeUninit<solClient_flow_createFuncInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<solClient_flow_createFuncInfo>(),
        48usize,
        concat!("Size of: ", stringify!(solClient_flow_createFuncInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<solClient_flow_createFuncInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(solClient_flow_createFuncInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rxInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_flow_createFuncInfo),
            "::",
            stringify!(rxInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eventInfo) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_flow_createFuncInfo),
            "::",
            stringify!(eventInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rxMsgInfo) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_flow_createFuncInfo),
            "::",
            stringify!(rxMsgInfo)
        )
    );
}
#[doc = " @struct solClient_flow_createFuncInfo\n\n Function information for Flow creation. This is set on a per-Flow basis.\n The application must set the eventInfo callback information. All Flows must have an event callback registered.\n\n The application must set the <i>rxMsgInfo</i> callback interface.  The <i>rxInfo</i> interface is deprecated it the pointer\n must be set to NULL.\n\n Applications will use the <i>rxMsgInfo</i> callback interface. The application has available to it a\n ::solClient_opaqueMsg_pt, which can be kept for later processing and provides a structured interface for accessing elements of the\n received message. The application callback routine then has the signature (see ::solClient_flow_rxMsgCallbackFunc_t):\n\n <code style=\"font-size:90%\">\nsolClient_rxMsgCallback_returnCode_t\napplicationRxMsgCallback (solClient_opaqueFlow_pt     opaqueFlow_p,\nsolClient_opaqueMsg_pt      msg_p,\nvoid                       *user_p);\n </code>"]
pub type solClient_flow_createFuncInfo_t = solClient_flow_createFuncInfo;
#[doc = " @struct solClient_version_info\n\n A structure returned from solClient_version_get that contains version information.\n All the returned pointers are never NULL when returned from solClient_version_get.\n\n @see solClient_version_get()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct solClient_version_info {
    #[doc = "< A pointer to string with version, for example, \"1.1.1\"."]
    pub version_p: *const ::std::os::raw::c_char,
    #[doc = "< Date and time."]
    pub dateTime_p: *const ::std::os::raw::c_char,
    #[doc = "< A pointer to string with variant information (for example, type of operating system and compiler)."]
    pub variant_p: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_solClient_version_info() {
    const UNINIT: ::std::mem::MaybeUninit<solClient_version_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<solClient_version_info>(),
        24usize,
        concat!("Size of: ", stringify!(solClient_version_info))
    );
    assert_eq!(
        ::std::mem::align_of::<solClient_version_info>(),
        8usize,
        concat!("Alignment of ", stringify!(solClient_version_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version_p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_version_info),
            "::",
            stringify!(version_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dateTime_p) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_version_info),
            "::",
            stringify!(dateTime_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).variant_p) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_version_info),
            "::",
            stringify!(variant_p)
        )
    );
}
#[doc = " @struct solClient_version_info\n\n A structure returned from solClient_version_get that contains version information.\n All the returned pointers are never NULL when returned from solClient_version_get.\n\n @see solClient_version_get()"]
pub type solClient_version_info_pt = *mut solClient_version_info;
extern "C" {
    #[doc = " This function must be called before any other API interface call is made, with the exception of\n solClient_log_setCallback(), which can be called first to intercept all logs, and\n solClient_log_setFile(), which can be used to change the log destination when the\n log callback is not in use.  Typically solClient_initialize() is called once during\n program initialization.\n Only configuration property names starting with \\ref globalProps \"GLOBAL_\" are processed; other property names\n are ignored. Any values not supplied are set to default values.\n This function takes care of any required global initialization.\n Note that the property values are stored internally in the API, and the caller does not have to maintain\n the props array or the strings that are pointed to after this call completes. Also, the API does not modify any of\n the strings pointed to by props when processing the property list.\n @param initialLogLevel The initial log level for logs for all log categories. This value\n                        can later be changed using solClient_log_setFilterLevel. If the\n                        default log level is desired, use ::SOLCLIENT_LOG_DEFAULT_FILTER.\n                        However, it is preferred that the application supply the log level\n                        from its own command line (or some other form of configuration) so\n                        that the log level can quickly be changed without recompiling\n                        the application.\n @param props An array of name and value string pairs for \\ref globalProps \"global configuration properties\", or NULL, if there are no global properties to set.\n @returns ::SOLCLIENT_OK or ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_initialize(
        initialLogLevel: solClient_log_level_t,
        props: solClient_propertyArray_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " This function may be called after use of the API is completed.\n This function takes care of any global clean-up that might be required.\n It automatically frees all allocated resources, including those for Contexts and\n Sessions that have been previously created but are not destroyed.\n Note that if solClient_cleanup() is called while Sessions are connected, any messages\n buffered for transmission are discarded and not sent. See solClient_session_disconnect()\n for further information.\n In most applications, it is not necessary to call solClient_cleanup() as the resources in\n use are automatically recovered when the application exits. solClient_cleanup() exists for\n rare applications that may want recover all API resources and continue operating without using\n the API further.\n @returns ::SOLCLIENT_OK or ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_cleanup() -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Returns a string representation of the return code passed in.\n @param returnCode The return code to convert to a string representation.\n @returns A pointer to a constant character string. This pointer is never NULL."]
    pub fn solClient_returnCodeToString(
        returnCode: solClient_returnCode_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns a string representation of the subcode passed in.\n @param subCode The subcode to convert to a string representation.\n @returns A pointer to a constant character string. This pointer is never NULL."]
    pub fn solClient_subCodeToString(subCode: solClient_subCode_t)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns a string representation of the transmit statistic name for the given\n statistic constant passed in.\n\n @param        txStat transmit statistic constant (::solClient_stats_tx_t).\n @returns       A pointer to a constant char string. This pointer is never NULL."]
    pub fn solClient_txStatToString(txStat: solClient_stats_tx_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns a string representation of the receive statistic name for the given\n statistic constant passed in.\n\n @param        rxStat receive statistic constant (::solClient_stats_rx_t).\n @returns       A pointer to a constant char string. This pointer is never NULL."]
    pub fn solClient_rxStatToString(rxStat: solClient_stats_rx_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns a pointer to a ::solClient_errorInfo structure, which contains the last captured\n error information for the calling thread. This information is captured on a per-thread\n basis. The returned structure is only valid until the thread makes the next API call,\n so if the calling thread wants to keep any of the structure fields, it must make a\n local copy of the information of interest.\n\n Any API call that returns ::SOLCLIENT_FAIL or ::SOLCLIENT_NOT_READY also updates the per-thread\n error information.  Applications that wish extra information on the error, should retrieve the\n ::solClient_errorInfo structure.\n\n The API always sets the ::solClient_errorInfo information before invoking any application callback.\n Therefore application may always call solClient_getLastErrorInfo() while handling event callbacks.\n\n @returns A pointer to a ::solClient_errorInfo structure containing error information. This pointer is never NULL.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_getLastErrorInfo() -> solClient_errorInfo_pt;
}
extern "C" {
    #[doc = " Clears the last error info, which is recorded on a per-thread basis. The error information\n is reset such that the sub code is ::SOLCLIENT_SUBCODE_OK, the error strings are empty strings,\n etc.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_resetLastErrorInfo();
}
extern "C" {
    #[doc = " Returns version information for the API. The caller is given a pointer to an\n internal version structure of type solClient_version_info_t containing the\n version information.\n @param version_p A pointer to a structure to hold the version information.\n @return ::SOLCLIENT_OK or ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_version_get(
        version_p: *mut solClient_version_info_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Returns a Universally Unique Identifier (UUID) as a 128-bit value, as per IETF RFC 4122.\n Only a version 4 UUID (generated from random or pseudo-random numbers) is supported.\n @param uuid_p A pointer to UUID value to be filled in.\n @return ::SOLCLIENT_OK or ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_generateUUID(uuid_p: *mut solClient_uuid_t) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Returns a Universally Unique Identifier (UUID) as a NULL-terminated string, as per IETF RFC 4122.\n Only a version 4 UUID (generated from random or pseudo-random numbers) is supported.\n The size of the buffer provided must be at least ::SOLCLIENT_UUID_STRING_BUFFER_SIZE bytes in\n size to hold the NULL-terminated UUID string value.\n An example output string is: 4e112068-7836-4e2f-af14-82682569bdfe (NULL-terminated).\n @param uuid_p A pointer to string buffer to fill in.\n @param bufferSize The size (in bytes) of provided buffer; must be at least ::SOLCLIENT_UUID_STRING_BUFFER_SIZE.\n @return ::SOLCLIENT_OK or ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_generateUUIDString(
        uuid_p: *mut ::std::os::raw::c_char,
        bufferSize: usize,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Appends (after a '/' delimeter') a Universally Unique Identifier (UUID) as a NULL-terminated string to a\n given input string.\n Only a version 4 UUID (generated from random or pseudo-random numbers) is supported.\n The size of the buffer provided must be at least ::SOLCLIENT_UUID_STRING_BUFFER_SIZE bytes in\n size to hold the NULL-terminated UUID string value.\n An example output string is: 4e112068-7836-4e2f-af14-82682569bdfe (NULL-terminated).\n @param inputStr A pointer to a null terminated string.\n @param uuid_p A pointer to string buffer to fill in.\n @param bufferSize The size (in bytes) of provided buffer; must be at least (strlen(inputStr) + ::SOLCLIENT_UUID_STRING_BUFFER_SIZE).\n @return ::SOLCLIENT_OK or ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_appendUUIDString(
        inputStr: *const ::std::os::raw::c_char,
        uuid_p: *mut ::std::os::raw::c_char,
        bufferSize: usize,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Allows the log level filter to be set. Any logs of lower severity\n than the filter level specified are not emitted by the API. For example, if the\n filter level is set to solClient_LOG_ERROR, then only logs of this severity or\n higher (for example, solClient_LOG_CRITICAL) are emitted. Less severe logs are filtered\n out. The log filter level is applied globally to ALL API Sessions.\n If this function is not called, then the default log filter level of\n ::SOLCLIENT_LOG_DEFAULT_FILTER is in force.\n @param category The log category to which the new log level applies.\n @param level The new log level at which logs are emitted.\n @return ::SOLCLIENT_OK or ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_log_setFilterLevel(
        category: solClient_log_category_t,
        level: solClient_log_level_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Allows for the registration of an optional log callback, which is called\n each time a new, non-filtered, log message is emitted by the API. If a\n callback is not registered, then, by default, the API prints non-filtered\n logs to stderr, although the destination file can be changed through\n solClient_log_setFile(). Setting the callback routine to NULL reverts to\n the default log output behavior.\n Note that solClient_log_setCallback() can be called before\n solClient_initialize() in order to intercept all logs.\n @param callback_p The routine to call for each non-filtered log.\n @param user_p     A pointer to opaque user data that is passed back to the log callback.\n @return ::SOLCLIENT_OK or ::SOLCLIENT_FAIL\n @see solClient_log_setFilterLevel()\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_log_setCallback(
        callback_p: solClient_log_callbackFunc_t,
        user_p: *mut ::std::os::raw::c_void,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Reset the log callback function to default log out behavior. All\n non-filtered logs are printed to stderr after this function is called.\n @return ::SOLCLIENT_OK or ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_log_unsetCallback() -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Allows the log file, which defaults to stderr, to be changed to a file specified\n by the caller. This file is only used if a log callback has not been set through\n solClient_log_setCallback(). Setting the file name to NULL or a zero-length string\n reverts the file back to stderr. If an error is encountered when\n writing a log message to the specified file, the log file is automatically reverted\n back to stderr.\n Note that solClient_log_setFile() can be called before solClient_initialize().\n @param logFileName_p The new file name to use, or use the default (stderr) if NULL or zero length.\n @return ::SOLCLIENT_OK or ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_log_setFile(
        logFileName_p: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Returns a string representation (for example, \"API\") of the log category passed in.\n @param category The log category to convert to a string representation.\n @return A pointer to a constant character string. This pointer is never NULL."]
    pub fn solClient_log_categoryToString(
        category: solClient_log_category_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns a string representation (for example, \"ERROR\") of the log level passed in.\n @param level The log level to convert to a string representation.\n @return A pointer to a constant character string. This pointer is never NULL."]
    pub fn solClient_log_levelToString(
        level: solClient_log_level_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Creates a new Context. The @ref ContextProps \"context properties\" are supplied as an array of\n name/value pointer pairs, where the name and value are both strings. Only configuration\n property names starting with \"CONTEXT_\" are processed; other property names\n are ignored. Any values not supplied are set to default values.\n Passing in NULL causes all Context\n properties to be set to their default values.\n\n It is highly recommended that applications should always use an automatically created internal context\n thread. Passing in ::SOLCLIENT_CONTEXT_PROPS_DEFAULT_WITH_CREATE_THREAD\n causes the Context to have the context thread created automatically and all other Context properties at\n their default value. Alternatively, an internal thread can be created by enabling ::SOLCLIENT_CONTEXT_PROP_CREATE_THREAD.\n\n If an external context thread  (the default for historical reasons) is needed under special circumstances,\n the application must supply a thread to do the work on\n behalf of a Context. The application does this by having a Context thread call solClient_context_processEvents(). In some rare cases, application can also use an optional file descriptor event service.\n  Applications can register\n application file descriptors for events using solClient_context_registerForFdEvents(). The file descriptor event callback routine that has\n been registered is invoked by the Context thread when the event occurs.\n\n As an alternative, the application can provide the file descriptor event registration mechanism itself, which then\n results in the API using the application-provided events. To activate this mode, the application must provide file descriptor event\n register and deregister function at the time of Context creation (see ::solClient_context_createRegisterFdFuncInfo). If the register/deregister function\n pointers provided are NULL, then the internal API event mechanism is used. When the application is providing events to the API,\n solClient_context_processEvents() must not be called. Instead solClient_context_timerTick() must be called on regular basis as\n API timers are dependent on this function which is usually invoked during solClient_context_processEvents().\n\n\n When the Context is created, an opaque Context pointer is returned to the caller, and this value\n is then used for any Context-level operations, such as creating a Session.\n\n Note that the property values are stored internally in the API, and the caller does not have to maintain\n the props array or the strings that are pointed to after this call completes. The API also does not modify any of\n the strings pointed to by props when processing the property list.\n\n @param props           An array of name/value string pair pointers to configure @ref ContextProps \"context properties\".\n @param opaqueContext_p An opaque Context pointer is returned that refers to the created Context.\n @param funcInfo_p      A pointer to a structure that provides information on optional file descriptor event functions.\n @param funcInfoSize    The size of the passed-in funcInfo structure (in bytes) to allow the structure to grow in the future.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_context_create(
        props: solClient_propertyArray_pt,
        opaqueContext_p: *mut solClient_opaqueContext_pt,
        funcInfo_p: *mut solClient_context_createFuncInfo_t,
        funcInfoSize: usize,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Destroys a previously created Context. On return, the opaque Context pointer\n is set to NULL. This operation <b>must not</b> be performed in a Context callback\n for the Context being destroyed. This includes all Sessions on the Context, timers on\n the Context, and application-supplied register file descriptor (see\n ::solClient_context_createFuncInfo) functions.\n\n @param opaqueContext_p An opaque Context returned when Context was created.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_context_destroy(
        opaqueContext_p: *mut solClient_opaqueContext_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Allows the application to optionally register an application file descriptor for events (for example,\n ::SOLCLIENT_FD_EVENT_READ) for an application file descriptor. The events parameter is an OR of\n the events requested (for example, if read and write events are requested, events is\n ::SOLCLIENT_FD_EVENT_READ | ::SOLCLIENT_FD_EVENT_WRITE).\n When the specified event(s) occur, the specified callback routine is invoked (in the context of the\n Context thread that called solClient_ProcessEvents), and the opaque user value is provided.\n When an event occurs, the event stays registered for the file descriptor unless the deregister function for the\n event is called, or if register is called again and the event is not specified.\n \\n\n NOTE: When this function is called for a given file descriptor, the specified events replace any previously\n       specified events. Therefore all events for a given file descriptor share the same callback routine and user data.\n \\n\n\n @param opaqueContext_p The opaque Context that was returned when Context was created.\n @param fd              The file descriptor being registered.\n @param events          The events being requested (multiple events can be OR'ed together).\n @param callback_p      The callback routine to be invoked.\n @param user_p          The opaque user data pointer (can be NULL) that is returned in the callback.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @li ::SOLCLIENT_SUBCODE_OUT_OF_RESOURCES - The number of file descriptors exceeds the operating system limit (refer to \\ref feature-limitations \"Feature Limitations\").\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_context_registerForFdEvents(
        opaqueContext_p: solClient_opaqueContext_pt,
        fd: solClient_fd_t,
        events: solClient_fdEvent_t,
        callback_p: solClient_context_fdCallbackFunc_t,
        user_p: *mut ::std::os::raw::c_void,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Allows the application to optionally deregister an application file descriptor for events (for example,\n ::SOLCLIENT_FD_EVENT_READ) for an application file descriptor. The events is an OR of the events no longer\n needed. If a file descriptor is called that has not been registered, or if an event is specified for a file descriptor that\n was not registered, ::SOLCLIENT_OK is returned. For example, in clean-up code, this function can be blindly\n called with ::SOLCLIENT_FD_EVENT_ALL for a given file descriptor with no ill effects.\n @param opaqueContext_p The opaque Context that was returned when Context was created.\n @param fd              The file descriptor that events are being deregistered for.\n @param events          The events no longer being requested (multiple events can be ORed together).\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_context_unregisterForFdEvents(
        opaqueContext_p: solClient_opaqueContext_pt,
        fd: solClient_fd_t,
        events: solClient_fdEvent_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Must be called by the Context thread for a given Context to have events processed. If messages\n arrive on a Session, the Session callback function is invoked in the Context of the calling Context\n thread. If application file descriptors have been registered and requested events have occurred on those file descriptors, the\n registered file descriptor event callback function is invoked in the Context of the calling Context thread. The\n Session event callback routine can also be invoked. This routine must be called as often as possible\n by the Context thread. Also, the application must avoid long processing times in the called\n messsage receive or application file descriptor event routines that can be invoked by this function.\n\n Note that if the application has taken over responsibility of generating file descriptor\n events, then this routine must not be called by the application. Instead solClient_context_timerTick()\n must be called on regular basis as API timers are dependent on this function which is usually invoked\n during solClient_context_processEvents().\n\n @param opaqueContext_p The opaque Context that was returned when Context was created.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_context_processEvents(
        opaqueContext_p: solClient_opaqueContext_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " This function must be called by the Context thread for a given Context to have events\n processed. This function also takes a second parameter 'wait'.\n If non-zero, solClient_context_processEventsWait will wait for an event (timeout or received message) and\n is identical to simply calling solClient_context_processEvents().\n\n When wait is zero, solClient_context_processEventsWait() always returns\n immediately, and if no received events occurred, this function returns\n ::SOLCLIENT_NOEVENT.\n\n See also solClient_context_processEvents() for a more information.\n\n @param opaqueContext_p Opaque Context that was returned when Context was created.\n @param wait When 1, processEvents waits for an event; when 0, it returns\n              immediately with ::SOLCLIENT_NOEVENT if there is nothing pending.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL, ::SOLCLIENT_NOEVENT\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_context_processEventsWait(
        opaqueContext_p: solClient_opaqueContext_pt,
        wait: solClient_bool_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Allows the application to start a timer. When the timer expires, the\n specified timer callback routine is invoked with the user pointer that was specified\n at timer start time. The timer duration is subject to the timer resolution specified\n by the Context property ::SOLCLIENT_CONTEXT_PROP_TIME_RES_MS. The timer duration is rounded\n up to the nearest timer resolution interval. For example, if the Context timer resolution\n is 50 ms, and a timer is started with a duration of 60 ms, then the timer duration is\n rounded up to 100 ms (2 ticks), and then one further tick is added for a total timer\n duration of 150 ms. This extra tick accounts for the fact that the current tick might\n be about to advance when the timer is started. Therefore, the actual timeout in this\n example is in the range of 100 ms to 150 ms.\n The timer callback routine is invoked in the cntext of the\n Context thread, and timeouts occur as a result of calling solClient_context_processEvents().\n The timer durations are approximate; the actual duration can be affected by the\n processing time spent in other callbacks by the Context thread, such as for Session events,\n received messages, and file descriptor events. This timer service should only be used for applications\n that require a coarse timer service (for example, a guard timer, or other timer uses that do\n not require a highly accurate timer service).\n\n When a one-shot timer expires, the timer is automatically cancelled. When a repeat\n timer expires, the timer is automatically rescheduled for the same duration, and\n continues to run until stopped using solClient_context_stopTimer.\n\n The invoked timer callback routine is allowed to start and stop timers.\n \\n\n\n @param opaqueContext_p The opaque Context that was returned when Context was created.\n @param timerMode       The type of timer to start (one-shot or repeat).\n @param durationMs      The requested timer duration (in milliseconds).\n @param callback_p      The routine to invoke when the timer expires.\n @param user_p          A pointer to opaque user data that is provided to the callback routine.\n @param timerId_p       A pointer to a returned timer ID which is used to stop a timer.\n @see solClient_context_stopTimer()\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @li ::SOLCLIENT_SUBCODE_OUT_OF_RESOURCES - The maximum number of timers started for context\\n\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_context_startTimer(
        opaqueContext_p: solClient_opaqueContext_pt,
        timerMode: solClient_context_timerMode_t,
        durationMs: solClient_uint32_t,
        callback_p: solClient_context_timerCallbackFunc_t,
        user_p: *mut ::std::os::raw::c_void,
        timerId_p: *mut solClient_context_timerId_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Allows the application to stop a previously started timer. Timers that expire\n and have their callback routine invoked are not required to be stopped by the application.\n @param opaqueContext_p The opaque Context that was returned when Context was created.\n @param timerId_p       A pointer to the identifier of the timer to be stopped; previously\n                        returned from solClient_context_startTimer(). The timer id is set to\n                        ::SOLCLIENT_CONTEXT_TIMER_ID_INVALID when returned.\n @see solClient_context_startTimer()\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_context_stopTimer(
        opaqueContext_p: solClient_opaqueContext_pt,
        timerId_p: *mut solClient_context_timerId_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " When the application takes over all file descriptor event generation, the application\n must also call this routine at regular intervals (specified by the Context property\n ::SOLCLIENT_CONTEXT_PROP_DEFAULT_TIME_RES_MS) to provide a timer tick for timer\n processing. When the application calls solClient_context_processEvents() for the Context,\n which is the normal mode of operation, then the application must not call this routine because\n solClient_context_processEvents() takes care of generating timer ticks.\n When this routine is invoked, it might result in the invocation of timer expiry callbacks.\n\n If the time interval between calls to solClient_context_timerTick() exceeds 60000 ms (60 seconds)\n the API assumes the system clock has changed, resets its internal concept of time, and ignores\n the call to solClient_context_timerTick().  Consequently, if the application attempts to use a\n timer resolution greater than 60 seconds, timers will never expire and any resolution greater\n than 30 seconds can cause timer ticks to be missed.\n\n @param opaqueContext_p The opaque Context that was returned when the Context was created.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_context_timerTick(
        opaqueContext_p: solClient_opaqueContext_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Creates a new Session within a specified Context. The @ref SessionProps \"session properties\"\n are supplied as an array of name/value pointer pairs, where the name and value are both strings.\n Only configuration property names starting with \"SESSION_\" are processed; other property names\n are ignored. Any values not supplied are set to default values.\n When the Session is created, an opaque Session pointer is returned to the caller, and this value\n is then used for any Session-level operations (for example, sending a message).\n The passed-in structure functInfo_p provides information on the message receive callback\n function and the Session event function which the application has provided for this Session.\n Both of these callbacks are mandatory. The message receive callback is invoked for each\n received message on this Session. The Session event callback is invoked when Session events\n occur, such as the Session going up or down. Both callbacks are invoked in the context\n of the Context thread to which this Session belongs.\n Note that the property values are stored internally in the API and the caller does not have to maintain\n the props array or the strings that are pointed to after this call completes. When processing the property list, the API\n will not modify any of the strings pointed to by props.\n \\n\n\n @param props           An array of name/value string pair pointers to configure @ref SessionProps \"session properties\".\n @param opaqueContext_p The Context in which the Session is to be created.\n @param opaqueSession_p An opaque Session pointer is returned that refers to the created Session.\n @param funcInfo_p      A pointer to a structure that provides information on callback functions for events and received messages.\n @param funcInfoSize    The size (in bytes) of the passed-in funcInfo structure to allow the structure to grow in the future.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_create(
        props: solClient_propertyArray_pt,
        opaqueContext_p: solClient_opaqueContext_pt,
        opaqueSession_p: *mut solClient_opaqueSession_pt,
        funcInfo_p: *mut solClient_session_createFuncInfo_t,
        funcInfoSize: usize,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Destroys a previously created Session. Upon return, the opaque Session pointer\n is set to NULL. If the Session being destroyed is still in a connected state,\n any buffered messages which have not been sent yet are\n discarded. If the application wants to ensure that any buffered messages are\n first sent, solClient_session_disconnect() must be\n called before solClient_session_destroy().\n\n This operation <b>must not</b> be performed in a Session callback\n for the Session being destroyed. This includes all Flows on the Session,\n as well as the application supplied event and data callback functions (see\n ::solClient_session_createFuncInfo) functions.\n @param opaqueSession_p An opaque Session that was returned when the Session was created.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_destroy(
        opaqueSession_p: *mut solClient_opaqueSession_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Returns the Context associated with the specified Session. Sessions are created\n within a Context (see ::solClient_session_create) and this routine can be used\n if the application has a Session pointer and needs to determine the associated\n Context. For example, in a Session event callback in which a Session pointer is\n provided, if the application wishes to start a timer, it needs the Context\n pointer, and this routine can be used to get the Context pointer from the\n Session pointer.\n @param opaqueSession_p An opaque Session that was returned when the Session was created.\n @param opaqueContext_p An opaque Context associated with the Session that is returned.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_getContext(
        opaqueSession_p: solClient_opaqueSession_pt,
        opaqueContext_p: *mut solClient_opaqueContext_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Allows certain properties of a Session to be modified after the Session has been created.\n Currently, only the following Session properties can be modified; attempting to specify other Session properties will result in\n ::SOLCLIENT_FAIL being returned:\n        @li ::SOLCLIENT_SESSION_PROP_APPLICATION_DESCRIPTION (Deprecated -- see Note below)\n        @li ::SOLCLIENT_SESSION_PROP_CLIENT_NAME (Deprecated -- see Note below)\n        @li ::SOLCLIENT_SESSION_PROP_HOST (may only be modified when Session is disconnected)\n        @li ::SOLCLIENT_SESSION_PROP_PORT (may only be modified when Session is disconnected)\n        @li ::SOLCLIENT_SESSION_PROP_OAUTH2_ACCESS_TOKEN  to update expiring access token; the update may take effect after the next session reconnection\n        @li ::SOLCLIENT_SESSION_PROP_OIDC_ID_TOKEN to update expiring idc id token; the update may take effect after the next session reconnection\n\n Note: Applications shall use ::solClient_session_modifyClientInfo() to modify the following Session properties:\n        @li ::SOLCLIENT_SESSION_PROP_APPLICATION_DESCRIPTION\n        @li ::SOLCLIENT_SESSION_PROP_CLIENT_NAME\n\n Note that the property values are stored internally in the API, and the caller does not have to maintain\n the props array or the strings that are pointed to after this call completes. The API also will not modify any of\n the strings pointed to by props when processing the property list.\n \\n\n\n @param opaqueSession_p The opaque Session that was returned when Session was created.\n @param props           An array of name/value string pair pointers to modify Session properties.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL, ::SOLCLIENT_WOULD_BLOCK\n @subcodes\n  @li ::SOLCLIENT_SUBCODE_CANNOT_MODIFY_WHILE_NOT_IDLE\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_modifyProperties(
        opaqueSession_p: solClient_opaqueSession_pt,
        props: solClient_propertyArray_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Allows the following client name and description properties of a Session to be modified after the Session has been created.\n        @li ::SOLCLIENT_SESSION_PROP_APPLICATION_DESCRIPTION\n        @li ::SOLCLIENT_SESSION_PROP_CLIENT_NAME\n\n The property modifications can be  carried out in a blocking or non-blocking mode, depending on the flag.\n Attempting to specify other Session properties will result in ::SOLCLIENT_FAIL being returned.\n\n Note that only one outstanding client info modification request is allowed.\n\n Note that changing client name property would trigger the P2P topic changes. To avoid message loss, it is recommended that this API\n is used only at the initialization time.\n\n Note that the property values are stored internally in the API, and the caller does not have to maintain\n the props array or the strings that are pointed to after this call completes. The API also will not modify any of\n the strings pointed to by props when processing the property list.\n \\n\n\n @param opaqueSession_p The opaque Session that was returned when Session was created.\n @param props   An array of name/value string pair pointers to modify Session properties.\n @param flag    A flag to control the operation. Valid flag for this operation is:\n  @li ::SOLCLIENT_MODIFYPROP_FLAGS_WAITFORCONFIRM\n\n @param correlation_p  A valid correlationTag pointer for non-blocking mode that will be returned in an asynchronous confirmation (::SOLCLIENT_SESSION_EVENT_MODIFYPROP_OK) or failure (::SOLCLIENT_SESSION_EVENT_MODIFYPROP_FAIL).\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL, ::SOLCLIENT_WOULD_BLOCK, ::SOLCLIENT_IN_PROGRESS ::SOLCLIENT_NOT_READY\n @subcodes\n @li ::SOLCLIENT_SUBCODE_CLIENT_NAME_ALREADY_IN_USE - The client name is in use by another client in the same VPN. Applications need to call ::solClient_session_connect after client name correction.\n @li ::SOLCLIENT_SUBCODE_CLIENT_NAME_INVALID - The client name chosen has been rejected as invalid by the broker.  Applications need to call ::solClient_session_connect after client name correction.\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_modifyClientInfo(
        opaqueSession_p: solClient_opaqueSession_pt,
        props: solClient_propertyArray_pt,
        flag: solClient_modifyPropFlags_t,
        correlation_p: *mut ::std::os::raw::c_void,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Gets the value of the specified Session property for the Session. The\n property value is copied out to buffer provided by the caller. The returned\n value is a NULL-terminated string.\n\n @param opaqueSession_p An opaque Session returned when the Session was created.\n @param propertyName_p  The name of the Session property for which the value is to be returned.\n @param buf_p           A pointer to the buffer provided by the caller in which to place the NULL-terminated property value string.\n @param bufSize         The size (in bytes) of the buffer provided by the caller.\n @returns               ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_getProperty(
        opaqueSession_p: solClient_opaqueSession_pt,
        propertyName_p: *const ::std::os::raw::c_char,
        buf_p: *mut ::std::os::raw::c_char,
        bufSize: usize,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Gets the value of the specified capability for the Session. The caller\n provides a solClient_field_t structure that is set on success with the proper type and value\n for the property requested.\n\n @param opaqueSession_p  The opaque Session returned when the Session was created.\n @param capabilityName_p The name of the \\ref sessioncapabilities \"Session capability\" the value is to be returned for.\n @param field_p          A pointer to the solClient_field_t provided by the caller in which to place the capability value.\n @param fieldSize        The size (in bytes) of the solClient_field_t provided by the caller.\n @returns               ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_getCapability(
        opaqueSession_p: solClient_opaqueSession_pt,
        capabilityName_p: *const ::std::os::raw::c_char,
        field_p: *mut solClient_field_t,
        fieldSize: usize,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Checks if the specified capability is set on the currently connected Session. Returns true if the Session has the capability requested.\n\n @param opaqueSession_p  The opaque Session returned when the Session was created.\n @param capabilityName_p The name of the \\ref sessioncapabilities \"session capability\" the value is to be returned for.\n @returns                True or False."]
    pub fn solClient_session_isCapable(
        opaqueSession_p: solClient_opaqueSession_pt,
        capabilityName_p: *const ::std::os::raw::c_char,
    ) -> solClient_bool_t;
}
extern "C" {
    #[doc = " Connects the specified Session. A Session connection can be carried out in a blocking or\n non-blocking mode, depending upon the Session property\n ::SOLCLIENT_SESSION_PROP_CONNECT_BLOCKING.\n In blocking mode, the calling thread is blocked until either the Session connection attempt\n succeeds or is determined to have failed. If the connection succeeds, ::SOLCLIENT_OK is\n returned. If the Session could not connect, ::SOLCLIENT_NOT_READY is returned.\n In non-blocking mode, ::SOLCLIENT_IN_PROGRESS is returned upon a successful Session connect\n request, and the connection attempt proceeds in the background.\n In both non-blocking and blocking mode, a Session event is generated for the Session:\n ::SOLCLIENT_SESSION_EVENT_UP_NOTICE, if the Session was connected successfully; or\n ::SOLCLIENT_SESSION_EVENT_CONNECT_FAILED_ERROR, if the Session failed to connect.\n For blocking mode, the Session event is issued before the call to\n solClient_session_connect() returns. For non-blocking mode, the timing is undefined (that is,\n it could occur before or after the call returns, but it will typically be after).\n A Session connection timer, controlled by the Session property\n ::SOLCLIENT_SESSION_PROP_CONNECT_TIMEOUT_MS, controls the maximum amount of\n time a Session connect attempt lasts for. If this amount time is exceeded,\n a ::SOLCLIENT_SESSION_EVENT_CONNECT_FAILED_ERROR event is issued for the Session.\n If there is an error when solClient_session_connect() is invoked, ::SOLCLIENT_FAIL\n is returned, and a Session event is not subsequently issued. Therefore, the caller must\n check for a return code of ::SOLCLIENT_FAIL if it has logic that depends upon a subsequent\n Session event to be issued.\n For a non-blocking Session connect invocation, if the Session connect attempt eventually\n fails, the last error information to indicate the reason for the failure cannot be\n determined by the calling thread, rather it must be discovered through the Session event\n callback (and solClient_getLastErrorInfo can be called in the Session event callback\n to get further information).\n For a blocking Session connect invocation, if the Session connect attempt does not\n return ::SOLCLIENT_OK, then the calling thread can determine the failure reason by immediately\n calling solClient_getLastErrorInfo.\n \\n\n\n @param opaqueSession_p The opaque Session that was returned when Session was created.\n  @return ::SOLCLIENT_OK (blocking mode only), ::SOLCLIENT_NOT_READY (blocking mode only), ::SOLCLIENT_IN_PROGRESS (non-blocking mode only) or ::SOLCLIENT_FAIL.\n @subcodes\n @li ::SOLCLIENT_SUBCODE_COMMUNICATION_ERROR - The underlying connection failed.\n\n The following subcodes can occur when a blocking connection operation is used (refer to ::SOLCLIENT_SESSION_PROP_CONNECT_BLOCKING).\n Otherwise, such errors are reported when a ::SOLCLIENT_SESSION_EVENT_CONNECT_FAILED_ERROR Session event is received.\n @li ::SOLCLIENT_SUBCODE_TIMEOUT - Timed out trying to connect the Session.\n @li ::SOLCLIENT_SUBCODE_LOGIN_FAILURE\n @li ::SOLCLIENT_SUBCODE_MSG_VPN_NOT_ALLOWED\n @li ::SOLCLIENT_SUBCODE_MSG_VPN_UNAVAILABLE\n @li ::SOLCLIENT_SUBCODE_CLIENT_USERNAME_IS_SHUTDOWN\n @li ::SOLCLIENT_SUBCODE_DYNAMIC_CLIENTS_NOT_ALLOWED\n @li ::SOLCLIENT_SUBCODE_CLIENT_NAME_ALREADY_IN_USE\n @li ::SOLCLIENT_SUBCODE_INVALID_VIRTUAL_ADDRESS\n @li ::SOLCLIENT_SUBCODE_CLIENT_DELETE_IN_PROGRESS\n @li ::SOLCLIENT_SUBCODE_TOO_MANY_CLIENTS\n @li ::SOLCLIENT_SUBCODE_UNKNOWN_FLOW_NAME\n @li ::SOLCLIENT_SUBCODE_UNTRUSTED_CERTIFICATE\n @li ::SOLCLIENT_SUBCODE_FAILED_LOADING_CERTIFICATE_AND_KEY\n @li ::SOLCLIENT_SUBCODE_CERTIFICATE_DATE_INVALID\n @li ::SOLCLIENT_SUBCODE_UNTRUSTED_COMMONNAME\n @li ::SOLCLIENT_SUBCODE_CONTROL_OTHER\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_connect(
        opaqueSession_p: solClient_opaqueSession_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Disconnects the specified Session. Once disconnected, topics/subscriptions\n can no longer be added or removed from the Session, messages can no longer be received for\n the Session, and messages cannot be sent to the Session. The Session definition remains,\n and the Session can be connected again (using solClient_session_connect()).\n When solClient_session_disconnect() is called, if there are buffered messages waiting to\n be transmitted for the Session (for example, because the send socket is full), the caller is\n blocked until all buffered data has been written to the send socket. Note the following: 1) This\n is done regardless of whether the Session has been configured for a blocking or non-blocking\n send operation (see ::SOLCLIENT_SESSION_PROP_SEND_BLOCKING).\n 2) A call to solClient_session_destroy(), solClient_context_destroy(), or solClient_cleanup()\n while a Session is connected (without first disconnecting the Session explicitly through a\n call to solClient_session_disconnect()) discards any buffered messages.\n @param opaqueSession_p The opaque Session returned when Session was created.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_disconnect(
        opaqueSession_p: solClient_opaqueSession_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " This is a deprecated function. It used to be required to call this function to start the\n Guaranteed Delivery protocol before Guaranteed messages could be sent.\n This is now done automatically as part of solClient_session_connect().\n New applications should not call this function, and they should not rely on\n the associated Session events ::SOLCLIENT_SESSION_EVENT_ASSURED_PUBLISHING_UP\n and ::SOLCLIENT_SESSION_EVENT_ASSURED_CONNECT_FAILED. To maintain backwards\n compatibility with existing applications, if\n solClient_session_startAssuredPublishing() is called\n (which is only allowed when the Session is in an established state), the\n application gets one of the following events: ::SOLCLIENT_SESSION_EVENT_ASSURED_PUBLISHING_UP,\n if sending of Guaranteed messages is allowed on the Session; or\n ::SOLCLIENT_SESSION_EVENT_ASSURED_CONNECT_FAILED.\n\n A new application can call\n solClient_session_send to send a Persistent or Non-Persistent\n message. A failure is returned if sending Guaranteed\n messages is not allowed on the Session (that is, if the Session is connected to an broker\n that does not support Guaranteed Messaging).\n \\n\n\n @param opaqueSession_p The opaque Session returned when Session was created.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @li ::SOLCLIENT_SUBCODE_INVALID_SESSION_OPERATION - Thrown when an attempt to start Guaranteed Messaging\n is made on a Session that does not support it.\\n\n @li ::SOLCLIENT_SUBCODE_ASSURED_MESSAGING_STATE_ERROR - Thrown when an attempt to start Guaranteed Messaging is made on a Session that is not established. \\n\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_startAssuredPublishing(
        opaqueSession_p: solClient_opaqueSession_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Sends a message on the specified Session. The message is composed of a number of optional\n components that are specified by the msg_p. The application should first\n allocate a solClient_msg, then use the methods defined in solClientMsg.h to\n build the message to send.\n\n solClient_session_sendMsg() returns SOLCLIENT_OK when the message has been successfully\n copied to the transmit buffer or underlying transport, this does not guarantee successful\n delivery to the Solace messaging broker. When sending Guaranteed messages (persistent or non-persistent),\n the application will receive a subsequent ::SOLCLIENT_SESSION_EVENT_ACKNOWLEDGEMENT event for all\n messages successfully delivered to the Solace messaging broker.  For Guaranteed messages, notifications of\n quota, permission, or other delivery problems will be indicated in a ::SOLCLIENT_SESSION_EVENT_REJECTED_MSG_ERROR\n event.\n\n <b>Special Buffering of Guaranteed Messages</b>\\n\n Guaranteed messages (::SOLCLIENT_DELIVERY_MODE_PERSISTENT or ::SOLCLIENT_DELIVERY_MODE_NONPERSISTENT) are\n assured by the protocol between the client and the Solace message router.  To make developers' task easier,\n guaranteed messages are queued for delivery in many instances:\n @li While transport (TCP) flow controlled.\n @li While message router flow controlled.\n @li While sessions are connecting or reconnecting.\n @li While sessions are disconnected or down.\n\n The C-SDK will buffer up to a publishers window size (::SOLCLIENT_SESSION_PROP_PUB_WINDOW_SIZE) of guaranteed messages before\n solClient_session_sendMsg() will either block (when ::SOLCLIENT_SESSION_PROP_SEND_BLOCKING is enabled) or return ::SOLCLIENT_WOULD_BLOCK\n (on active sessions) or return ::SOLCLIENT_NOT_READY (on disconnected or reconnecting sessions).\n\n For the most part this is desired behavior. Transient sessions failures do not require special handling in applications. When\n ::SOLCLIENT_SESSION_PROP_RECONNECT_RETRIES is non-zero, the underlying transport will automatically reconnect and the publishing\n application does not need to concern itself with special handling for the transient reconnecting state.\n\n @param opaqueSession_p The opaque Session returned when the Session was created.\n @param msg_p           The opaque message created by solClient_msg_alloc.\n @see @ref adConsiderations\n @return ::SOLCLIENT_OK, ::SOLCLIENT_NOT_READY, ::SOLCLIENT_FAIL, ::SOLCLIENT_WOULD_BLOCK\n @subcodes\n @li ::SOLCLIENT_SUBCODE_SESSION_NOT_ESTABLISHED - An attempt was made to send a direct (non-guaranteed) message on a non-established\n Session. Guaranteed messages are queued for later transmission on non-established Sessions.\n @li ::SOLCLIENT_SUBCODE_TOPIC_TOO_LARGE\n @li ::SOLCLIENT_SUBCODE_TOPIC_MISSING\n @li ::SOLCLIENT_SUBCODE_USER_DATA_TOO_LARGE\n @li ::SOLCLIENT_SUBCODE_QUEUENAME_TOO_LARGE\n @li ::SOLCLIENT_SUBCODE_QUEUENAME_INVALID_MODE\n @li ::SOLCLIENT_SUBCODE_QUEUENAME_TOPIC_CONFLICT\n @li ::SOLCLIENT_SUBCODE_MAX_TOTAL_MSGSIZE_EXCEEDED\n @li ::SOLCLIENT_SUBCODE_DELIVER_TO_ONE_INVALID\n @li ::SOLCLIENT_SUBCODE_INVALID_SESSION_OPERATION - An attempt was made to send a Guaranteed message to a Session that does not support Guaranteed Messaging.\n @li ::SOLCLIENT_SUBCODE_TIMEOUT - Timed-out trying to write a message to socket,\n     waiting for Session to be established (only for blocking sends; refer to ::SOLCLIENT_SESSION_PROP_SEND_BLOCKING),\n     or waiting for an open publisher window (only when using ::SOLCLIENT_DELIVERY_MODE_PERSISTENT or\n     ::SOLCLIENT_DELIVERY_MODE_NONPERSISTENT with blocking send operation).\n @li ::SOLCLIENT_SUBCODE_COMMUNICATION_ERROR - The underlying connection failed.\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_sendMsg(
        opaqueSession_p: solClient_opaqueSession_pt,
        msg_p: solClient_opaqueMsg_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Sends the given Solace Message Format (SMF) message on the specified Session.\n\n solClient_session_sendSmf() returns SOLCLIENT_OK when the message has be successfully\n copied to the transmit buffer or underlying transport, this does not guarantee successful\n delivery to the Solace messaging broker.\n\n @param opaqueSession_p The opaque Session returned when the Session was created.\n @param smfBufInfo_p    A pointer to the bufInfo describing a validly formatted SMF direct message.\n\n @return ::SOLCLIENT_OK, ::SOLCLIENT_NOT_READY, ::SOLCLIENT_FAIL, ::SOLCLIENT_WOULD_BLOCK\n @subcodes\n @li ::SOLCLIENT_SUBCODE_SESSION_NOT_ESTABLISHED - An attempt was made to send a Direct (that is, a non-Guaranteed) message on a non-established\n Session.\n @li ::SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE - The message was too large to be buffered.\n @li ::SOLCLIENT_SUBCODE_INVALID_SMF_MESSAGE - The buffer does not contain a validly formatted SMF messagem or the buffer contains a valid SMF message, but it is not a Direct message. Only Direct messages can be sent.\n @li ::SOLCLIENT_SUBCODE_TIMEOUT - Timed-out trying to write a message to socket,\n     waiting for Session to be established (only for blocking sends; refer to ::SOLCLIENT_SESSION_PROP_SEND_BLOCKING)\n @li ::SOLCLIENT_SUBCODE_COMMUNICATION_ERROR - The underlying connection failed.\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_sendSmf(
        opaqueSession_p: solClient_opaqueSession_pt,
        smfBufInfo_p: solClient_bufInfo_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Sends multiple messages on the specified Session. For direct messages, using this function is more efficient than multiple calls to\n solClient_session_send(). This routine is suitable when an application is able to construct multiple\n messages at once from a single stimulus.\n\n Note that the number of messages which can be sent through a single call to solClient_session_sendMultipleMsg()\n is limited to ::SOLCLIENT_SESSION_SEND_MULTIPLE_LIMIT.\n\n For Sessions in which solClient_session_sendMultipleMsg() is used, it is recommended that the Session\n property ::SOLCLIENT_SESSION_PROP_TCP_NODELAY be enabled (it is enabled by default).\n With solClient_session_sendMultipleMsg() multiple messages are sent at once onto a TCP connection, and therefore\n there is no need to have the operating system carry out the TCP delay algorithm to cause fuller IP packets.\n\n Guaranteed Delivery messages may be specified. It is recommended that all messages to be sent in a batch  have\n the same delivery mode.\n\n solClient_session_sendMultipleMsg() returns SOLCLIENT_OK when the messages have been successfully\n copied to the transmit buffer or underlying transport, this does not guarantee successful\n delivery to the Solace messaging broker. When sending Guaranteed messages (persistent or non-persistent),\n the application will receive a subsequent ::SOLCLIENT_SESSION_EVENT_ACKNOWLEDGEMENT event for all\n messages successfully delivered to the Solace messaging broker.  For Guaranteed messages, notifications of\n quota, permission, or other delivery problems will be indicated in a ::SOLCLIENT_SESSION_EVENT_REJECTED_MSG_ERROR\n event.\n\n solClient_session_sendMultipleMsg() takes as an argument a location to store the number of\n messages written (<i>numberOfMessagesWritten</i>). This value will always be equal to the requested\n <i>numberOfMessages</i> when ::SOLCLIENT_OK is returned.   However on all other return values, it may be\n possible that part of the message array (<i>msgArray_p</i>) has been written and this value <b>must</b> be\n checked by applications that need to know which messages have been sent and which have not.\n\n @param opaqueSession_p         The opaque Session returned when the Session was created.\n @param msgArray_p              A pointer to an array of solClient_opaqueMsg_pt pointers. Each entry describes one message to be sent.\n @param numberOfMessages        The number of messages provided in the message array.\n @param numberOfMessagesWritten A pointer to the variable to receive the returned number of messages accepted by SolClient.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_NOT_READY, ::SOLCLIENT_FAIL, ::SOLCLIENT_WOULD_BLOCK"]
    pub fn solClient_session_sendMultipleMsg(
        opaqueSession_p: solClient_opaqueSession_pt,
        msgArray_p: *mut solClient_opaqueMsg_pt,
        numberOfMessages: solClient_uint32_t,
        numberOfMessagesWritten: *mut solClient_uint32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Sends multiple Solace Message Format (SMF) messages on the specified Session.\n\n @param opaqueSession_p The opaque Session returned when the Session was created.\n @param smfBufInfo_p    A pointer to the bufInfo array describing validly formatted SMF Direct message.\n @param numberOfMessages The number of messages in the smfBufInfo_p array.\n\n solClient_session_sendMultipleSmf() returns SOLCLIENT_OK when the message has be successfully\n copied to the transmit buffer or underlying transport, this does not guarantee successful\n delivery to the Solace messaging broker.\n\n @return ::SOLCLIENT_OK, ::SOLCLIENT_NOT_READY, ::SOLCLIENT_FAIL, ::SOLCLIENT_WOULD_BLOCK\n @subcodes\n @li ::SOLCLIENT_SUBCODE_SESSION_NOT_ESTABLISHED - An attempt was made to send a Direct (that is, non-Guaranteed) message on a non-established\n Session.\n @li ::SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE - The message was too large to be buffered.\n @li ::SOLCLIENT_SUBCODE_INVALID_SMF_MESSAGE - The buffer does not contain a validly formatted SMF messagem or the buffer contains a valid SMF message, but it is not a Direct message. Only Direct messages can be sent.\n @li ::SOLCLIENT_SUBCODE_TIMEOUT - Timed-out trying to write a message to socket,\n     waiting for Session to be established (only for blocking sends; refer to ::SOLCLIENT_SESSION_PROP_SEND_BLOCKING).\n @li ::SOLCLIENT_SUBCODE_COMMUNICATION_ERROR - The underlying connection failed.\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_sendMultipleSmf(
        opaqueSession_p: solClient_opaqueSession_pt,
        smfBufInfo_p: solClient_bufInfo_pt,
        numberOfMessages: solClient_uint32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Adds a Topic subscription to a Session. Messages matching the subscription\n are delivered to the Session's message receive callback. When Topic dispatching is in use,\n messages matching this subscription are only delivered to the Session callback if they\n are not delivered to a more specific callback.\n @see @ref subscription-syntax\n @see @ref topic-dispatch\n\n @param opaqueSession_p An opaque Session returned when the Session was created.\n @param topicSubscription_p The Topic subscription string (a NULL-terminated UTF-8 string).\n @return ::SOLCLIENT_OK, ::SOLCLIENT_NOT_READY, ::SOLCLIENT_FAIL, ::SOLCLIENT_WOULD_BLOCK, ::SOLCLIENT_IN_PROGRESS\n @subcodes\n @li ::SOLCLIENT_SUBCODE_INVALID_TOPIC_SYNTAX\n @li ::SOLCLIENT_SUBCODE_SUBSCRIPTION_ACL_DENIED\n @li ::SOLCLIENT_SUBCODE_SESSION_NOT_ESTABLISHED - An attempt was made to operate on a non-established Session.\n @li ::SOLCLIENT_SUBCODE_TIMEOUT - Timed out trying to write subscribe request to socket,\n     waiting for Session to be established, or waiting for internal resources.\n     (Only for blocking subscription operations. Refer to ::SOLCLIENT_SESSION_PROP_SUBSCRIBE_BLOCKING)\n @li ::SOLCLIENT_SUBCODE_COMMUNICATION_ERROR - The underlying connection failed.\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_topicSubscribe(
        opaqueSession_p: solClient_opaqueSession_pt,
        topicSubscription_p: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Adds a Topic subscription to a Session. This extended version of the subscribe function\n allows for more control of the operation through flags. Messages matching the subscription\n are delivered to the Session's message receive callback. When Topic dispatching is in use,\n messages matching this subscription are only delivered to the Session callback if they\n are not delivered to a more specific callback.\n @see @ref subscription-syntax\n @see @ref topic-dispatch\n\n @param opaqueSession_p The opaque Session returned when Session was created.\n @param flags \\ref subscribeflags \"Flags\" to control the operation. Valid flags for this operation are:\n @li ::SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM\n @li ::SOLCLIENT_SUBSCRIBE_FLAGS_REQUEST_CONFIRM\n\n @param topicSubscription_p The Topic subscription string (a NULL-terminated UTF-8 string).\n @return ::SOLCLIENT_OK, ::SOLCLIENT_NOT_READY, ::SOLCLIENT_FAIL, ::SOLCLIENT_WOULD_BLOCK, ::SOLCLIENT_IN_PROGRESS\n @subcodes\n @li ::SOLCLIENT_SUBCODE_INVALID_TOPIC_SYNTAX\n @li ::SOLCLIENT_SUBCODE_SUBSCRIPTION_ACL_DENIED\n @li ::SOLCLIENT_SUBCODE_SESSION_NOT_ESTABLISHED - An attempt was made to operate on a non-established Session.\n @li ::SOLCLIENT_SUBCODE_TIMEOUT - Timed-out trying to write a subscribe request to socket,\n     waiting for a Session to be established, or waiting for internal resources.\n     (Only for blocking subscription operations. Refer to ::SOLCLIENT_SESSION_PROP_SUBSCRIBE_BLOCKING);\n     or timed-out waiting for a confirm (only when using ::SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM).\n @li ::SOLCLIENT_SUBCODE_COMMUNICATION_ERROR - The underlying connection failed.\n\n The following subcodes can occur when using ::SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM. Otherwise, such errors are reported\n when a ::SOLCLIENT_SESSION_EVENT_SUBSCRIPTION_ERROR Session event is received.\n @li ::SOLCLIENT_SUBCODE_OUT_OF_RESOURCES - The broker cannot accept any more Topic subscriptions. (This subcode only occurs when using the Topic Routing Blade.)\n @li ::SOLCLIENT_SUBCODE_SUBSCRIPTION_ALREADY_PRESENT (see ::SOLCLIENT_SESSION_PROP_IGNORE_DUP_SUBSCRIPTION_ERROR)\n @li ::SOLCLIENT_SUBCODE_SUBSCRIPTION_TOO_MANY\n @li ::SOLCLIENT_SUBCODE_SUBSCRIPTION_ACL_DENIED\n @li ::SOLCLIENT_SUBCODE_SUBSCRIPTION_OTHER\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_topicSubscribeExt(
        opaqueSession_p: solClient_opaqueSession_pt,
        flags: solClient_subscribeFlags_t,
        topicSubscription_p: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Adds a Topic subscription to a Session like ::solClient_session_topicSubscribeExt(),\n but this function also allows a different message receive callback and dispatchUser_p to be specified.\n Specifying a NULL funcInfo_p or if funcInfo_p references a NULL  dispatchCallback_p and a NULL dispatchUser_p makes this function\n act the same as ::solClient_session_topicSubscribeExt(). Used in this manner, an application can set the correlationTag, which appears in asynchronouus confirmations (::SOLCLIENT_SESSION_EVENT_SUBSCRIPTION_OK). Setting correlationTag is not available when using\n ::solClient_session_topicSubscribeExt().\n\n Usually this API is used to provide a separate callback and user pointer for messages received on the given topic.\n The Session property ::SOLCLIENT_SESSION_PROP_TOPIC_DISPATCH must be enabled for a non-NULL callback to be\n specified. When funcInfo_p is non-NULL and a dispatchCallback_p is specified, the callback pointer and dispatchUser_p are stored\n in an internal callback table. funcInfo_p is <b>not</b> saved by the API.\n\n @see @ref subscription-syntax\n @see @ref topic-dispatch\n\n @param opaqueSession_p The opaque Session returned when Session was created.\n @param flags \\ref subscribeflags \"Flags\" to control the operation. Valid flags for this operation are:\n @li ::SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM\n @li ::SOLCLIENT_SUBSCRIBE_FLAGS_REQUEST_CONFIRM\n @li ::SOLCLIENT_SUBSCRIBE_FLAGS_LOCAL_DISPATCH_ONLY\n\n @param topicSubscription_p The Topic subscription string (a NULL-terminated UTF-8 string).\n @param funcInfo_p         The message receive callback information. See struct solClient_session_rxMsgDispatchFuncInfo\n @param correlationTag     A correlationTag pointer that is returned as is in the confirm or fail sessionEvent for the\n                           subscription. This is only used if SOLCLIENT_SUBSCRIBE_FLAGS_REQUEST_CONFIRM is set and\n                           SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM is not set.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_NOT_READY, ::SOLCLIENT_FAIL, ::SOLCLIENT_WOULD_BLOCK, ::SOLCLIENT_IN_PROGRESS\n\n A successful call has a return code of ::SOLCLIENT_OK, except when using ::SOLCLIENT_SUBSCRIBE_FLAGS_REQUEST_CONFIRM without\n ::SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM. In that case, the return code will be ::SOLCLIENT_IN_PROGRESS because the call returns without\n waiting for the operation to complete.\n @subcodes\n @li ::SOLCLIENT_SUBCODE_INVALID_TOPIC_SYNTAX\n @li ::SOLCLIENT_SUBCODE_SUBSCRIPTION_ACL_DENIED\n @li ::SOLCLIENT_SUBCODE_SESSION_NOT_ESTABLISHED - An attempt was made to operate on a non-established Session.\n @li ::SOLCLIENT_SUBCODE_TIMEOUT - Timed-out trying to write a subscribe request to socket,\n     waiting for a Session to be established, or waiting for internal resources.\n     This subcode only occurs for blocking subscription operations (refer to ::SOLCLIENT_SESSION_PROP_SUBSCRIBE_BLOCKING),\n     or the operation timed-out waiting for a confirm (only when using ::SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM).\n @li ::SOLCLIENT_SUBCODE_COMMUNICATION_ERROR - The underlying connection failed.\n @li ::SOLCLIENT_SUBCODE_PARAM_CONFLICT - If subscribe flags ::SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM or ::SOLCLIENT_SUBSCRIBE_FLAGS_REQUEST_CONFIRM\n     are used with ::SOLCLIENT_SUBSCRIBE_FLAGS_LOCAL_DISPATCH_ONLY.\n\n The following subcodes can occur when using ::SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM. Otherwise, such errors are reported\n when a ::SOLCLIENT_SESSION_EVENT_SUBSCRIPTION_ERROR Session event is received.\n @li ::SOLCLIENT_SUBCODE_OUT_OF_RESOURCES - The broker cannot accept any more Topic subscriptions. (This subcode only occurs using the Topic Routing Blade.)\n @li ::SOLCLIENT_SUBCODE_SUBSCRIPTION_ALREADY_PRESENT (see ::SOLCLIENT_SESSION_PROP_IGNORE_DUP_SUBSCRIPTION_ERROR)\n @li ::SOLCLIENT_SUBCODE_SUBSCRIPTION_TOO_MANY\n @li ::SOLCLIENT_SUBCODE_SUBSCRIPTION_ACL_DENIED\n @li ::SOLCLIENT_SUBCODE_SUBSCRIPTION_OTHER\n @li ::SOLCLIENT_SUBCODE_INVALID_SESSION_OPERATION\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_topicSubscribeWithDispatch(
        opaqueSession_p: solClient_opaqueSession_pt,
        flags: solClient_subscribeFlags_t,
        topicSubscription_p: *const ::std::os::raw::c_char,
        funcInfo_p: *mut solClient_session_rxMsgDispatchFuncInfo_t,
        correlationTag: *mut ::std::os::raw::c_void,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Removes a Topic subscription from a Session.\n @see @ref subscription-syntax\n @see @ref topic-dispatch\n\n @param opaqueSession_p The opaque Session returned when Session was created.\n @param topicSubscription_p The Topic subscription string (a NULL-terminated UTF-8 string).\n @return ::SOLCLIENT_OK, ::SOLCLIENT_NOT_READY, ::SOLCLIENT_FAIL, ::SOLCLIENT_WOULD_BLOCK, ::SOLCLIENT_IN_PROGRESS\n @subcodes\n @li ::SOLCLIENT_SUBCODE_INVALID_TOPIC_SYNTAX\n @li ::SOLCLIENT_SUBCODE_SESSION_NOT_ESTABLISHED - An attempt was made to operate on a non-established Session.\n @li ::SOLCLIENT_SUBCODE_TIMEOUT - Timed out trying to write unsubscribe request to socket,\n     waiting for Session to be established, or waiting for internal resources.\n      This subcode only occurs for blocking subscription operations (refer to ::SOLCLIENT_SESSION_PROP_SUBSCRIBE_BLOCKING).\n @li ::SOLCLIENT_SUBCODE_COMMUNICATION_ERROR - The underlying connection failed.\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_topicUnsubscribe(
        opaqueSession_p: solClient_opaqueSession_pt,
        topicSubscription_p: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Removes a Topic subscription from a Session. This extended version of the Topic unsubscribe function\n allows for more control of the operation through flags.\n @see @ref subscription-syntax\n @see @ref topic-dispatch\n\n @param opaqueSession_p The opaque Session returned when Session was created.\n @param flags \\ref subscribeflags \"Flags\" to control the operation. Valid flags for this operation are:\n @li ::SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM\n @li ::SOLCLIENT_SUBSCRIBE_FLAGS_REQUEST_CONFIRM\n\n @param topicSubscription_p The Topic subscription string (a NULL-terminated UTF-8 string).\n @return ::SOLCLIENT_OK, ::SOLCLIENT_NOT_READY, ::SOLCLIENT_FAIL, ::SOLCLIENT_WOULD_BLOCK, ::SOLCLIENT_IN_PROGRESS\n @subcodes\n @li ::SOLCLIENT_SUBCODE_INVALID_TOPIC_SYNTAX\n @li ::SOLCLIENT_SUBCODE_SESSION_NOT_ESTABLISHED - An attempt was made to operate on a non-established Session.\n @li ::SOLCLIENT_SUBCODE_TIMEOUT - Timed out trying to write unsubscribe request to socket,\n     waiting for Session to be established, waiting for internal resources.\n      (This subcode only occurs only for blocking subscription operations; refer to ::SOLCLIENT_SESSION_PROP_SUBSCRIBE_BLOCKING),\n     or waiting for confirm (only when using ::SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM).\n @li ::SOLCLIENT_SUBCODE_COMMUNICATION_ERROR - The underlying connection failed\n\n The following subcodes can occur when using ::SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM. Otherwise, such errors are reported\n when a ::SOLCLIENT_SESSION_EVENT_SUBSCRIPTION_ERROR Session event is received.\n @li ::SOLCLIENT_SUBCODE_SUBSCRIPTION_NOT_FOUND (see ::SOLCLIENT_SESSION_PROP_IGNORE_DUP_SUBSCRIPTION_ERROR)\n @li ::SOLCLIENT_SUBCODE_SUBSCRIPTION_OTHER\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_topicUnsubscribeExt(
        opaqueSession_p: solClient_opaqueSession_pt,
        flags: solClient_subscribeFlags_t,
        topicSubscription_p: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Removes a Topic subscription from a Session like ::solClient_session_topicUnsubscribeExt(),\n but this function also allows a message receive callback and dispatchUser_p to be specified.\n Specifying a NULL funcInfo_p or if funcInfo_p references a NULL  dispatchCallback_p and a NULL dispatchUser_p makes this function\n act the same as ::solClient_session_topicUnsubscribeExt(). Used in this manner, an application can set the correlationTag which appears in asynchronouus confirmations (::SOLCLIENT_SESSION_EVENT_TE_UNSUBSCRIBE_OK). Setting correlationTag is not available when using\n ::solClient_session_topicUnsubscribeExt().\n\n Usually this API is used to provide a separate callback and user pointer for messages received on the given topic.\n The Session property ::SOLCLIENT_SESSION_PROP_TOPIC_DISPATCH must be enabled for a non-NULL callback to be\n specified. When funcInfo_p is non-NULL and a dispatchCallback_p is specified, the callback pointer and dispatchUser_p are removed\n from an internal callback table. funcInfo_p does not have to match the funcInfo_p used in ::solClient_session_topicSubscribeWithDispatch(). However,\n the contents referenced in funcInfo_p must match an entry found in the callback table.\n\n @see @ref subscription-syntax\n @see @ref topic-dispatch\n\n @param opaqueSession_p The opaque Session returned when Session was created.\n @param flags \\ref subscribeflags \"Flags\" to control the operation. Valid flags for this operation are:\n @li ::SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM\n @li ::SOLCLIENT_SUBSCRIBE_FLAGS_REQUEST_CONFIRM\n @li ::SOLCLIENT_SUBSCRIBE_FLAGS_LOCAL_DISPATCH_ONLY\n\n @param topicSubscription_p The Topic subscription string (a NULL-terminated UTF-8 string).\n @param funcInfo_p         The message receive callback information. See struct solClient_session_rxMsgDispatchFuncInfo.\n @param correlationTag     A correlationTag pointer that is returned as is in the confirm or fail sessionEvent for the\n                           subscription. This is only used if SOLCLIENT_SUBSCRIBE_FLAGS_REQUEST_CONFIRM is set and\n                           SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM is not set.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_NOT_READY, ::SOLCLIENT_FAIL, ::SOLCLIENT_WOULD_BLOCK, ::SOLCLIENT_IN_PROGRESS\n\n A successful call has a return code of ::SOLCLIENT_OK, except when using ::SOLCLIENT_SUBSCRIBE_FLAGS_REQUEST_CONFIRM without\n ::SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM, then the return code is ::SOLCLIENT_IN_PROGRESS because the call returns without\n waiting for the operation to complete.\n @subcodes\n @li ::SOLCLIENT_SUBCODE_INVALID_TOPIC_SYNTAX\n @li ::SOLCLIENT_SUBCODE_SESSION_NOT_ESTABLISHED - An attempt was made to operate on a non-established Session.\n @li ::SOLCLIENT_SUBCODE_TIMEOUT - Timed-out trying to write unsubscribe request to socket,\n     waiting for Session to be established, waiting for internal resources.\n      This subcode only occurs for blocking subscription operations (refer to ::SOLCLIENT_SESSION_PROP_SUBSCRIBE_BLOCKING);\n     or the operation timed-out waiting for a confirmation (only when using ::SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM).\n @li ::SOLCLIENT_SUBCODE_COMMUNICATION_ERROR - The underlying connection failed.\n @li ::SOLCLIENT_SUBCODE_PARAM_CONFLICT - If subscribe flags ::SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM or ::SOLCLIENT_SUBSCRIBE_FLAGS_REQUEST_CONFIRM\n     are used with ::SOLCLIENT_SUBSCRIBE_FLAGS_LOCAL_DISPATCH_ONLY.\n\n The following subcodes can occur when using ::SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM. Otherwise, such errors are reported\n when a ::SOLCLIENT_SESSION_EVENT_SUBSCRIPTION_ERROR Session event is received.\n @li ::SOLCLIENT_SUBCODE_SUBSCRIPTION_NOT_FOUND (see ::SOLCLIENT_SESSION_PROP_IGNORE_DUP_SUBSCRIPTION_ERROR)\n @li ::SOLCLIENT_SUBCODE_SUBSCRIPTION_OTHER\n @li ::SOLCLIENT_SUBCODE_INVALID_SESSION_OPERATION\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_topicUnsubscribeWithDispatch(
        opaqueSession_p: solClient_opaqueSession_pt,
        flags: solClient_subscribeFlags_t,
        topicSubscription_p: *const ::std::os::raw::c_char,
        funcInfo_p: *mut solClient_session_rxMsgDispatchFuncInfo_t,
        correlationTag: *mut ::std::os::raw::c_void,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Check a Topic string against Topic encoding rules for the broker. This\n routine is intended for use with solClient_session_sendMsg, and the Topic\n set in the \\link ::solClient_opaqueMsg_pt opaque message pointer\\endlink. This\n function should not be used with \\link ::solClient_session_topicSubscribe\n solClient_session_topicSubscribe.\\endlink  solClient_session_topicSubscribe\n does its\n own Topic validation, which includes accepting wildcards. For performance\n reasons, solClient_session_sendMsg does not validate topics, and this function\n is provided as a convenience to developers to ensure a Topic is valid\n before sending a message that could be rejected by the broker. It is\n expected then, that the same Topic be used for sending many messages.\n\n @param opaqueSession_p The opaque Session returned when Session was created.\n @param topicString_p The Topic string (a NULL-terminated UTF-8 string).\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @li ::SOLCLIENT_SUBCODE_INVALID_TOPIC_SYNTAX\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_validateTopic(
        opaqueSession_p: solClient_opaqueSession_pt,
        topicString_p: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Sends a Topic Endpoint unsubscribe command to the broker. This is\n only valid if no subscribers are bound to the Topic Endpoint.\n The application can specify a correlation tag to match up responses. The\n correlation tag is a void pointer with no significance to the API. When the broker responds to the\n unsubscribe command, the correlation tag is returned in the eventInfo structure of the callback event.\n If this command succeeds there is a later event callback of either\n ::SOLCLIENT_SESSION_EVENT_TE_UNSUBSCRIBE_OK or\n ::SOLCLIENT_SESSION_EVENT_TE_UNSUBSCRIBE_ERROR.\n\n\n @param opaqueSession_p An opaque Session pointer returned when Session was created.\n @param teName_p       A string containing the Topic Endpoint name.\n @param correlationTag  Correlation tag returned in the resulting Session event.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_NOT_READY, or ::SOLCLIENT_FAIL\n @subcodes\n @li ::SOLCLIENT_SUBCODE_SESSION_NOT_ESTABLISHED - Attempted to operate on a non-established Session.\n @li ::SOLCLIENT_SUBCODE_TIMEOUT - Timed-out trying to write a subscribe request to socket,\n     waiting for a Session to be established, or waiting for internal resources\n     (only for blocking subscription operations; refer to ::SOLCLIENT_SESSION_PROP_SUBSCRIBE_BLOCKING);\n     or timed-out waiting for a confirm (only when using ::SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM).\n @li ::SOLCLIENT_SUBCODE_COMMUNICATION_ERROR - The underlying connection failed.\n @li ::SOLCLIENT_SUBCODE_INVALID_SESSION_OPERATION - The Session does not support Guaranteed messaging.\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_dteUnsubscribe(
        opaqueSession_p: solClient_opaqueSession_pt,
        teName_p: *const ::std::os::raw::c_char,
        correlationTag: *mut ::std::os::raw::c_void,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Returns an array of Session receive statistics.\n If the array is smaller than the number of defined receive statistics, only the first N\n defined statistics are returned.\n If the array is larger than the number of defined receive statistics, only the defined\n entries are filled in. The other entries are not touched.\n @param opaqueSession_p An opaque Session returned when the Session was created.\n @param rxStats_p       A pointer to an array of statistic values of type solClient_stats_t.\n @param arraySize       The number of entries in the passed in array (not the number of bytes).\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_getRxStats(
        opaqueSession_p: solClient_opaqueSession_pt,
        rxStats_p: solClient_stats_pt,
        arraySize: solClient_uint32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Returns an individual receive statistic.\n If multiple receive statistics are needed, it is more efficient to use\n solClient_session_getRxStats rather than to call this routine multiple times for\n different statistics.\n @param opaqueSession_p The opaque Session returned when the Session was created.\n @param rxStatType      The type of receive statistic to return.\n @param rxStat_p        A pointer to a variable to hold the returned statistic.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @see solClient_session_getRxStats()\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_getRxStat(
        opaqueSession_p: solClient_opaqueSession_pt,
        rxStatType: solClient_stats_rx_t,
        rxStat_p: solClient_stats_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Returns an array of Session transmit statistics.\n If the array is smaller than the number of defined transmit statistics, only the first N\n defined statistics are returned.\n If the array is larger than the number of defined transmit statistics, only the defined\n entries are filled in. The other entries are not touched.\n @param opaqueSession_p The opaque Session returned when the Session was created.\n @param txStats_p       A pointer to an array of statistic values of type solClient_Stats_t.\n @param arraySize       The number of entries in the array passed in (NOT the number of bytes).\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_getTxStats(
        opaqueSession_p: solClient_opaqueSession_pt,
        txStats_p: solClient_stats_pt,
        arraySize: solClient_uint32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Returns an individual transmit statistic.\n If multiple transmit statistics are needed, it is more efficient to use\n solClient_session_getTxStats rather than to call this routine multiple times for\n different statistics.\n @param opaqueSession_p An opaque Session returned when Session was created.\n @param txStatType      The type of transmit statistic to return.\n @param txStat_p        A pointer to a variable to hold the returned statistic.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @see solClient_session_getTxStats()\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_getTxStat(
        opaqueSession_p: solClient_opaqueSession_pt,
        txStatType: solClient_stats_tx_t,
        txStat_p: solClient_stats_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Clears all of the receive and transmit statistics for the specified Session. All previous\n Session statistics are lost when this is called.\n @param opaqueSession_p The opaque Session returned when Session was created.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_clearStats(
        opaqueSession_p: solClient_opaqueSession_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Outputs a log at the specified log level at this moment containing the value of all\n receive and transmit statistics for the specified Session. This routine is useful for\n application debugging because it allows an application to easily output all available\n Session statistics.\n @param opaqueSession_p The opaque Session returned when the Session was created.\n @param level The log level used to output the statistics log.\n @return ::SOLCLIENT_OK or ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_logStats(
        opaqueSession_p: solClient_opaqueSession_pt,
        level: solClient_log_level_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Create a temporary Topic string. This string may be passed as the Topic to\n ::solClient_session_createFlow() when connecting with a non-durable Topic\n Endpoint. It may also be used in a ::solClient_destination_t that is sent\n to a peer application in the ReplyTo field of the Solace Header map or in a\n structured data field.\n\n @param opaqueSession_p The opaque Session returned when the Session was created.\n @param topic_p         A pointer to a string location where the string is returned.\n @param length          The maximum string length to return.\n @return ::SOLCLIENT_OK or ::SOLCLIENT_FAIL\n @subcodes\n @li ::SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE - The generated Topic would be longer than the\n available length.\n @li ::SOLCLIENT_SUBCODE_SESSION_NOT_ESTABLISHED - The Session must be established before\n temporary Topic strings can be generated.\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_createTemporaryTopicName(
        opaqueSession_p: solClient_opaqueSession_pt,
        topic_p: *mut ::std::os::raw::c_char,
        length: usize,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Outputs a log at the specified log level at this moment containing the Flow state information\n for all Flows at this moment. It also dumps a summary of the number of active\n Flows, as well as the allocated but unbound Flows.\n @param opaqueSession_p The opaque Session returned when Session was created.\n @param level The log level used to output the statistics log.\n @return ::SOLCLIENT_OK or ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_logFlowInfo(
        opaqueSession_p: solClient_opaqueSession_pt,
        level: solClient_log_level_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Send a Topic Request message. The application expects an end-to-end reply\n from the client that receives the message.\n\n If the Reply-To destination in the Solace header map is not set, it is set to the default Session\n replyTo destination. Leaving the replyTo destination unset and allowing the API to\n set the default replyTo destination is the easiest way to set a valid replyTo destination.\n\n When the application needs to do a non-blocking request (that is, the timeout parameter is zero), the application\n may set any replyTo topic destination.\n\n When the application needs to do a blocking request (that is, the timeout parameter is non-zero),\n the replyTo destination must be a topic that the application has subscribed to for Direct messages.\n If the replyTo destination is set to an unsubscribed topic, a call to solClient_session_sendRequest()\n will block until the amount of time set for the timeout parameter expires and then return\n ::SOLCLIENT_INCOMPLETE with subcode ::SOLCLIENT_SUBCODE_TIMEOUT.\n\n If the timeout parameter is zero, this function returns immediately with ::SOLCLIENT_IN_PROGRESS upon\n successful buffering of the message for transmission. Any response generated by the destination client\n is delivered to the replyTo destination as a receive message callback with the response attribute set -\n solClient_msg_isReplyMsg() returns true. It is entirely within the responsibility of the\n application to manage asynchronous responses.\n\n When the timeout parameter is non-zero, this function waits for the amount of time specified by the timeout parameter for a\n response before returning ::SOLCLIENT_INCOMPLETE, otherwise this function returns ::SOLCLIENT_OK.\n If replyMsg_p is non-NULL, this functions returns an opaque message pointer (::solClient_opaqueMsg_pt) in the location\n referenced by replyMsg_p. This message is allocated by the API and contains the received reply. This function allocates\n the message on behalf of the application and the application <b>must</b> later release the message by calling\n solClient_msg_free(replyMsg_p).\n\n If this function does not return ::SOLCLIENT_OK, and replyMsg_p is non-NULL, then the location referenced by\n replyMsg_p is set to NULL.\n\n @param opaqueSession_p The opaque Session pointer that is returned when the Session was\n                        created.\n @param msg_p          A pointer to a solClient_msgBuffer that contains the\n                       message to be sent.\n @param replyMsg_p     A reference to a solClient_msgBuffer pointer that will\n                       receive the reply message pointer. If NULL, then\n                       only status is returned. If non-NULL the application must\n                       call solClient_msg_free() for the replyMsg when it is\n                       no longer needed.\n @param timeout        The maximum time (in milliseconds) to wait for reply.\n                       If timeout is set to zero then the function will return\n                       immediately ::SOLCLIENT_IN_PROGRESS after buffering of\n                       the message for transmission.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_IN_PROGRESS, ::SOLCLIENT_NOT_READY, ::SOLCLIENT_FAIL, ::SOLCLIENT_WOULD_BLOCK,\n         ::SOLCLIENT_INCOMPLETE\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_sendRequest(
        opaqueSession_p: solClient_opaqueSession_pt,
        msg_p: solClient_opaqueMsg_pt,
        replyMsg_p: *mut solClient_opaqueMsg_pt,
        timeout: solClient_uint32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Send a Reply Message. This function constructs a Solace binary\n message header based on the received message and sends a reply to\n the correct destination. If rxmsg_p is NULL, the application is responsible for setting\n a destination and correlationId string in the replyMsg. Otherwise the following fields\n from the rxmsg are used in the replyMsg:\n\n @li ReplyTo If replyMsg has no destination, the rxmsg ReplyTo destination is used.\n @li CorrelationId If replyMsg has no correlationId string, the rxmsg correlationId is copied.\n\n If replyMsg is null, the API creates a replyMsg that contains only correlationId string.\n\n @param opaqueSession_p The opaque Session pointer returned when the Session was\n                        created.\n @param rxmsg_p        A pointer to a solClient_msgBuffer that contains the\n                       message to reply to. (optional)\n @param replyMsg_p     A pointer to a solClient_msgBuffer that contains the\n                       message to be sent. (optional)\n @returns ::SOLCLIENT_OK, ::SOLCLIENT_NOT_READY, ::SOLCLIENT_FAIL\n @subcodes\n @li ::SOLCLIENT_SUBCODE_MISSING_REPLY_TO - the rxmsg_p (if not NULL) does not have a reply-to and so a reply cannot be sent.\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_sendReply(
        opaqueSession_p: solClient_opaqueSession_pt,
        rxmsg_p: solClient_opaqueMsg_pt,
        replyMsg_p: solClient_opaqueMsg_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Returns a string representation of the Session event passed in.\n @param sessionEvent The Session event to convert to a string representation.\n @return A pointer to a constant character string. This pointer is never NULL."]
    pub fn solClient_session_eventToString(
        sessionEvent: solClient_session_event_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Provision, on the broker, a durable Queue or Topic Endpoint using the specified Session.\n ::SOLCLIENT_ENDPOINT_PROP_ID must be set to either ::SOLCLIENT_ENDPOINT_PROP_QUEUE or ::SOLCLIENT_ENDPOINT_PROP_TE\n in this interface. Only durable (::SOLCLIENT_ENDPOINT_PROP_DURABLE is enabled) endpoints may be provisioned. A non-durable\n endpoint is created when a Flow is bound to it with solClient_session_createFlow().\n\n Endpoint creation can be carried out in a blocking or non-blocking mode, depending upon the \\ref provisionflags \"provisionFlags\".\n If SOLCLIENT_PROVISION_FLAGS_WAITFORCONFIRM is set in provisionFlags,\n the calling thread is blocked until the endpoint creation attempt either\n succeeds or is determined to have failed. If the endpoint is created, ::SOLCLIENT_OK is\n returned.\n When SOLCLIENT_PROVISION_FLAGS_WAITFORCONFIRM is not set, ::SOLCLIENT_IN_PROGRESS is returned when the endpoint\n provision request is successfully sent, and the creation attempt proceeds in the background.\n An endpoint creation timer, controlled by the property\n ::SOLCLIENT_SESSION_PROP_PROVISION_TIMEOUT_MS, controls the maximum amount of\n time a creation attempt lasts for. Upon expiry of this time,\n a ::SOLCLIENT_SESSION_EVENT_PROVISION_ERROR event is issued for the Session.\n If there is an error when solClient_session_endpointProvision() is invoked, then ::SOLCLIENT_FAIL\n is returned, and a provision event will not be subsequently issued. Thus, the caller must\n check for a return code of ::SOLCLIENT_FAIL if it has logic that depends upon a subsequent\n provision event to be issued.\n For a non-blocking endpoint provision, if the creation attempt eventually\n fails, the error information that indicates the reason for the failure cannot be\n determined by the calling thread, rather it must be discovered through the Session event\n callback (and solClient_getLastErrorInfo() can be called in the Session event callback\n to get further information).\n For a blocking endpoint creation invocation, if the creation attempt does not\n return ::SOLCLIENT_OK, then the calling thread can determine the failure reason by immediately\n calling solClient_getLastErrorInfo. For a blocking endpoint creation, ::SOLCLIENT_NOT_READY is returned\n if the create failed due to the timeout expiring (see ::SOLCLIENT_SESSION_PROP_PROVISION_TIMEOUT_MS).\n\n @param props           The provision \\ref endpointProps \"properties\" used to define the endpoint.\n @param opaqueSession_p The Session which is used to create the endpoint.\n @param provisionFlags  \\ref provisionflags \"Flags\" to control provision operation.\n @param correlationTag  A correlation tag returned in the resulting Session event.\n @param queueNetworkName    This parameter is deprecated but still supported for backwards compatibility.\n                         It is recommended to pass NULL for this parameter.  When a non-null pointer is passed,\n                         it is used as a pointer to the location in which the network name of the created Queue\n                         Network Name is returned. This can be used to set the destination for published\n                         messages. An empty string is returned when the created endpoint is a Topic Endpoint.\n                         For publishing to a queue, the current recommended practice is to use\n                         solClient_destination_t where the destType is set to SOLCLIENT_QUEUE_DESTINATION and\n                         dest is set to the queue name.\n @param qnnSize          As with queueNetworkName, this is a deprecated parameter.  When passing NULL as the\n                         queueNetworkName, pass 0 as qnnSize.  When queueNetworkName is not null, qnnSize is the\n                         maximum length of the Queue Network Name string that can be returned.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL, ::SOLCLIENT_NOT_READY, ::SOLCLIENT_IN_PROGRESS, ::SOLCLIENT_WOULD_BLOCK\n @subcodes\n @li ::SOLCLIENT_SUBCODE_TIMEOUT - The operation timed out trying to provision (only for blocking provision operations; refer to ::SOLCLIENT_PROVISION_FLAGS_WAITFORCONFIRM).\n @li ::SOLCLIENT_SUBCODE_COMMUNICATION_ERROR - The underlying connection failed.\n @li ::SOLCLIENT_SUBCODE_INVALID_TOPIC_NAME_FOR_TE\n @li ::SOLCLIENT_SUBCODE_ENDPOINT_ALREADY_EXISTS\n @li ::SOLCLIENT_SUBCODE_ENDPOINT_PROPERTY_MISMATCH\n @li ::SOLCLIENT_SUBCODE_NO_MORE_NON_DURABLE_QUEUE_OR_TE\n @li ::SOLCLIENT_SUBCODE_PERMISSION_NOT_ALLOWED\n @li ::SOLCLIENT_SUBCODE_QUOTA_OUT_OF_RANGE\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_endpointProvision(
        props: solClient_propertyArray_pt,
        opaqueSession_p: solClient_opaqueSession_pt,
        provisionFlags: solClient_uint32_t,
        correlationTag: *mut ::std::os::raw::c_void,
        queueNetworkName: *mut ::std::os::raw::c_char,
        qnnSize: usize,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Remove an endpoint from the broker. An application can only remove an endpoint that has previously\n been provisioned with solClient_session_provistionEndpoint(). The broker will reject with an error any\n attempt to remove a temporary endpoint (provisioned by solClient_session_createFlow()), or a permanent endpoint\n provisioned by the administrator through the CLI or solAdmin.\n\n @param props           The provision properties used to identify the endpoint.\n @param opaqueSession_p The Session which is used to delete the endpoint.\n @param provisionFlags  \\ref provisionflags \"Flags\" to control delete operation.\n @param correlationTag  The correlation tag returned in the resulting Session event.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL, ::SOLCLIENT_NOT_READY, ::SOLCLIENT_IN_PROGRESS, ::SOLCLIENT_WOULD_BLOCK\n @subcodes\n @li ::SOLCLIENT_SUBCODE_TIMEOUT - The operation timed out trying to provision (only for blocking provision operations; refer to ::SOLCLIENT_PROVISION_FLAGS_WAITFORCONFIRM).\n @li ::SOLCLIENT_SUBCODE_COMMUNICATION_ERROR - The underlying connection failed.\n @li ::SOLCLIENT_SUBCODE_UNKNOWN_QUEUE_NAME\n @li ::SOLCLIENT_SUBCODE_UNKNOWN_TE_NAME\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_endpointDeprovision(
        props: solClient_propertyArray_pt,
        opaqueSession_p: solClient_opaqueSession_pt,
        provisionFlags: solClient_uint32_t,
        correlationTag: *mut ::std::os::raw::c_void,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Add a Topic subscription to the endpoint defined by the endpoint properties if the operation is supported\n on the endpoint. Topic subscriptionscan be added to Queue endpoints (::SOLCLIENT_ENDPOINT_PROP_QUEUE) and\n to the special endpoint for each Session on brokers running SolOS-TR (::SOLCLIENT_ENDPOINT_PROP_CLIENT_NAME).\n\n <b>Adding subscriptions to Queues</b>\n\n Guaranteed messages are published to a Queue when it is set as the destination of the message. However,\n you can also add one or more Topic subscriptions to a durable or temporary Queue so that\n Guaranteed messages published to those topics are also delivered to the Queue.\n @li Only a Queue (::SOLCLIENT_ENDPOINT_PROP_QUEUE) Endpoint can be used.\n @li Only a Topic subscription can be used.\n @li Must have modify-topic permission on the Endpoint.\n\n <b>Adding subscriptions to remote clients</b>\n\n A subscription manager client can add subscriptions on behalf of other clients. These Topic\n subscriptions are not retained in the subscription cache and are not be reapplied upon reconnection.\n @li Only supported in SolOS-TR mode.\n @li Only a ClientName (::SOLCLIENT_ENDPOINT_PROP_CLIENT_NAME) Endpoint can be used.\n @li Only a Topic subscription can be used.\n @li Must have subscription-manager permissions on the client username.\n\n It is an error to add subscriptions to a Topic Endpoint (::SOLCLIENT_ENDPOINT_PROP_TE)  with this interface.\n A subscription can only be added to a Topic Endpoint when a Flow is bound to it. The subscription is part of the Flow properties.\n\n @param endpointProps   The \\ref endpointProps \"provision properties\" used to identify the endpoint.\n @param opaqueSession_p The Session which is used to perform the subscription request. If the Session also supports\n                        ::SOLCLIENT_SESSION_PROP_REAPPLY_SUBSCRIPTIONS, then the subscriptions are be remembered\n                        and automatically reapplied should the Session fail and reconnect automatically.\n @param flags           \\ref subscribeflags \"Flags\" to control the operation. Valid flags for this operation are:\n @li ::SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM\n @li ::SOLCLIENT_SUBSCRIBE_FLAGS_REQUEST_CONFIRM\n @param topicSubscription_p Topic Subscription to apply as a NULL-terminated UTF-8 string.\n @param correlationTag  Correlation tag returned in the resulting Session event.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL, ::SOLCLIENT_NOT_READY, ::SOLCLIENT_IN_PROGRESS\n @subcodes\n @li ::SOLCLIENT_SUBCODE_TIMEOUT - The operation timed out trying to provision (only for blocking provision operations; refer to ::SOLCLIENT_PROVISION_FLAGS_WAITFORCONFIRM).\n @li ::SOLCLIENT_SUBCODE_COMMUNICATION_ERROR - The underlying connection failed.\n @li ::SOLCLIENT_SUBCODE_UNKNOWN_QUEUE_NAME\n @li ::SOLCLIENT_SUBCODE_UNKNOWN_CLIENT_NAME\n @li ::SOLCLIENT_SUBCODE_SUBSCRIPTION_ACL_DENIED\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_endpointTopicSubscribe(
        endpointProps: solClient_propertyArray_pt,
        opaqueSession_p: solClient_opaqueSession_pt,
        flags: solClient_subscribeFlags_t,
        topicSubscription_p: *const ::std::os::raw::c_char,
        correlationTag: *mut ::std::os::raw::c_void,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Remove a Topic subscription from the endpoint defined by the endpoint properties if the operation is supported\n on the endpoint. Used to remove subscriptions added by solClient_session_endpointTopicSubscribe() .\n Refer to that function's documentation for operational parameters. This method cannot remove subscriptions added through the CLI.\n\n @param endpointProps   The \\ref endpointProps \"provision properties\" used to identify the endpoint.\n @param opaqueSession_p The Session which is used to perform the remove subscription request.\n @param flags           \\ref subscribeflags \"Flags\" to control the operation. Valid flags for this operation are:\n @li ::SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM\n @li ::SOLCLIENT_SUBSCRIBE_FLAGS_REQUEST_CONFIRM\n @param topicSubscription_p Topic Subscription to remove as a NULL-terminated UTF-8 string.\n @param correlationTag  Correlation tag returned in the resulting Session event.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL, ::SOLCLIENT_NOT_READY, ::SOLCLIENT_IN_PROGRESS\n @subcodes\n @li ::SOLCLIENT_SUBCODE_TIMEOUT - The operation timed out trying to provision (only for blocking provision operations; refer to ::SOLCLIENT_PROVISION_FLAGS_WAITFORCONFIRM).\n @li ::SOLCLIENT_SUBCODE_COMMUNICATION_ERROR - The underlying connection failed.\n @li ::SOLCLIENT_SUBCODE_UNKNOWN_QUEUE_NAME\n @li ::SOLCLIENT_SUBCODE_UNKNOWN_CLIENT_NAME\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_endpointTopicUnsubscribe(
        endpointProps: solClient_propertyArray_pt,
        opaqueSession_p: solClient_opaqueSession_pt,
        flags: solClient_subscribeFlags_t,
        topicSubscription_p: *const ::std::os::raw::c_char,
        correlationTag: *mut ::std::os::raw::c_void,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Creates a new Flow within a specified Session. Flow characteristics and behavior are defined by Flow properties. The Flow properties\n are supplied as an array of name/value pointer pairs, where the name and value are both strings.\n \\ref flowProps \"FLOW\" and \\ref endpointProps \"ENDPOINT\" configuration property names are processed; other property names\n are ignored. If the Flow creation specifies a non-durable endpoint, ENDPOINT properties can be used to change the default\n properties on the non-durable endpoint. Any values not supplied are set to default values.\n\n When the Flow is created, an opaque Flow pointer is returned to the caller, and this value is then used for any\n Flow-level operations (for example, starting/stopping a Flow, getting statistics, sending an acknowledgment).\n The passed-in structure functInfo_p provides information on the message receive callback\n function and the Flow event function which the application has provided for this Flow.\n Both of these callbacks are mandatory. The message receive callback is invoked for each\n received message on this Flow. The Flow event callback is invoked when Flow events\n occur, such as the Flow going up or down. Both callbacks are invoked in the context\n of the Context thread to which the controlling Session belongs.\n\n Flow creation can be carried out in a blocking or\n non-blocking mode, depending upon the Flow property\n ::SOLCLIENT_FLOW_PROP_BIND_BLOCKING.\n In blocking mode, the calling thread is blocked until the Flow connection attempt either\n succeeds or is determined to have failed. If the connection succeeds, ::SOLCLIENT_OK is\n returned, and if the Flow could not be connected, ::SOLCLIENT_NOT_READY is returned.\n In non-blocking mode, ::SOLCLIENT_IN_PROGRESS is returned upon a successful Flow create\n request, and the connection attempt proceeds in the background.\n In both a non-blocking and blocking mode, a Flow event is generated for the Session:\n ::SOLCLIENT_FLOW_EVENT_UP_NOTICE, if the Flow was connected successfully; or\n ::SOLCLIENT_FLOW_EVENT_BIND_FAILED_ERROR, if the Flow failed to connect.\n For blocking mode, the Flow event is issued before the call to\n solClient_session_createFlow() returns. For non-blocking mode, the timing is undefined (that is,\n it could occur before or after the call returns, but it will typically be after).\n A Flow connection timer, controlled by the Flow property\n ::SOLCLIENT_FLOW_PROP_BIND_TIMEOUT_MS, controls the maximum amount of\n time a Flow connect attempt lasts for. Upon expiry of this time,\n a ::SOLCLIENT_FLOW_EVENT_BIND_FAILED_ERROR event is issued for the Session.\n If there is an error when solClient_session_createFlow() is invoked, then ::SOLCLIENT_FAIL\n is returned, and a Flow event is not subsequently issued. Thus, the caller must\n check for a return code of ::SOLCLIENT_FAIL if it has logic that depends upon a subsequent\n Flow event to be issued.\n For a non-blocking Flow create invocation, if the Flow create attempt eventually\n fails, the error information that indicates the reason for the failure cannot be\n determined by the calling thread. It must be discovered through the Flow event\n callback (and solClient_getLastErrorInfo can be called in the Flow event callback\n to get further information).\n For a blocking Flow create invocation, if the Flow create attempt does not\n return ::SOLCLIENT_OK, then the calling thread can determine the failure reason by immediately\n calling solClient_getLastErrorInfo. For a blocking Flow creation, ::SOLCLIENT_NOT_READY is returned\n if the created failed due to the bind timeout expiring (see ::SOLCLIENT_FLOW_PROP_BIND_TIMEOUT_MS).\n Note that the property values are stored internally in the API and the caller does not have to maintain\n the props array or the strings that are pointed to after this call completes. The API does not modify any of\n the strings pointed to by props when processing the property list.\n\n If the flow property SOLCLIENT_FLOW_PROP_BIND_ENTITY_ID is set to ::SOLCLIENT_FLOW_PROP_BIND_ENTITY_TE,\n the flow Topic property ::SOLCLIENT_FLOW_PROP_TOPIC <b>must</b> be set, which will replace any existing\n topic on the topic-endpoint.\n\n <b>WARNING:</b> By default the ::SOLCLIENT_FLOW_PROP_ACKMODE is set to ::SOLCLIENT_FLOW_PROP_ACKMODE_AUTO,\n which automatically acknowledges all received messages. Function ::solClient_flow_sendAck returns SOLCLIENT_OK\n in the mode ::SOLCLIENT_FLOW_PROP_ACKMODE_AUTO, but with a warning that solClient_flow_sendAck\n is ignored as flow is in auto-ack mode.\n\n \\n\n\n @param props           An array of name/value string pair pointers to configure Flow properties.\n @param opaqueSession_p The Session in which the Flow is to be created.\n @param opaqueFlow_p    The returned opaque Flow pointer that refers to the created Flow.\n @param funcInfo_p      A pointer to a structure that provides information on callback functions for events and received messages.\n @param funcInfoSize    The size of the passed-in funcInfo structure (in bytes) to allow the structure to grow in the future.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL, ::SOLCLIENT_NOT_READY, ::SOLCLIENT_IN_PROGRESS\n @subcodes\n @li ::SOLCLIENT_SUBCODE_TIMEOUT - The operation timed out trying to create a Flow (only for blocking Flow create operations; refer to ::SOLCLIENT_FLOW_PROP_BIND_BLOCKING).\n @li ::SOLCLIENT_SUBCODE_COMMUNICATION_ERROR - The underlying connection failed.\n @li ::SOLCLIENT_SUBCODE_OUT_OF_RESOURCES - The API was unable to allocate the memory necessary to create the Flow.\n @li ::SOLCLIENT_SUBCODE_INVALID_SESSION_OPERATION - The Session does not support flow creation.\n @li ::SOLCLIENT_SUBCODE_INVALID_TOPIC_NAME_FOR_TE\n @li ::SOLCLIENT_SUBCODE_UNKNOWN_QUEUE_NAME\n @li ::SOLCLIENT_SUBCODE_UNKNOWN_TE_NAME\n @li ::SOLCLIENT_SUBCODE_MAX_CLIENTS_FOR_QUEUE\n @li ::SOLCLIENT_SUBCODE_MAX_CLIENTS_FOR_TE\n @li ::SOLCLIENT_SUBCODE_QUEUE_NOT_FOUND\n @li ::SOLCLIENT_SUBCODE_QUEUE_SHUTDOWN\n @li ::SOLCLIENT_SUBCODE_TE_SHUTDOWN\n @li ::SOLCLIENT_SUBCODE_NO_MORE_NON_DURABLE_QUEUE_OR_TE\n @li ::SOLCLIENT_SUBCODE_SUBSCRIPTION_ACL_DENIED\n @li ::SOLCLIENT_SUBCODE_REPLAY_NOT_SUPPORTED\n @li ::SOLCLIENT_SUBCODE_REPLAY_DISABLED\n @li ::SOLCLIENT_SUBCODE_CLIENT_INITIATED_REPLAY_NON_EXCLUSIVE_NOT_ALLOWED\n @li ::SOLCLIENT_SUBCODE_CLIENT_INITIATED_REPLAY_INACTIVE_FLOW_NOT_ALLOWED\n @li ::SOLCLIENT_SUBCODE_CLIENT_INITIATED_REPLAY_BROWSER_FLOW_NOT_ALLOWED\n @li ::SOLCLIENT_SUBCODE_REPLAY_TEMPORARY_NOT_SUPPORTED\n @li ::SOLCLIENT_SUBCODE_UNKNOWN_START_LOCATION_TYPE\n @li ::SOLCLIENT_SUBCODE_REPLAY_START_TIME_NOT_AVAILABLE\n @li ::SOLCLIENT_SUBCODE_REPLAY_START_MESSAGE_UNAVAILABLE\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_session_createFlow(
        props: solClient_propertyArray_pt,
        opaqueSession_p: solClient_opaqueSession_pt,
        opaqueFlow_p: *mut solClient_opaqueFlow_pt,
        funcInfo_p: *mut solClient_flow_createFuncInfo_t,
        funcInfoSize: usize,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Destroys a previously created Flow. Upon return, the opaque Flow pointer\n is set to NULL.\n This operation <b>must not</b> be performed in a Flow callback\n for the Flow being destroyed.\n\n @param opaqueFlow_p A pointer to the opaque Flow pointer that was returned when\n the Session was created.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @li ::SOLCLIENT_SUBCODE_TIMEOUT - The operation timed-out trying to destroy the Flow.\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_flow_destroy(
        opaqueFlow_p: *mut solClient_opaqueFlow_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Returns the Session associated with the specified Flow. When flows are created\n within a Session (see ::solClient_session_createFlow), then this routine can be used\n if the application has a Flow pointer and needs to determine the associated\n Session. For example, in a Flow event callback in which a Flow pointer is\n provided, an application can use this routine to determine the associated Session. Note that from the Session the associated Context\n can be determined through  ::solClient_session_getContext.\n @param opaqueFlow_p An opaque Flow that was returned when the Flow was created.\n @param opaqueSession_p An opaque Session associated with the Flow that is returned.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_flow_getSession(
        opaqueFlow_p: solClient_opaqueFlow_pt,
        opaqueSession_p: *mut solClient_opaqueSession_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Sends an acknowledgment on the specified Flow. This instructs the API to consider\n the specified msgID acknowledged at the application layer. The library\n does not send acknowledgments immediately. It stores the state for\n acknowledged messages internally and acknowledges messages, in bulk, when a\n threshold or timer is reached.\n\n Applications <b>must</b> only acknowledge a message on the Flow on which\n it is received. Using the <i>msgId</i> received on one Flow when acknowledging\n on another may result in no message being removed from the message-spool or the wrong\n message being removed from the message-spool.\n\n The exact behavior of solClient_flow_sendAck() is controlled by Flow property\n ::SOLCLIENT_FLOW_PROP_ACKMODE:\n @li SOLCLIENT_FLOW_PROP_ACKMODE_AUTO - messages are acknowledged automatically by C API\n and calling this function has no effect.\n @li SOLCLIENT_FLOW_PROP_ACKMODE_CLIENT - every message received must be acknowledged by the\n application through individual calls to solClient_flow_sendAck().\n\n <b>WARNING:</b> If ::SOLCLIENT_FLOW_PROP_ACKMODE is set to ::SOLCLIENT_FLOW_PROP_ACKMODE_AUTO\n (the default behavior), the function returns ::SOLCLIENT_OK, but with a warning that\n solClient_flow_sendAck is ignored as the flow is in auto-ack mode.\n\n @param opaqueFlow_p    The opaque Flow that is returned when the Flow was created.\n @param msgId           The 64-bit messageId for the acknowledged message.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_flow_sendAck(
        opaqueFlow_p: solClient_opaqueFlow_pt,
        msgId: solClient_msgId_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Closes the receiver on the specified Flow. This method will close the Flow\n window to the broker so further messages will not be received until\n solClient_flow_start() is called. Messages in transit when this method is\n called will still be delivered to the application. So the application must\n expect that the receive message callback can be called even after calling\n solClient_flow_stop(). The maximum number of messages that may be\n in transit at any one time is controlled by ::SOLCLIENT_FLOW_PROP_WINDOWSIZE\n and ::SOLCLIENT_FLOW_PROP_MAX_UNACKED_MESSAGES (see solClient_flow_setMaxUnacked()).\n\n A Flow can be created with the window closed by setting the Flow property ::SOLCLIENT_FLOW_PROP_START_STATE\n to ::SOLCLIENT_PROP_DISABLE_VAL. When a Flow is created in this way, messages will not be received\n on the Flow until after ::solClient_flow_start() is called.\n\n\n @param opaqueFlow_p    The opaque Flow returned when the Flow was created.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_flow_stop(opaqueFlow_p: solClient_opaqueFlow_pt) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Opens the receiver on the specified Flow. This method opens the Flow window\n to the broker so further messages can be received. For browser flows (::SOLCLIENT_FLOW_PROP_BROWSER), applications have to call the function to get more messages.\n\n A Flow may be created with the window closed by setting the Flow property ::SOLCLIENT_FLOW_PROP_START_STATE\n to ::SOLCLIENT_PROP_DISABLE_VAL. When a Flow is created in this way, messages will not be received\n on the Flow until after ::solClient_flow_start() is called.\n\n\n @param opaqueFlow_p    The opaque Flow returned when the Flow was created.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_flow_start(opaqueFlow_p: solClient_opaqueFlow_pt) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Changes the maximum number of unacknowledged messages that may be received\n on the specified Flow. This function may only be used when the Flow has been\n created with ::SOLCLIENT_FLOW_PROP_ACKMODE set to ::SOLCLIENT_FLOW_PROP_ACKMODE_CLIENT.\n When the maximum number of unacknowledged messages is reduced, messages in transit will still be received even if that causes\n the application to exceed the new limit of maximum number of unacknowledged messages.\n The maximum number of messages that may be in transit at any one time is the lesser of\n the current allowable unacknowledged messages and the Flow property ::SOLCLIENT_FLOW_PROP_WINDOWSIZE.\n The current allowable unacknowledged messages is simply the difference between the current\n (that is, before calling this function) maximum number of acknowledged messages and the number of messages\n received that have not been acknowledged.\n\n @param opaqueFlow_p    The opaque Flow returned when the Flow was created.\n @param maxUnacked      The new value for maximum number of acknowledged messages to allow\n                        on the Flow. If set to -1, there is no limit to the maximum number of\n                        acknowledged messages other than the broker defined limit in the endpoint.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @li ::SOLCLIENT_SUBCODE_INVALID_FLOW_OPERATION - Changing maximum unacknowledged messages is\n              only valid when the Flow acknowldgement mode (::SOLCLIENT_FLOW_PROP_ACKMODE) is set\n              to ::SOLCLIENT_FLOW_PROP_ACKMODE_CLIENT.\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_flow_setMaxUnacked(
        opaqueFlow_p: solClient_opaqueFlow_pt,
        maxUnacked: solClient_int32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Returns an array of Flow receive statistics.\n If the array is smaller than the number of defined receive statistics, only the first N\n defined statistics are returned.\n If the array is larger than the number of defined receive statistics, only the defined\n entries are filled in. The other entries are not touched.\n @param opaqueFlow_p The opaque Flow returned when the Flow was created.\n @param rxStats_p       A pointer to an array of statistic values of type solClient_Stats_t.\n @param arraySize       The number of entries in the array passed in (NOT the number of bytes).\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_flow_getRxStats(
        opaqueFlow_p: solClient_opaqueFlow_pt,
        rxStats_p: solClient_stats_pt,
        arraySize: solClient_uint32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Returns an individual receive statistic.\n If multiple receive statistics are needed, it is more efficient to use\n solClient_flow_getRxStats rather than to call this routine multiple times for\n different statistics.\n @param opaqueFlow_p The opaque Flow returned when Flow was created.\n @param rxStatType      The type of receive statistic to return.\n @param rxStat_p        A pointer to a variable to hold the returned statistic.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @see solClient_flow_getRxStats()\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_flow_getRxStat(
        opaqueFlow_p: solClient_opaqueFlow_pt,
        rxStatType: solClient_stats_rx_t,
        rxStat_p: solClient_stats_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Retrieve the destination for the Flow. The destination returned can\n be used to set the ReplyTo field in a message, or otherwise communicated\n to partners that need to send messages to this Flow. This is especially useful\n for temporary endpoints (Queues and Topic Endpoints), as the destination\n is unknown before the endpoint is created.\n @param opaqueFlow_p The opaque Flow returned when the Flow was created.\n @param dest_p       A pointer to a solClient_destination_t.\n @param destSize     The size of (solClient_destination_t). This parameter is used for backwards binary compatibility if solClient_destination_t changes in the future.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_flow_getDestination(
        opaqueFlow_p: solClient_opaqueFlow_pt,
        dest_p: *mut solClient_destination_t,
        destSize: usize,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Clears all the statistics (rx and tx) for the specified Flow. All previous\n Flow statistics are lost when this is called.\n @param opaqueFlow_p The opaque Flow returned when Flow was created.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_flow_clearStats(
        opaqueFlow_p: solClient_opaqueFlow_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Outputs a log at a specified log level that contains the value at this moment of all\n receive and transmit statistics for the specified Flow. This routine is useful for\n debugging of applications because it enables an application to easily output all available\n Flow statistics.\n @param opaqueFlow_p The opaque Flow returned when Flow was created.\n @param level The log level used to output the statistics log.\n @return ::SOLCLIENT_OK or ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_flow_logStats(
        opaqueFlow_p: solClient_opaqueFlow_pt,
        level: solClient_log_level_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Allows topics to be dispatched to different message receive callbacks and with different\n dispatchUser_p for received messages on an endpoint Flow. If the endpoint supports adding topics\n (Queue endpoints), then this function will also add the Topic subscription to the endpoint unless\n SOLCLIENT_SUBSCRIBE_FLAGS_LOCAL_DISPATCH_ONLY is set. SOLCLIENT_SUBSCRIBE_FLAGS_LOCAL_DISPATCH_ONLY is\n implied for all other endpoints.\n\n If the dispatch function info (funcinfo_p) is NULL, the Topic subscription is only added to the endpoint and\n no local dispatch entry is created. This operation is then identical to solClient_session_endpointTopicSubscribe().\n\n SOLCLIENT_SUBSCRIBE_FLAGS_LOCAL_DISPATCH_ONLY can only be set when funcinfo_p\n is not NULL. Consequently funcinfo_p may not be NULL for non-Queue endpoints.\n\n The Session property ::SOLCLIENT_SESSION_PROP_TOPIC_DISPATCH must be enabled for a non-NULL funcinfo_p\n to be specified.\n\n When funcinfo_p is not NULL, the received messages on the Topic Endpoint Flow are further demultiplexed based on the received\n topic.\n\n @see @ref subscription-syntax\n @see @ref topic-dispatch\n @see @ref flow-topic-dispatch\n\n @param opaqueFlow_p The opaque Flow that is returned when the Flow was created.\n @param flags \\ref subscribeflags \"Flags\" to control the operation. Valid flags for this operation are:\n @li ::SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM\n @li ::SOLCLIENT_SUBSCRIBE_FLAGS_REQUEST_CONFIRM\n @li ::SOLCLIENT_SUBSCRIBE_FLAGS_LOCAL_DISPATCH_ONLY\n @param topicSubscription_p The Topic subscription string (a NULL-terminated UTF-8 string).\n @param funcInfo_p         The message receive callback information. See structure solClient_flow_rxMsgDispatchFuncInfo.\n @param correlationTag     A correlationTag pointer that is returned in the confirm or fail sessionEvent for the\n                           subscription. This is only used if SOLCLIENT_SUBSCRIBE_FLAGS_REQUEST_CONFIRM is set and\n                           SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM is not set.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_NOT_READY, ::SOLCLIENT_FAIL, ::SOLCLIENT_WOULD_BLOCK, ::SOLCLIENT_IN_PROGRESS\n @subcodes\n @li ::SOLCLIENT_SUBCODE_INVALID_TOPIC_SYNTAX\n @li ::SOLCLIENT_SUBCODE_INVALID_SESSION_OPERATION - Topic dispatch is not enabled for the Session .\n @li ::SOLCLIENT_SUBCODE_INVALID_FLOW_OPERATION - Topic dispatch is not supported for the Transacted Flow.\n @see ::solClient_subCode for a description of all subcodes.\n\n A successful call has a return code of ::SOLCLIENT_OK except when using ::SOLCLIENT_SUBSCRIBE_FLAGS_REQUEST_CONFIRM without\n ::SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM. In that case, the return code will be ::SOLCLIENT_IN_PROGRESS because the call returns without\n waiting for the operation to complete."]
    pub fn solClient_flow_topicSubscribeWithDispatch(
        opaqueFlow_p: solClient_opaqueFlow_pt,
        flags: solClient_subscribeFlags_t,
        topicSubscription_p: *const ::std::os::raw::c_char,
        funcInfo_p: *mut solClient_flow_rxMsgDispatchFuncInfo_t,
        correlationTag: *mut ::std::os::raw::c_void,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Removes a topic dispatch from an endpoint Flow. When the Flow is connected to a Queue endpoint, this function also removes the Topic\n subscription from the Queue unless ::SOLCLIENT_SUBSCRIBE_FLAGS_LOCAL_DISPATCH_ONLY is set.\n\n @see @ref subscription-syntax\n @see @ref topic-dispatch\n @see @ref flow-topic-dispatch\n\n @param opaqueFlow_p The opaque Flow returned when the Flow was created.\n @param flags \\ref subscribeflags \"Flags\" to control the operation. Valid flags for this operation are:\n @li ::SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM\n @li ::SOLCLIENT_SUBSCRIBE_FLAGS_REQUEST_CONFIRM\n @li ::SOLCLIENT_SUBSCRIBE_FLAGS_LOCAL_DISPATCH_ONLY\n @param topicSubscription_p The Topic subscription string (a NULL-terminated UTF-8 string).\n @param funcInfo_p         The message receive callback information. See structure solClient_flow_rxMsgDispatchFuncInfo.\n @param correlationTag     A correlationTag pointer that is returned as is in the confirm or fail sessionEvent for the\n                           subscription. This is only used if SOLCLIENT_SUBSCRIBE_FLAGS_REQUEST_CONFIRM is set and\n                           SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM is not set.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_NOT_READY, ::SOLCLIENT_FAIL, ::SOLCLIENT_WOULD_BLOCK, ::SOLCLIENT_IN_PROGRESS\n @subcodes\n @li ::SOLCLIENT_SUBCODE_INVALID_TOPIC_SYNTAX\n @li ::SOLCLIENT_SUBCODE_INVALID_SESSION_OPERATION - Topic dispatch is not enabled for the Session\n @li ::SOLCLIENT_SUBCODE_INVALID_FLOW_OPERATION - Topic dispatch is not supported for the Transacted Flow.\n @see ::solClient_subCode for a description of all subcodes.\n\n A successful call has a return code of ::SOLCLIENT_OK except when using ::SOLCLIENT_SUBSCRIBE_FLAGS_REQUEST_CONFIRM without\n ::SOLCLIENT_SUBSCRIBE_FLAGS_WAITFORCONFIRM. In that case, the return code will be ::SOLCLIENT_IN_PROGRESS because the call returns without\n waiting for the operation to complete."]
    pub fn solClient_flow_topicUnsubscribeWithDispatch(
        opaqueFlow_p: solClient_opaqueFlow_pt,
        flags: solClient_subscribeFlags_t,
        topicSubscription_p: *const ::std::os::raw::c_char,
        funcInfo_p: *mut solClient_flow_rxMsgDispatchFuncInfo_t,
        correlationTag: *mut ::std::os::raw::c_void,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Gets the value of the specified Flow property for the Flow. The\n property value is copied out to buffer provided by the caller. The returned\n value is a NULL-terminated UTF-8 string.\n\n @param opaqueFlow_p    The opaque Flow returned when the Flow was created.\n @param propertyName_p  The name of the Flow property for which the value is to be returned.\n @param buf_p           A pointer to the buffer provided by the caller in which to place the NULL-terminated property value string.\n @param bufSize         The size of the buffer provided by the caller (in bytes).\n @returns               ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_flow_getProperty(
        opaqueFlow_p: solClient_opaqueFlow_pt,
        propertyName_p: *const ::std::os::raw::c_char,
        buf_p: *mut ::std::os::raw::c_char,
        bufSize: usize,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Outputs a log at the specified log level that contains the Flow state information\n for the given Flow.\n @param opaqueFlow_p The opaque Flow returned when Flow was created.\n @param level The log level used to output the statistics log.\n @return ::SOLCLIENT_OK or ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_flow_logFlowInfo(
        opaqueFlow_p: solClient_opaqueFlow_pt,
        level: solClient_log_level_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Returns a string representation of the Flow event passed in.\n @param flowEvent The Flow event to convert to a string representation.\n @return A pointer to a constant character string. This pointer is never NULL."]
    pub fn solClient_flow_eventToString(
        flowEvent: solClient_flow_event_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Creates a Transacted Session object that is used in subsequent transactions.\n It is recommended that a client application use a default Context-bound Message Dispatcher\n for its asynchronous message delivery within a Transacted Session.\n\n By enabling Transacted Session property ::SOLCLIENT_TRANSACTEDSESSION_PROP_CREATE_MESSAGE_DISPATCHER,\n a TransactedSession-bound Message Dispatcher is created as well when a Transacted Session\n is created. The lifecycle of a Message Dispatcher is bounded to the lifecycle of the\n corresponding API object.\n @see @ref transacted-session\n\n @param props     An array of name/value string pair pointers to configure Transacted Session  properties.\n @param session_p           Session in which a Transacted Session is to be created.\n @param transactedSession_p  Pointer to the location which contains the opaque Transacted Session pointer on return.\n @param rfu_p               Reserved for future use; must be NULL.\n @returns                     ::SOLCLIENT_OK on success. ::SOLCLIENT_FAIL, or ::SOLCLIENT_NOT_READY\n @subcodes\n @see ::solClient_subCode for a description of subcodes."]
    pub fn solClient_session_createTransactedSession(
        props: solClient_propertyArray_pt,
        session_p: solClient_opaqueSession_pt,
        transactedSession_p: *mut solClient_opaqueTransactedSession_pt,
        rfu_p: *mut ::std::os::raw::c_void,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Destroys a previous created Transacted Session.\n This operation must not be performed from a callback for associated with the Transacted Session\n being destroyed. This includes all Flows on the Transacted Session.\n @see @ref transacted-session\n\n @param transactedSession_p  Pointer to opaque Transacted Session pointer that was returned\n                              when the Transacted Session was created.\n @returns ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of subcodes."]
    pub fn solClient_transactedSession_destroy(
        transactedSession_p: *mut solClient_opaqueTransactedSession_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Rollback the active transaction of a specified Transacted Session.\n @see @ref transacted-session\n\n @param transactedSession_p  Pointer to opaque Transacted Session pointer that was returned when\n the Transacted Session was created.\n @returns ::SOLCLIENT_OK on success, ::SOLCLIENT_NOT_READY if underlying session is not active,\n ::SOLCLIENT_FAIL if the Transacted Session is no longer active.\n @subcodes\n @li ::SOLCLIENT_SUBCODE_INVALID_TRANSACTED_SESSION_ID\n @li ::SOLCLIENT_SUBCODE_INVALID_TRANSACTION_ID\n @li ::SOLCLIENT_SUBCODE_COMMIT_OR_ROLLBACK_IN_PROGRESS"]
    pub fn solClient_transactedSession_rollback(
        transactedSession_p: solClient_opaqueTransactedSession_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Commit the active transaction of a specified Transacted Session.\n @see @ref transacted-session\n\n @param transactedSession_p  Pointer to opaque Transacted Session pointer that was returned when\n the Transacted Session was created.\n @returns\n @li ::SOLCLIENT_OK on success\n @li ::SOLCLIENT_NOT_READY if underlying session is not active\n @li ::SOLCLIENT_ROLLBACK if a ROLLBACK response is received and the Transacted Session is still active\n @li ::SOLCLIENT_FAIL\n\n The following subcodes all apply when ::SOLCLIENT_ROLLBACK is returned.\n @li ::SOLCLIENT_SUBCODE_INVALID_TRANSACTED_SESSION_ID\n @li ::SOLCLIENT_SUBCODE_INVALID_TRANSACTION_ID\n @li ::SOLCLIENT_SUBCODE_NO_TRANSACTION_STARTED\n @li ::SOLCLIENT_SUBCODE_MESSAGE_CONSUME_FAILURE\n @li ::SOLCLIENT_SUBCODE_MESSAGE_PUBLISH_FAILURE\n @li ::SOLCLIENT_SUBCODE_QUEUE_SHUTDOWN\n @li ::SOLCLIENT_SUBCODE_TE_SHUTDOWN\n @li ::SOLCLIENT_SUBCODE_SPOOL_OVER_QUOTA\n @li ::SOLCLIENT_SUBCODE_QUEUE_NOT_FOUND\n @li ::SOLCLIENT_SUBCODE_TRANSACTION_FAILURE\n @li ::SOLCLIENT_SUBCODE_ENDPOINT_MODIFIED\n @li ::SOLCLIENT_SUBCODE_INVALID_CONNECTION_OWNER\n @li ::SOLCLIENT_SUBCODE_COMMIT_OR_ROLLBACK_IN_PROGRESS\n @li ::SOLCLIENT_SUBCODE_NO_SUBSCRIPTION_MATCH\n @li ::SOLCLIENT_SUBCODE_CONTROL_OTHER\n\n When solClient_transactedSession_commit() returns ::SOLCLIENT_FAIL, the status of the outstanding commit request cannot be determined. The commit may have succeeded on the message-router before the response was lost. Or the commit request may have failed (roll back).  Applications that treat the failure as a rollback must allow for duplicate transactions. The following subcodes may occur:\n @li ::SOLCLIENT_SUBCODE_COMMIT_STATUS_UNKNOWN - This can occur when a commit request is sent and before the response is received the connection failed and was\n automatically re-established to a standby message router. The API establishes a new transacted session and processing may continue but the status of the last\n commit request is unknown.\n\n @see ::solClient_subCode for a description of subcodes."]
    pub fn solClient_transactedSession_commit(
        transactedSession_p: solClient_opaqueTransactedSession_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Sends an Guaranteed Delivery  message on the specified Transacted Session.\n The message is composed of a number of\n optional components that are specified by the msg_p. The application should first allocate a\n solClient_msg, then use the methods defined in solClientMsg.h to build the message to send. \\n\n solClient_transactedSession_sendMsg() returns ::SOLCLIENT_OK when the message has been successfully\n copied to the transmit buffer or underlying transport.\n A successful commit acknowledges published messages delivered to the Solace messaging broker.\n @see @ref transacted-session\n\n @param transactedSession_p The opaque Transacted Session returned when the Transacted Session was created.\n @param msg_p           The opaque message created by solClient_msg_alloc.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_NOT_READY, or ::SOLCLIENT_FAIL.\n @subcodes\n @li ::SOLCLIENT_SUBCODE_DELIVERY_MODE_UNSUPPORTED\n @li ::SOLCLIENT_SUBCODE_COMMIT_OR_ROLLBACK_IN_PROGRESS"]
    pub fn solClient_transactedSession_sendMsg(
        transactedSession_p: solClient_opaqueTransactedSession_pt,
        msg_p: solClient_opaqueMsg_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Create a transacted consumer Flow within a specified Transacted Session.\n If a Rx Message Callback is provided, messages received on the flow are dispatched\n to the callback with its usual user_p in a context of a Message Dispatcher\n thread. If there is no Rx Message Callback (i.e.\n funcInfo_p-> rxMsgInfo.callback_p=NULL), messages received on the Flow are queued internally.\n Applications must call ::solClient_flow_receiveMsg() directly to retrieve the queued messages.\n\n Unlike non-transacted Flows, events and messages received on a transacted Flow are delivered\n in the context of two different threads. Events are still delivered in a context of\n the context thread, but messages are dispatched to the Flow Rx message\n callback with their usual user_p in the context of a Message Dispatcher thread or are retrieved by\n calling solClient_flow_receiveMsg() from the context of an application thread.\n @see @ref transacted-session\n\n The following flow properties are not supported by transacted Flows:\n  @li ::SOLCLIENT_FLOW_PROP_ACKMODE\n  @li ::SOLCLIENT_FLOW_PROP_AUTOACK\n  @li ::SOLCLIENT_FLOW_PROP_BROWSER\n  @li ::SOLCLIENT_FLOW_PROP_MAX_UNACKED_MESSAGES\n\n @param props           An array of name/value string pair pointers to configure Flow properties.\n @param transactedSession_p The Transacted Session in which the transacted Flow is to be created.\n @param flow_p    The returned opaque Flow pointer that refers to the created Flow.\n @param funcInfo_p      A pointer to a structure that provides information on callback functions for events and received messages.\n @param funcInfoSize    The size of the passed-in funcInfo structure (in bytes) to allow the structure to grow in the future.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_FAIL, ::SOLCLIENT_NOT_READY\n  @subcodes\n     SOLCLIENT_SUBCODE_PROP_PARAM_CONFLICT\n @see ::solClient_subCode for a description of subcodes."]
    pub fn solClient_transactedSession_createFlow(
        props: solClient_propertyArray_pt,
        transactedSession_p: solClient_opaqueTransactedSession_pt,
        flow_p: *mut solClient_opaqueFlow_pt,
        funcInfo_p: *mut solClient_flow_createFuncInfo_t,
        funcInfoSize: usize,
    ) -> solClient_returnCode_t;
}
extern "C" {
    pub fn solClient_transactedSession_getSessionName(
        transactedSession_p: solClient_opaqueTransactedSession_pt,
        nameBuf_p: *mut ::std::os::raw::c_char,
        bufSize: usize,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Receives a message from a specified Transacted Flow.\n It waits until timeout or a message received, no wait if timeout=0.\n Applications must later call solClient_msg_free() to release the received message.\n @see @ref transacted-session\n\n @param flow_p     Opaque flow pointer.\n @param msg_p      Pointer to the location to contain the opaque message pointer.  If there is no message, the opaque message pointer is set to NULL.\n @param timeout    timeout in milliseconds, 0 means no wait.\n @returns\n     @li  ::SOLCLIENT_OK with a valid opaque message pointer if queue is not empty,\n     @li  ::SOLCLIENT_OK with the returned opaque message pointer set to NULL (*msg_p= NULL) when timeout or\n              queue is empty and timeout=0.\n     @li   ::SOLCLIENT_FAIL with subcode ::SOLCLIENT_SUBCODE_INVALID_FLOW_OPERATION if the flow is not a Transacted Flow or ::SOLCLIENT_SUBCODE_FLOW_UNBOUND if the flow is unbound and there are no buffered messages within the API waiting for delivery.\n     @li   ::SOLCLIENT_NOT_READY with subcode ::SOLCLIENT_SUBCODE_SESSION_NOT_ESTABLISHED or ::SOLCLIENT_SUBCODE_NO_TRANSACTION_STARTED.\n @subcodes\n     @li ::SOLCLIENT_SUBCODE_FLOW_UNBOUND\n     @li ::SOLCLIENT_SUBCODE_INVALID_FLOW_OPERATION\n     @li ::SOLCLIENT_SUBCODE_NO_TRANSACTION_STARTED\n     @li ::SOLCLIENT_SUBCODE_COMMIT_OR_ROLLBACK_IN_PROGRESS\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_flow_receiveMsg(
        flow_p: solClient_opaqueFlow_pt,
        msg_p: *mut solClient_opaqueMsg_pt,
        timeout: solClient_int32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Returns the Transacted Session pointer with the specified Flow.\n When flows are created within a Transacted Session (see ::solClient_transactedSession_createFlow), then this routine can be used if the application has\n a Flow pointer and needs to determine the associated Transacted Session. For example, in a Flow event callback in which a Flow pointer is provided,\n an application can use this routine to determine the associated Transacted Session.\n @see @ref transacted-session\n\n @param flow_p     Opaque flow pointer.\n @param transactedSession_p  Pointer to the location which contains the opaque Transacted Session pointer on return.\n @return ::SOLCLIENT_OK, ::SOLCLIENT_NOT_READY, ::SOLCLIENT_FAIL"]
    pub fn solClient_flow_getTransactedSession(
        flow_p: solClient_opaqueFlow_pt,
        transactedSession_p: *mut solClient_opaqueTransactedSession_pt,
    ) -> solClient_returnCode_t;
}
pub const solClient_cacheStatus_SOLCLIENT_CACHE_INVALID_MESSAGE: solClient_cacheStatus = -1;
pub const solClient_cacheStatus_SOLCLIENT_CACHE_LIVE_MESSAGE: solClient_cacheStatus = 0;
pub const solClient_cacheStatus_SOLCLIENT_CACHE_MESSAGE: solClient_cacheStatus = 1;
pub const solClient_cacheStatus_SOLCLIENT_CACHE_SUSPECT_MESSAGE: solClient_cacheStatus = 2;
#[doc = " @enum solClient_cacheStatus\n\n Cache Status of received message, returned by solClient_msg_isCacheMsg()"]
pub type solClient_cacheStatus = ::std::os::raw::c_int;
#[doc = " @enum solClient_cacheStatus\n\n Cache Status of received message, returned by solClient_msg_isCacheMsg()"]
pub use self::solClient_cacheStatus as solClient_cacheStatus_t;
#[doc = "< Approximate amount of total memory consumed for message pool (allocated and on free list)"]
pub const solClient_msg_stats_SOLCLIENT_MSG_STATS_TOTAL_MEMORY: solClient_msg_stats = 0;
#[doc = "< Approximate amount of allocated memory (in-use; not on free list)"]
pub const solClient_msg_stats_SOLCLIENT_MSG_STATS_ALLOC_MEMORY: solClient_msg_stats = 1;
#[doc = "< The number of message allocations performed -- calls to ::solClient_msg_alloc()"]
pub const solClient_msg_stats_SOLCLIENT_MSG_STATS_MSG_ALLOCS: solClient_msg_stats = 2;
#[doc = "< The number of message frees performed -- calls to ::solClient_msg_free()"]
pub const solClient_msg_stats_SOLCLIENT_MSG_STATS_MSG_FREES: solClient_msg_stats = 3;
#[doc = "< The number of message dups performed -- calls to ::solClient_msg_dup()"]
pub const solClient_msg_stats_SOLCLIENT_MSG_STATS_MSG_DUPS: solClient_msg_stats = 4;
#[doc = "< The number of message re-allocations performed (growth in a message buffer)"]
pub const solClient_msg_stats_SOLCLIENT_MSG_STATS_MSG_REALLOCS: solClient_msg_stats = 5;
#[doc = "< The number of messages on message free list"]
pub const solClient_msg_stats_SOLCLIENT_MSG_STATS_FREE_MSGS: solClient_msg_stats = 6;
#[doc = "< The number of currently allocated messages"]
pub const solClient_msg_stats_SOLCLIENT_MSG_STATS_ALLOC_MSGS: solClient_msg_stats = 7;
#[doc = "< The number of containers (streams or maps) on container free list."]
pub const solClient_msg_stats_SOLCLIENT_MSG_STATS_FREE_CONTAINERS: solClient_msg_stats = 8;
#[doc = "< The number of currently allocated containers (for example, stream or map)."]
pub const solClient_msg_stats_SOLCLIENT_MSG_STATS_ALLOC_CONTAINERS: solClient_msg_stats = 9;
#[doc = "< The number of free data blocks (of specified quanta size from 0 to ::SOLCLIENT_MSG_NUMDBQUANTA - 1)"]
pub const solClient_msg_stats_SOLCLIENT_MSG_STATS_FREE_DATA_BLOCKS: solClient_msg_stats = 10;
#[doc = "< The number of allocated data blocks (of specified quanta size). Quanta ::SOLCLIENT_MSG_NUMDBQUANTA indicates messages currently allocated that are larger than maximum quanta size."]
pub const solClient_msg_stats_SOLCLIENT_MSG_STATS_ALLOC_DATA_BLOCKS: solClient_msg_stats = 11;
#[doc = " @enum solClient_msg_stats\n Statistics associated with message memory management.\n These statistics can be retrieved through ::solClient_msg_getStat()."]
pub type solClient_msg_stats = ::std::os::raw::c_uint;
#[doc = " @enum solClient_msg_stats\n Statistics associated with message memory management.\n These statistics can be retrieved through ::solClient_msg_getStat()."]
pub use self::solClient_msg_stats as solClient_msg_stats_t;
extern "C" {
    #[doc = " Allocate a solClient Msg that can be used for storing and sending\n messages to and from the Solace Messaging Appliance.\n Applications are responsible for releasing all message buffers they allocate\n by solClient_msg_alloc().\n\n @param  msg_p         A pointer to the memory that will hold the Msg pointer.\n                       This is an opaque value. Elements of the msg\n                       may only be accessed by the accessors defined in this\n                       API.\n @returns              ::SOLCLIENT_OK on success. ::SOLCLIENT_FAIL on failure.\n                       msg_p is only valid after a ::SOLCLIENT_OK return.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_alloc(msg_p: *mut solClient_opaqueMsg_pt) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Free a solClient Msg previously allocated by solClient_msg_alloc().\n Applications are responsible for releasing all message buffers they allocate by\n solClient_msg_alloc() or solClient_msg_dup(). Message buffers received by callback\n are owned by the API and <b>must not</b> be released. However the application may\n take ownership of these message buffers as well by returning\n ::SOLCLIENT_CALLBACK_TAKE_MSG on return from the receive message callback function.\n If the application returns ::SOLCLIENT_CALLBACK_TAKE_MSG, it <b>must</b> release\n the message by calling solClient_msg_free() when it is finished with the message\n buffer.\n @param msg_p   A pointer to the msg_p previously allocated. On return\n                      this reference is NULL and the memory previously referenced by\n                      it is no longer valid.\n @returns             ::SOLCLIENT_OK on success. ::SOLCLIENT_FAIL when msg_p does\n                      not point to a valid msg.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_free(msg_p: *mut solClient_opaqueMsg_pt) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Duplicate a message buffer and allocate a new msg which references all the\n same data. For any data blocks, the reference count is incremented to\n indicate that two message buffers have pointers to the data.\n Applications are responsible for releasing all message buffers they allocate by\n solClient_msg_dup().\n @param msg_p         A pointer to a Msg.\n @param dupMsg_p      A pointer to return a pointer to new msg.\n @returns             ::SOLCLIENT_OK or ::SOLCLIENT_FAIL.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_dup(
        msg_p: solClient_opaqueMsg_pt,
        dupMsg_p: *mut solClient_opaqueMsg_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Release all memory associated with a message buffer. This function returns\n a message buffer to its original state, as if it has just been allocated\n by solClient_msg_alloc.\n\n @param msg_p   A pointer to a Msg.\n @returns       ::SOLCLIENT_OK or ::SOLCLIENT_FAIL.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_reset(msg_p: solClient_opaqueMsg_pt) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, retrieve the user property Map from binary metadata.\n The returned map is a multimap, in which more than one value may be associated\n with a given field name. A call to <i>solClient_container_addXyz()</i> does not\n overwrite an existing one, instead it adds a new field. To overwrite an existing\n field, the field has to been deleted and then added with a new value. To get all\n values associated with a given field name, a linear search is required.\n The returned map should later be closed by a call to\n ::solClient_container_closeMapStream(). However, if it is not, the map\n is automatically closed when the associated message is freed through a call to\n ::solClient_msg_free(). If the map is closed automatically, the\n application cannot continue to use the map. Attempting to use a closed map\n returns an invalid pointer error (::SOLCLIENT_SUBCODE_PARAM_NULL_PTR).\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param map_p    A pointer to memory that contains a map pointer on return.\n @returns        ::SOLCLIENT_OK, ::SOLCLIENT_FAIL, or ::SOLCLIENT_NOT_FOUND\n @subcodes\n @li ::SOLCLIENT_SUBCODE_NO_STRUCTURED_DATA\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getUserPropertyMap(
        msg_p: solClient_opaqueMsg_pt,
        map_p: *mut solClient_opaqueContainer_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, retrieve the contents of a binary attachment part\n as a stream.\n The returned stream should later be closed by a call to\n ::solClient_container_closeMapStream(). However, if it is not, the stream\n is automatically closed when the associated message is freed through a call to\n ::solClient_msg_free(). If the stream is closed automatically, the\n application may not continue to use the stream. Attempting to use a closed stream\n returns an invalid pointer error (::SOLCLIENT_SUBCODE_PARAM_NULL_PTR)\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param stream_p pointer to memory that contains a stream pointer on return.\n @returns        ::SOLCLIENT_OK, ::SOLCLIENT_FAIL, or ::SOLCLIENT_NOT_FOUND\n @subcodes\n @li ::SOLCLIENT_SUBCODE_NO_STRUCTURED_DATA\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getBinaryAttachmentStream(
        msg_p: solClient_opaqueMsg_pt,
        stream_p: *mut solClient_opaqueContainer_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, retrieve the contents of a binary attachment part as a map.\n The returned map is a multimap in which more than one value may be associated\n with a given field name. A call to <i>solClient_container_addXyz()</i> does not\n overwrite an existing one, but adds a new one instead. To overwrite an existing\n field, the field has to been deleted and then added with a new value. To get all\n values associated with a given field name, a linear search is required.\n The returned map should later be closed by a call to\n ::solClient_container_closeMapStream(). However, if it is not, the map\n is automatically closed when the associated message is freed through a call to\n ::solClient_msg_free(). If the map is closed automatically, the\n application may not continue to use the map. Attempting to use a closed map\n will return an invalid pointer error (::SOLCLIENT_SUBCODE_PARAM_NULL_PTR)\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param map_p    A pointer to memory that contains a map pointer on return;\n @returns        ::SOLCLIENT_OK, ::SOLCLIENT_FAIL, or ::SOLCLIENT_NOT_FOUND\n @subcodes\n @li ::SOLCLIENT_SUBCODE_NO_STRUCTURED_DATA\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getBinaryAttachmentMap(
        msg_p: solClient_opaqueMsg_pt,
        map_p: *mut solClient_opaqueContainer_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, retrieve the contents of a binary attachment part and\n return the pointer and length.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                       to solClient_msg_alloc() or received data callback.\n @param bufPtr_p       A pointer to the application pointer to fill in with the\n                       message data pointer on return. The programmer may cast\n                       the returned void pointer to any reference suitable for\n                       the application.\n @param size_p         A pointer to memory that contains data size on\n                       return.\n @returns              ::SOLCLIENT_OK or ::SOLCLIENT_FAIL or ::SOLCLIENT_NOT_FOUND\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getBinaryAttachmentPtr(
        msg_p: solClient_opaqueMsg_pt,
        bufPtr_p: solClient_opaquePointer_pt,
        size_p: *mut solClient_uint32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, retrieve the contents of a binary attachment part if it is\n a JMS string and return a pointer to the string (NULL-terminated string).\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                       to solClient_msg_alloc() or received data callback.\n @param bufPtr_p       A pointer to memory that contains the string pointer\n                       on return.\n @returns              ::SOLCLIENT_OK or ::SOLCLIENT_FAIL or ::SOLCLIENT_NOT_FOUND\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getBinaryAttachmentString(
        msg_p: solClient_opaqueMsg_pt,
        bufPtr_p: *mut *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, retrieve the size of the open container in the binary\n attachment. If there is no open container in the binary attachment,\n this function returns ::SOLCLIENT_NOT_FOUND.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                       to solClient_msg_alloc() or received data callback.\n @param size_p   A pointer to memory that contains the size on return.\n @returns        ::SOLCLIENT_OK or ::SOLCLIENT_FAIL or ::SOLCLIENT_NOT_FOUND\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getBinaryAttachmentContainerSize(
        msg_p: solClient_opaqueMsg_pt,
        size_p: *mut usize,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, retrieve the contents of a Correlation Tag part (used by\n an application when sending Guaranteed messages and receiving Guaranteed message\n acknowledgments) and return the pointer and length.\n\n @param msg_p          solClient_opaqueMsg_pt that is returned from a previous call\n                       to solClient_msg_alloc() or received in a receive\n                       message callback.\n @param bufPtr_p       A pointer to the application pointer to fill in with the\n                       message correlation tag pointer on return. The programmer may cast\n                       the returned void pointer to any reference suitable for\n                       the application.\n @param size_p         A pointer to memory that contains data size on\n                       return.\n @see @ref adConsiderations\n @returns              ::SOLCLIENT_OK or ::SOLCLIENT_FAIL or ::SOLCLIENT_NOT_FOUND\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getCorrelationTagPtr(
        msg_p: solClient_opaqueMsg_pt,
        bufPtr_p: solClient_opaquePointer_pt,
        size_p: *mut solClient_uint32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, retrieve the contents of a User Data part.\n\n The maximum size allowed for the user data part is ::SOLCLIENT_BUFINFO_MAX_USER_DATA_SIZE.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param bufPtr_p       A pointer to the application pointer to fill in with the\n                       message user data pointer on return. The programmer may cast\n                       the returned void pointer to any reference suitable for\n                       the application.\n @param size_p         A pointer to memory that contains data size on\n                       return.\n @returns              ::SOLCLIENT_OK or ::SOLCLIENT_FAIL or ::SOLCLIENT_NOT_FOUND\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getUserDataPtr(
        msg_p: solClient_opaqueMsg_pt,
        bufPtr_p: solClient_opaquePointer_pt,
        size_p: *mut solClient_uint32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, retrieve the contents of a XML part of the message.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param bufPtr_p       A pointer to the application pointer to fill in with the\n                       message XML data pointer on return. The programmer may cast\n                       the returned void pointer to any reference suitable for\n                       the application.\n @param size_p         A pointer to memory that contains data size on\n                       return.\n @returns              ::SOLCLIENT_OK or ::SOLCLIENT_FAIL or ::SOLCLIENT_NOT_FOUND\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getXmlPtr(
        msg_p: solClient_opaqueMsg_pt,
        bufPtr_p: solClient_opaquePointer_pt,
        size_p: *mut solClient_uint32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, retrieve the raw Solace Message Format (SMF) message as originally\n received.\n\n @param msg_p    solClient_opaqueMsg_pt received in a receive message\n                 callback.\n @param bufPtr_p       A pointer to the application pointer to fill in with the\n                       message SMF pointer on return. SMF data is binary 8 byte data\n                       and can be stored by copying 'size' bytes from the returned\n                       pointer.\n @param size_p         A pointer to memory that contains data size on\n                       return.\n @returns              ::SOLCLIENT_OK or ::SOLCLIENT_FAIL or ::SOLCLIENT_NOT_FOUND\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getSMFPtr(
        msg_p: solClient_opaqueMsg_pt,
        bufPtr_p: *mut *mut solClient_uint8_t,
        size_p: *mut solClient_uint32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set the contents of a Binary Attachment Part to the given\n pointer and size. This memory may contain the pre-built payload the\n application is sending, or an application may choose to subsequently build a\n structured message (a map or stream container) in the Binary Attachment\n part and the buffer set here is used to construct the container up\n to the size. If the structured message grows to exceed the set size,\n an internal data block is used to hold the entire container.\n\n <b>NOTE:</b> When a Guaranteed message is constructed with this API\n refer to @ref adConsiderations.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param buf_p          A pointer to buffer.\n @param size           The maximum number of bytes in buffer.\n @returns              ::SOLCLIENT_OK or ::SOLCLIENT_FAIL if msg_p is invalid.\n @subcodes\n @li ::SOLCLIENT_SUBCODE_NO_STRUCTURED_DATA\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setBinaryAttachmentPtr(
        msg_p: solClient_opaqueMsg_pt,
        buf_p: *mut ::std::os::raw::c_void,
        size: solClient_uint32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set the contents of the binary attachment part by copying in from\n the given pointer and size. This causes memory to be allocated from\n API internal or heap storage. If any binary attachment previously existed it will\n be first removed before the new data is copied in.\n\n Passing in a buf_p of NULL and a size of zero results in\n a binary attachment not being present in the message.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param buf_p          A pointer to buffer.\n @param size           The maximum number of bytes in buffer.\n @returns              ::SOLCLIENT_OK or ::SOLCLIENT_FAIL if msg_p is invalid\n                       or memory not available.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setBinaryAttachment(
        msg_p: solClient_opaqueMsg_pt,
        buf_p: *const ::std::os::raw::c_void,
        size: solClient_uint32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set the contents of the binary attachment part to a UTF-8 or ASCII string\n by copying in from the given pointer until null-terminated. The message\n will be TLV-encoded suitable for reading by any other Solace Corporation Messaging APIs.\n If any binary attachment previously existed it is first\n removed before the new data is copied in.\n\n Passing in a buf_p of NULL results in\n a binary attachment not being present in the message.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param buf_p          A pointer to a buffer containing a UTF-8 or ASCII string.\n @returns              ::SOLCLIENT_OK or ::SOLCLIENT_FAIL if msg_p is invalid\n                       or memory is not available.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setBinaryAttachmentString(
        msg_p: solClient_opaqueMsg_pt,
        buf_p: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set the contents of the binary attachment part to a Map or Stream, as\n referenced by the given solClient_opaqueContainer_pt. This function\n copies in from the given container. Changes to the container after this function is called\n will not be propagated to this message. The message\n will be TLV encoded suitable for reading by any other Solace Messaging API.\n If any binary attachment previously existed it is first\n removed before the new data is copied in.\n\n <b>WARNING:</b> This method is intended to be used to add an existing\n message independent container to a message. That is, a container created by\n either ::solClient_container_createMap() or ::solClient_container_createStream().\n Do <b>not</b> call this method with a container that is already in the message,\n returned from a call to ::solClient_msg_createBinaryAttachmentMap or\n ::solClient_msg_createBinaryAttachmentStream. That is unnecessary as the container\n is already in the message. Further, the first operation of\n ::solClient_msg_setBinaryAttachmentContainer() is to wipe out the existing binary\n attachment.\n\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param cont_p   An opaque container pointer for the container to add.\n @returns              ::SOLCLIENT_OK or ::SOLCLIENT_FAIL if msg_p is invalid\n                       or memory is not available.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setBinaryAttachmentContainer(
        msg_p: solClient_opaqueMsg_pt,
        cont_p: solClient_opaqueContainer_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set the contents of the binary attachment part to a Map or Stream, as\n referenced by the given solClient_opaqueContainer_pt. This function\n takes a reference to the given container. This is a high performance interface function that avoids a memory\n copy from application memory into the message binary attachment. On a subsequent ::solClient_session_sendMsg() the\n binary attachment contents will be copied directly from the application memory to the transmit socket or buffer.\n\n <b>NOTE:</b> When a Guaranteed message is constructed with this API\n refer to @ref adConsiderations\n\n In addition to the above note, the application <b>must not</b> change the container after this function is called until\n the message is sent, even when the message contains a non-Guaranteed message. Changing the container, or releasing the memory referenced\n by the container, will cause the message contents to be a corrupt container when transmitted. If the container is added to a Guaranteed\n Delivery message by reference then the container and container memory must not be modified until the appliance acknowledgment for the\n message is received. This latter further restriction for Guaranteed Delivery is required in case the C API library\n needs to retransmit the original message for any reason. In general, for Guaranteed Delivery, it is far safer to use\n ::solClient_msg_setBinaryAttachmentContainer. It is unlikely the application will achieve any performance gains by\n this function with Guaranteed messages.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param cont_p   An opaque container pointer for the container to add.\n @returns              ::SOLCLIENT_OK or ::SOLCLIENT_FAIL if msg_p is invalid\n                       or memory is not available.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setBinaryAttachmentContainerPtr(
        msg_p: solClient_opaqueMsg_pt,
        cont_p: solClient_opaqueContainer_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set the contents of a user data part to the given\n pointer and size.\n This function is provided for high-performance applications that\n must be aware that the data referenced cannot be modified until the send\n operation completes.\n\n The maximum size allowed for the user data part is ::SOLCLIENT_BUFINFO_MAX_USER_DATA_SIZE.\n\n <b>NOTE:</b> When a Guaranteed message is constructed with this API\n refer to @ref adConsiderations\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param buf_p    A pointer to buffer.\n @param size     The number of bytes in the buffer.\n @returns        ::SOLCLIENT_OK or ::SOLCLIENT_FAIL if msg_p is invalid.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setUserDataPtr(
        msg_p: solClient_opaqueMsg_pt,
        buf_p: *mut ::std::os::raw::c_void,
        size: solClient_uint32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set the contents of User Data Part by copying in from\n the given pointer and size. This causes memory to be allocated from internal\n or heap storage. If any user data previously existed it is first\n removed before the new data is copied in.\n\n The maximum size allowed for the user data part is ::SOLCLIENT_BUFINFO_MAX_USER_DATA_SIZE.\n\n Passing in a buf_p of NULL and a size of zero results in\n user data not being present in the message.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param buf_p    A pointer to buffer.\n @param size     The number of bytes in buffer.\n @returns        ::SOLCLIENT_OK or ::SOLCLIENT_FAIL if msg_p is invalid\n                 or memory not available.\n @subcodes\n @li ::SOLCLIENT_SUBCODE_NO_STRUCTURED_DATA\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setUserData(
        msg_p: solClient_opaqueMsg_pt,
        buf_p: *const ::std::os::raw::c_void,
        size: solClient_uint32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set the contents of the XML part to the given\n pointer and size.\n This function is provided for high-performance applications that\n must be aware that the data referenced cannot be modified until the send\n operation completes.\n\n <b>NOTE:</b> When a Guaranteed message is constructed with this API\n refer to @ref adConsiderations.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param buf_p    A pointer to buffer.\n @param size     The number of bytes in buffer.\n @returns        ::SOLCLIENT_OK or ::SOLCLIENT_FAIL if msg_p is invalid.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setXmlPtr(
        msg_p: solClient_opaqueMsg_pt,
        buf_p: *mut ::std::os::raw::c_void,
        size: solClient_uint32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set the contents of the XML part by copying in from\n the given pointer and size. This causes memory to be allocated from internal\n or heap storage. If any XML part previously existed, it is first\n removed before the new data is copied in.\n\n Passing in a buf_p of NULL and a size of zero results in\n the XML part not being present in the message.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param buf_p    A pointer to buffer.\n @param size     The number of bytes in buffer.\n @returns        ::SOLCLIENT_OK or ::SOLCLIENT_FAIL if msg_p is invalid\n                 or memory not available.\n @subcodes\n @li ::SOLCLIENT_SUBCODE_NO_STRUCTURED_DATA\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setXml(
        msg_p: solClient_opaqueMsg_pt,
        buf_p: *const ::std::os::raw::c_void,
        size: solClient_uint32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set the Correlation Tag to the given pointer. The Correlation Tag is a\n local reference used by applications generating Guaranteed messages. Messages that are\n sent in either PERSISTENT or non-PERSISTENT mode can set the Correlation Tag,\n which is returned when the ::SOLCLIENT_SESSION_EVENT_ACKNOWLEDGEMENT event\n is later received. The solClient_session_eventCallbackInfo structured returned with the\n event contains a (void *) correlation_p which will be the same pointer the application\n initializes with this method.\n Important: <b>The Correlation Tag is not included in the\n transmitted message and is only used with the local API</b>.\n\n This function is provided for high-performance applications that\n must be aware that the data referenced cannot be modified until the send\n operation completes.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param correlation_p    A pointer to buffer.\n @param size     Ignored.\n @see @ref adConsiderations\n @returns        ::SOLCLIENT_OK or ::SOLCLIENT_FAIL if msg_p is invalid.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setCorrelationTagPtr(
        msg_p: solClient_opaqueMsg_pt,
        correlation_p: *mut ::std::os::raw::c_void,
        size: solClient_uint32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, save correlation information Part by copying in from\n the given pointer and size. This is not recommended for high performance applications,\n use solClient_msg_setCorrelationTagPtr instead. The Correlation Tag is a local reference\n used by applications generating Guaranteed messages. Messages that are\n sent in either PERSISTENT or non-PERSISTENT mode may set the Correlation Tag. If this\n method is used, a pointer to the correlation information is returned\n when the ::SOLCLIENT_SESSION_EVENT_ACKNOWLEDGEMENT event\n is later received. The solClient_session_eventCallbackInfo structured returned with the\n event contains a (void *) correlation_p which points to a copy of the information\n initialized with this method. The size is <b>not</b> returned.\n Important: <b>The Correlation Tag is not included in the\n transmitted message and is only used with the local API</b>.\n\n This causes memory to be allocated from internal\n or heap storage.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param correlation_p  A pointer to the correlation information.\n @param size     The number of bytes in buffer.\n @see @ref adConsiderations\n @returns        ::SOLCLIENT_OK or ::SOLCLIENT_FAIL if msg_p is invalid\n                 or memory not available.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setCorrelationTag(
        msg_p: solClient_opaqueMsg_pt,
        correlation_p: *const ::std::os::raw::c_void,
        size: solClient_uint32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set the Topic of the message as a pointer to application\n space. This function is provided for high-performance applications that\n must be aware that the data referenced cannot be modified until the send\n operation completes.\n\n <b>NOTE:</b> When a Guaranteed message is constructed with this API\n refer to @ref adConsiderations.\n\n Only solClient_msg_setTopicPtr is provided, for copy-in operations use\n solClient_msg_setDestination.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param topic_p  A pointer to topic string.\n @returns        ::SOLCLIENT_OK or ::SOLCLIENT_FAIL if msg_p is invalid.\n @subcodes\n @li ::SOLCLIENT_SUBCODE_NO_STRUCTURED_DATA\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setTopicPtr(
        msg_p: solClient_opaqueMsg_pt,
        topic_p: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set the QueueName destination of the message as a pointer to\n application space.\n This function is provided for high-performance applications that must be\n aware that the pointer data cannot be modified until the send operation\n completes.\n\n <b>NOTE:</b> When a Guaranteed message is constructed with this API\n refer to @ref adConsiderations.\n\n Only solClient_msg_setQueueNamePtr is provided, for copy-in\n operations use solClient_msg_setDestination.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param queueName_p    A pointer to topic string.\n @returns              ::SOLCLIENT_OK or ::SOLCLIENT_FAIL if msg_p is invalid.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setQueueNamePtr(
        msg_p: solClient_opaqueMsg_pt,
        queueName_p: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, retrieve the replyTo destination and set the information\n in the passed in destination structure. On return dest_p->dest points to\n message memory and is only valid as long as msg_p is valid.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param dest_p         A pointer to destination structure to receive ReplyTo.\n @param destSize       The size of (solClient_destination_t).\n @returns              ::SOLCLIENT_OK, ::SOLCLIENT_FAIL, ::SOLCLIENT_NOT_FOUND\n @subcodes\n @li ::SOLCLIENT_SUBCODE_NO_STRUCTURED_DATA\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getReplyTo(
        msg_p: solClient_opaqueMsg_pt,
        dest_p: *mut solClient_destination_t,
        destSize: usize,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set the ReplyTo destination.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param dest_p         A pointer to ReplyTo destination to set.\n @param destSize       The size of (solClient_destination_t).\n @returns              ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setReplyTo(
        msg_p: solClient_opaqueMsg_pt,
        dest_p: *const solClient_destination_t,
        destSize: usize,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, delete the ReplyTo destination.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @returns        ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_deleteReplyTo(msg_p: solClient_opaqueMsg_pt) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set the Destination field (queue or topic).\n A destination can be removed from a message\n by setting the ::solClient_destination_t structure to\n {::SOLCLIENT_NULL_DESTINATION, NULL}.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param dest_p         A pointer to destination information.\n @param destSize      The size of (solClient_destination_t).\n @returns              ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @li ::SOLCLIENT_SUBCODE_NO_STRUCTURED_DATA\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setDestination(
        msg_p: solClient_opaqueMsg_pt,
        dest_p: *mut solClient_destination_t,
        destSize: usize,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, get the Destination field (queue or topic), which is the\n destination this message was published to. On successful\n return dest_p->dest points to message memory and is only valid as\n long as msg_p is valid.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param dest_p         A pointer to destination information.\n @param destSize       The size of destination_t structure.\n @returns              ::SOLCLIENT_OK, ::SOLCLIENT_FAIL, ::SOLCLIENT_NOT_FOUND\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getDestination(
        msg_p: solClient_opaqueMsg_pt,
        dest_p: *mut solClient_destination_t,
        destSize: usize,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, copy the SenderID pointer into the given buffer.\n\n This method allows the application to retrieve a pointer to the string that\n is the SenderID.  The SenderID is user-defined,\n carried end-to-end, and can also be matched in a selector, but otherwise is not relevant\n to the event broker.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param buf_p          A pointer to string pointer for senderId.\n @returns              ::SOLCLIENT_OK on success,  ::SOLCLIENT_FAIL if msg\n                       is invalid, ::SOLCLIENT_NOT_FOUND if msg contains no SenderId field.\n @subcodes\n @li ::SOLCLIENT_SUBCODE_NO_STRUCTURED_DATA\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getSenderId(
        msg_p: solClient_opaqueMsg_pt,
        buf_p: *mut *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set the SenderID.\n\n This overrides ::SOLCLIENT_SESSION_PROP_GENERATE_SENDER_ID\n session property and forces the specified SenderID\n into the binary message header.\n\n This method allows the application to set the contents of the\n SenderID.  The SenderID is user-defined, carried end-to-end, and\n can also be matched in a selector but otherwise is not relevant\n to the event broker.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param buf_p          A pointer to string for the data copy.\n @returns              ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setSenderId(
        msg_p: solClient_opaqueMsg_pt,
        buf_p: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, delete the SenderId.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @returns        ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_deleteSenderId(msg_p: solClient_opaqueMsg_pt) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, copy the ApplicationMessageType topic pointer into the given pointer.\n\n This method allows the application to retrieve a pointer to the string that\n is the ApplicationMessageType.  The ApplicationMessageType is user-defined,\n carried end-to-end, and can also be matched in a selector, but otherwise is not relevant\n to the event broker.\n\n In JMS applications, this field is carried as the JMSType Message Header Field.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param msgType_p      A pointer to string pointer to receive msgType pointer.\n @returns              ::SOLCLIENT_OK on success,  ::SOLCLIENT_FAIL if msg\n                       is invalid, ::SOLCLIENT_NOT_FOUND if it contains no msgType field.\n @subcodes\n @li ::SOLCLIENT_SUBCODE_NO_STRUCTURED_DATA\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getApplicationMsgType(
        msg_p: solClient_opaqueMsg_pt,
        msgType_p: *mut *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set the ApplicationMessageType field.\n\n This method allows the application to set the string contents of the\n ApplicationMessageType.  The ApplicationMessageType is user defined,\n carried end-to-end, and can slso be matched in a selector, but otherwise is not relevant\n to the event broker.\n\n In JMS applications, this field is carried as the JMSType Message Header Field.\n\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param msgType        A pointer to string with msgType.\n @returns              ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL if\n                       msg or length is invalid.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setApplicationMsgType(
        msg_p: solClient_opaqueMsg_pt,
        msgType: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, delete the MsgType field.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @returns        ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_deleteApplicationMsgType(
        msg_p: solClient_opaqueMsg_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, copy the ApplicationMessageId pointer into the given buffer.\n\n This method allows the application to retrieve a pointer to the string that\n is the ApplicationMessageId.  The ApplicationMessageId is user-defined,\n carried end-to-end, and can also be matched in a selector, but otherwise is not relevant\n to the event broker.\n\n In JMS applications, this field is carried as the JMSMessageID Message Header Field.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param messageId_p    A pointer to string pointer to receive MessageId pointer.\n @returns              ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL if\n                       msg_p is invalid, ::SOLCLIENT_NOT_FOUND for none found\n @subcodes\n @li ::SOLCLIENT_SUBCODE_NO_STRUCTURED_DATA\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getApplicationMessageId(
        msg_p: solClient_opaqueMsg_pt,
        messageId_p: *mut *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set the ApplicationMessageId field.\n\n This method allows the application to set the string contents of the\n ApplicationMessageId.  The ApplicationMessageId is user defined,\n carried end-to-end, and can slso be matched in a selector, but otherwise is not relevant\n to the event broker.\n\n In JMS applications, this field is carried as the JMSMessageId Message Header Field.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param messageId_p    pointer to string containing messageId.\n @returns              ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL if\n                       msg_p is invalid.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setApplicationMessageId(
        msg_p: solClient_opaqueMsg_pt,
        messageId_p: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, delete the Application MessageId field.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @returns        ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_deleteApplicationMessageId(
        msg_p: solClient_opaqueMsg_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, copy the SequenceNo into the given buffer.\n A sequence number is automatically included (if not already present) in\n the Solace-defined fields for each message sent if the session property\n ::SOLCLIENT_SESSION_PROP_GENERATE_SEQUENCE_NUMBER is enabled.\n\n This method allows the application to retrieve the value that\n is the SequenceNo.  The SequenceNo is user-defined,\n carried end-to-end, and can also be matched in a selector, but otherwise is not relevant\n to the event broker.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param seqNum_p       A pointer to 64-bit field to receive the value.\n @returns              ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL if\n                       msg_p is invalid, ::SOLCLIENT_NOT_FOUND if not found.\n @subcodes\n @li ::SOLCLIENT_SUBCODE_NO_STRUCTURED_DATA\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getSequenceNumber(
        msg_p: solClient_opaqueMsg_pt,
        seqNum_p: *mut solClient_int64_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set the Sequence Number field.\n This overrides the ::SOLCLIENT_SESSION_PROP_GENERATE_SEQUENCE_NUMBER\n session property and forces the specified Sequence Number\n into the binary message header. This does <b>not</b> change the\n internal sequence numbering and the next generated sequence number will\n still be one more than the last generated sequence number.\n\n A sequence number is automatically included (if not already present) in\n the Solace-defined fields for each message sent if the session property\n ::SOLCLIENT_SESSION_PROP_GENERATE_SEQUENCE_NUMBER is enabled.\n\n This method allows the application to set the value of the\n SequenceNo.  The SequenceNo is user defined,\n carried end-to-end, and can slso be matched in a selector, but otherwise is not relevant\n to the event broker.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param seqNum         The 64-bit Sequence Number.\n @returns              ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL if\n                       msg_p is invalid.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setSequenceNumber(
        msg_p: solClient_opaqueMsg_pt,
        seqNum: solClient_uint64_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, delete the Sequence Number field.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @returns        ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_deleteSequenceNumber(
        msg_p: solClient_opaqueMsg_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, copy the CorrelationId pointer into the given buffer.\n\n This method allows the application to retrieve a pointer to the string that\n is the CorrelationId.  The CorrelationId is user-defined,\n carried end-to-end, and can also be matched in a selector, but otherwise is not relevant\n to the event broker.  The CorrelationId may be used for peer-to-peer message synchronization.\n\n In JMS applications, this field is carried as the JMSCorrelationID Message Header Field.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param correlation_p  A pointer to string pointer to receive correlation\n                       Id pointer.\n @returns              ::SOLCLIENT_OK on success, ::SOLCLIENT_NOT_FOUND if the field is\n                       not present and ::SOLCLIENT_FAIL if  msg_p is invalid\n @subcodes\n @li ::SOLCLIENT_SUBCODE_NO_STRUCTURED_DATA\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getCorrelationId(
        msg_p: solClient_opaqueMsg_pt,
        correlation_p: *mut *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set the CorrelationId field.\n\n The CorrelationId is user-defined, carried end-to-end, and can also be matched\n in a selector, but otherwise is not relevant\n to the event broker.  The CorrelationId may be used for peer-to-peer message synchronization.\n\n In JMS applications, this field is carried as the JMSCorrelationID Message Header Field.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param correlation_p  A pointer to string to copy into correlationId.\n @returns              ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL if\n                       msg_p is invalid.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setCorrelationId(
        msg_p: solClient_opaqueMsg_pt,
        correlation_p: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, delete the Correlation Id field.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @returns        ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_deleteCorrelationId(
        msg_p: solClient_opaqueMsg_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, copy the Receive Timestamp into the given buffer.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param timestamp_p    A pointer to a 64-bit field to receive the value.\n                       The value is in milliseconds.\n @returns              ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL if\n                       msg_p is invalid, ::SOLCLIENT_NOT_FOUND if not found.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getRcvTimestamp(
        msg_p: solClient_opaqueMsg_pt,
        timestamp_p: *mut solClient_int64_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set the Sender Timestamp field.\n This overrides the ::SOLCLIENT_SESSION_PROP_GENERATE_SEND_TIMESTAMPS\n session property and sets the specified Sender Timestamp value\n in the binary message header.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param timestamp  The sender timestamp value to set. The value is in milliseconds.\n @returns              ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL if\n                       msg_p is invalid\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setSenderTimestamp(
        msg_p: solClient_opaqueMsg_pt,
        timestamp: solClient_int64_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, copy the SenderTimestamp into the given buffer.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param timestamp_p    A pointer to a 64-bit field to receive the value.\n                       The value is in milliseconds.\n @returns              ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL if\n                       msg_p is invalid, ::SOLCLIENT_NOT_FOUND for none found.\n @subcodes\n @li ::SOLCLIENT_SUBCODE_NO_STRUCTURED_DATA\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getSenderTimestamp(
        msg_p: solClient_opaqueMsg_pt,
        timestamp_p: *mut solClient_int64_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, delete the SenderTimestamp.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @returns        ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_deleteSenderTimestamp(
        msg_p: solClient_opaqueMsg_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set the expiration time field. The expiration time is the UTC time\n (that is, the number of milliseconds from midnight January 1, 1970 UTC) when the\n message is to expire. The expiration time is carried in the message when set to\n a non-zero value. Expiration time is not included when this value is set to zero.\n\n The message expiration time is carried to clients that receive the message\n unmodified and does not effect the life cycle of the message. Use\n solClient_msg_setTimeToLive() to enforce message expiry in the network.\n In fact when solClient_msg_setTimeToLive() is used, setting this property has no effect.\n When solClient_msg_setTimeToLive() is called, the expiration time is never carried\n in the message, however it may be calculated and retrieved by the sender if the session property\n ::SOLCLIENT_SESSION_PROP_CALCULATE_MESSAGE_EXPIRATION is enabled. Thus if\n ::solClient_msg_getExpiration() is called after the message is sent, a calculated\n expiration time is returned based on the time-to-live.\n\n <b>Note:</b> When solClient_msg_setTimeToLive() is set on a message, the receiving\n client may also calculate the expiration time if it has enabled the session\n property ::SOLCLIENT_SESSION_PROP_CALCULATE_MESSAGE_EXPIRATION.\n\n See solClient_msg_getExpiration() for more details.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param timestamp  The sender timestamp value to set. The value is in milliseconds.\n @returns              ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL if\n                       msg_p is invalid\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setExpiration(
        msg_p: solClient_opaqueMsg_pt,
        timestamp: solClient_int64_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, copy the Message Expiration timestamp into the given buffer. If\n message expiration time is not set in the message and the session property\n ::SOLCLIENT_SESSION_PROP_CALCULATE_MESSAGE_EXPIRATION is enabled, the expiration time\n is calculated based on the message Time To Live. When enabled, the expiration time\n for sent messages will be the UTC time when the message is sent plus the Time To Live. The\n expiration time for received messages is the UTC time when the message was received\n plus the Time To Live in the message at the time it was received.\n\n If the expiration time is not set in the message, and it cannot be calculated, the\n timestamp is set to zero.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param timestamp_p    A pointer to a 64-bit field to receive the value.\n                       The value is in milliseconds.\n @returns              ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL if\n                       msg_p is invalid.\n @subcodes\n @li ::SOLCLIENT_SUBCODE_NO_STRUCTURED_DATA\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getExpiration(
        msg_p: solClient_opaqueMsg_pt,
        timestamp_p: *mut solClient_int64_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, get the Class of Service from a message.\n The  Class of Service has different semantics for direct and guaranteed messages.\n\n For direct messages, the class of service selects the weighted round-robin delivery\n queue when the message is forwarded to a consumer.  {::SOLCLIENT_COS_1} are the\n lowest priority messages and will use the solace message-router D-1 delivery queues.\n\n For messages published as guaranteed messages, * messages published\n with ::SOLCLIENT_COS_1 can be rejected by the solace message-router if\n that message would cause any queue or topic-endpoint to exceed its configured\n <i>low-priority-max-msg-count</i>.\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param cos_p         A place to store the returned class of service, one of\n                      @li ::SOLCLIENT_COS_1\n                      @li ::SOLCLIENT_COS_2\n                      @li ::SOLCLIENT_COS_3\n @returns             ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL if\n                      msg_p or cos_p is invalid.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getClassOfService(
        msg_p: solClient_opaqueMsg_pt,
        cos_p: *mut solClient_uint32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set the Class of Service to use for transmission.\n The  Class of Service has different semantics for direct and guaranteed messages.\n\n The  Class of Service has different semantics for direct and guaranteed messages.\n For direct messages, the class of service selects the weighted round-robin delivery\n queue when the message is forwarded to a consumer.  {::SOLCLIENT_COS_1} are the\n lowest priority messages and will use the solace message-router D-1 delivery queues.\n\n For messages published as guaranteed messages, * messages published\n with ::SOLCLIENT_COS_1 can be rejected by the solace message-router if\n that message would cause any queue or topic-endpoint to exceed its configured\n <i>low-priority-max-msg-count</i>.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param cos            The class of service, one of ::SOLCLIENT_COS_1,\n                       ::SOLCLIENT_COS_2, or ::SOLCLIENT_COS_3.\n @returns              ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL if\n                       msg_p is invalid.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setClassOfService(
        msg_p: solClient_opaqueMsg_pt,
        cos: solClient_uint32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, get the Time To Live (TTL) from a message. If the message does not\n contain a time to live field, zero is returned.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param ttl_p    A pointer to a 64-bit field to receive the value.\n                 The value is in milliseconds.\n @returns        ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL if\n                      msg_p or timestamp_p is invalid.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getTimeToLive(
        msg_p: solClient_opaqueMsg_pt,
        ttl_p: *mut solClient_int64_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set the Time To Live (TTL) for a message. Setting the Time To Live to\n zero disables TTL for the message.\n\n This property is only valid for Guaranteed messages (Persistent and Non-Persistent).\n It has no effect when used in conjunction with other message types unless the message\n is promoted by the appliance to a Guaranteed message.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param ttl      64-bit value in milliseconds to use for message time to live.\n @returns              ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL if\n                       msg_p is invalid.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setTimeToLive(
        msg_p: solClient_opaqueMsg_pt,
        ttl: solClient_int64_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, return the delivery mode.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param mode_p         A place to store the returned delivery mode, one of\n                       @li ::SOLCLIENT_DELIVERY_MODE_DIRECT\n                       @li ::SOLCLIENT_DELIVERY_MODE_PERSISTENT\n                       @li ::SOLCLIENT_DELIVERY_MODE_NONPERSISTENT\n @see @ref adConsiderations\n @returns              ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL if\n                       msg_p is invalid.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getDeliveryMode(
        msg_p: solClient_opaqueMsg_pt,
        mode_p: *mut solClient_uint32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set the delivery mode.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param mode           The delivery mode to use for this message. It can be one of the following:\n                       @li ::SOLCLIENT_DELIVERY_MODE_DIRECT\n                       @li ::SOLCLIENT_DELIVERY_MODE_PERSISTENT\n                       @li ::SOLCLIENT_DELIVERY_MODE_NONPERSISTENT\n @see @ref adConsiderations\n @returns              ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL if\n                       msg_p is invalid.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setDeliveryMode(
        msg_p: solClient_opaqueMsg_pt,
        mode: solClient_uint32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, return the Guaranteed message Id. The guaranteed message Id only\n exists in messages received on a flow.  The message Id is only to be used for the\n purpose of acknowledgements.  No other meaning should be inferred from the value\n of the message Id.\n\n Messages are acknowledged by calling ::solClient_flow_sendAck()\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param msgId_p  pointer to memory to store the returned msgId.\n @returns        ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL if\n                 msg_p is invalid, ::SOLCLIENT_NOT_FOUND if msg_p does not contain an\n                 assured delivery message.\n @see @ref adConsiderations\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getMsgId(
        msg_p: solClient_opaqueMsg_pt,
        msgId_p: *mut solClient_msgId_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, return the Topic Sequence Number.  If there is no topic sequence number\n SOLCLIENT_NOT_FOUND is returned and the sequence number returned is zero.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param seqNum_p pointer to memory to store the returned topic sequence number.\n @returns        ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL if\n                 msg_p is invalid, ::SOLCLIENT_NOT_FOUND if msg_p does not contain\n                 a topic sequence number.\n @see @ref adConsiderations\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getTopicSequenceNumber(
        msg_p: solClient_opaqueMsg_pt,
        seqNum_p: *mut solClient_int64_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, return the delivery count. If delivery is supported returns\n SOLCLIENT_OK otherwise returns SOLCLIENT_FAIL.\n Note messages from browser flows will have the delivery of the next\n consumer delivery not the current message delivery count from the endpoint.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param count_p  pointer to memory to store the returned delivery count.\n @returns        ::SOLCLIENT_OK if delivery count is supported,\n                 ::SOLCLIENT_FAIL if delivery count is not supported, or\n                 if msg_p or count_p are invalid.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getDeliveryCount(
        msg_p: solClient_opaqueMsg_pt,
        count_p: *mut solClient_int32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, test the redeliver status.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n\n @see @ref adConsiderations\n @returns        True, if the message was redelivered."]
    pub fn solClient_msg_isRedelivered(msg_p: solClient_opaqueMsg_pt) -> solClient_bool_t;
}
extern "C" {
    #[doc = " Given a msg_p, return the data source (live or cached message).\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n\n @returns        cacheStatus, one of:\n                 @li ::SOLCLIENT_CACHE_LIVE_MESSAGE\n                 @li ::SOLCLIENT_CACHE_MESSAGE\n                 @li ::SOLCLIENT_CACHE_SUSPECT_MESSAGE"]
    pub fn solClient_msg_isCacheMsg(msg_p: solClient_opaqueMsg_pt) -> solClient_cacheStatus_t;
}
extern "C" {
    #[doc = "  Given a msg_p containing a cached message, return the cache RequestId that\n  the application set in the call to solClient_csession_sendCacheRequest().\n\n @param msg_p            solClient_opaquemsg_pt received in a receive message callback.\n @param cacheRequestId_p pointer to location to receive the cacheRequestId.\n\n @returns  ::SOLCLIENT_OK, ::SOLCLIENT_FAIL or ::SOLCLIENT_NOT_FOUND if msg_p does not contain a received\n cache message."]
    pub fn solClient_msg_getCacheRequestId(
        msg_p: solClient_opaqueMsg_pt,
        cacheRequestId_p: *mut solClient_uint64_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, test the discard indication status.\n Returns true if one or more messages have been discarded prior to the current\n message, otherwise it returns false.\n This indicates congestion discards only, and is not affected by message eliding.\n\n @see ::solClient_msg_isElidingEligible for information about message eliding.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n\n @returns        True, if the message had the discard indication set."]
    pub fn solClient_msg_isDiscardIndication(msg_p: solClient_opaqueMsg_pt) -> solClient_bool_t;
}
extern "C" {
    #[doc = " Given a msg_p, test the response attribute.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n\n @returns        True, if the message is a response to a solClient_session_sendRequest()."]
    pub fn solClient_msg_isReplyMsg(msg_p: solClient_opaqueMsg_pt) -> solClient_bool_t;
}
extern "C" {
    #[doc = " Given a msg_p, set the Dead Message Queue (DMQ) eligible property on a message. When this\n option is set, messages that expire in the network, are saved on a appliance dead message\n queue. Otherwise expired messages are discarded.\n By default the property is set to false on newly created messages.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param val      0 - clear, 1 - set.\n @returns        ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL if\n                       msg_p is invalid.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setDMQEligible(
        msg_p: solClient_opaqueMsg_pt,
        val: solClient_bool_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, test the Dead Message Queue (DMQ) eligible property.\n\n @param msg_p    solClient_opaqueMsg_pt returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n\n @returns        True, if the message has \"Dead Message Queue eligible\" property set."]
    pub fn solClient_msg_isDMQEligible(msg_p: solClient_opaqueMsg_pt) -> solClient_bool_t;
}
extern "C" {
    #[doc = " Append an application-specified suffix to the default topic destination for the Session.\n When the session is established, a unique topic destination is created for the Session.\n This topic is generated by the appliance, and the API subscribes to a wildcard extended\n topic that is derived by appending '/>' to the unique topic destination. By default,\n ::solClient_session_sendRequest automatically  adds a replyTo destination derived by\n appending '/#' to the unique topic destination.\n\n When this function is used, a delimiter ('/') and the supplied string are appended instead.\n\n @param msg_p          A solClient_opaqueMsg_pt that is returned from a previous call\n                       to solClient_msg_alloc() or received in a receive\n                       message callback.\n @param opaqueSession_p pointer to the Session the message is later used with.\n @param suffix_p       A pointer to a NULL-terminated suffix string.\n @returns              ::SOLCLIENT_OK, ::SOLCLIENT_FAIL.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setReplyToSuffix(
        msg_p: solClient_opaqueMsg_pt,
        opaqueSession_p: solClient_opaqueSession_pt,
        suffix_p: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " This utility returns the suffix of the topic string. If the received message contains a\n topic destination, and the topic begins with the session topic prefix, this utility\n returns a pointer to the string following the '/' delimiter that terminates the topic\n prefix.\n\n @param msg_p          A solClient_opaqueMsg_pt that is returned from a previous call\n                       to solClient_msg_alloc() or received in a receive\n                       message callback.\n @param opaqueSession_p A pointer to the Session the message was received on.\n @param suffix_p       A pointer to pointer location that contains pointer to a NULL-\n                       terminated suffix string on success.\n @returns              ::SOLCLIENT_OK, ::SOLCLIENT_FAIL, ::SOLCLIENT_NOT_FOUND.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getDestinationTopicSuffix(
        msg_p: solClient_opaqueMsg_pt,
        opaqueSession_p: solClient_opaqueSession_pt,
        suffix_p: *mut *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Set the reply attribute of the message. When this message is later transmitted it is\n sent as a reply even if solClient_session_sendMsg() is used instead of\n solClient_session_reply().\n\n @param msg_p          solClient_opaqueMsg_pt returned from a previous call\n                       to solClient_msg_alloc() or received in a receive\n                       message callback.\n @param isReply        A Boolean that indicates whether to set or reset the reply\n                       attribute.\n @returns              ::SOLCLIENT_OK, ::SOLCLIENT_FAIL.\n @subcodes\n @li ::SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE - Indicates that the attempt to set\n                       the reply attribute was for a message received from an older\n                       style API that has insufficient space in the binary meta header.\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setAsReplyMsg(
        msg_p: solClient_opaqueMsg_pt,
        isReply: solClient_bool_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set the ElidingEligible property on a message. Setting this property\n to true indicates that this message should be eligible for eliding. Message eliding\n enables filtering of data to avoid transmitting every single update to a subscribing\n client. It can be used to overcome slow consumers or any situation where a slower\n message rate is desired.\n\n Time-based eliding (supported in SolOS-TR) ensures that subscriber applications\n always receive only the most current update of a published topic at a rate that\n they can manage. By limiting the incoming message rate, a subscriber application\n is able to avoid a message backlog filled with outdated messages.\n\n This property does not indicate whether the message was elided or even provide\n information about the subscriber's configuration (with regards to Message Eliding).\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param elide    A Boolean that indicates whether to set or reset the Eliding Eligible\n                 attribute.\n @returns        ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL if msg_p is invalid.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setElidingEligible(
        msg_p: solClient_opaqueMsg_pt,
        elide: solClient_bool_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, test the ElidingEligible attribute.\n Does not indicate whether messages were elided or provide information about the\n subscriber profile eliding configuration.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n\n @returns        True, if the message has the Eliding Eligible attribute set."]
    pub fn solClient_msg_isElidingEligible(msg_p: solClient_opaqueMsg_pt) -> solClient_bool_t;
}
extern "C" {
    #[doc = " Create a map container in the binary attachment of the message.\n The map is a multimap in which more than one value may be associated\n with a given field name. A call to <i>solClient_container_addXyz()</i> does not\n overwrite an existing one, but adds a new one instead. To overwrite an existing\n field, the field has to been deleted and then added with a new value. To get all\n values associated with a given field name, a linear search is required.\n Any existing data is overwritten with the map that will be created by subsequent\n primitive data functions.\n The returned opaque container reference must be used for subsequent\n add functions.\n The returned map should later be closed by a call to\n ::solClient_container_closeMapStream(). However, if it is not, the map\n is automatically closed when the associated message is freed through a call to\n ::solClient_msg_free(). If the map is closed automatically, the\n application may not continue to use the map. Attempting to use a closed map\n will return an invalid pointer error (::SOLCLIENT_SUBCODE_PARAM_NULL_PTR).\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param map_p         A pointer location to receive the container pointer.\n @param size          A hint to the size (in bytes) of the map to be created. This\n                      is used to determine what size of data block to allocate.\n                      Datablocks are available in fixed sizes from\n                      ::SOLCLIENT_GLOBAL_PROP_DBQUANTASIZE_0\n                      to ::SOLCLIENT_GLOBAL_PROP_DBQUANTASIZE_4.\n                      If the data block is too small for the subsequently created map, a\n                      larger data block is allocated when necessary, and\n                      existing structured data copied into place. This\n                      reallocation can negatively affect performance.\n\n @returns             ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_createBinaryAttachmentMap(
        msg_p: solClient_opaqueMsg_pt,
        map_p: *mut solClient_opaqueContainer_pt,
        size: solClient_uint32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Create a stream container in the binary attachment of the\n message. Any existing data is overwritten\n with the stream that is created by subsequent primitive data functions.\n The returned opaque container reference must be used for subsequent\n add functions.\n The returned stream should later be closed by a call to\n ::solClient_container_closeMapStream(). However, if it is not, the stream\n is automatically closed when the associated message is freed through a call to\n ::solClient_msg_free(). If the stream is closed automatically, the\n application may not continue to use the stream. Attempting to use a closed stream\n returns an invalid pointer error (::SOLCLIENT_SUBCODE_PARAM_NULL_PTR).\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param stream_p      A pointer location to receive the container pointer.\n @param size          A hint to the size (in bytes) of the stream to be created. This\n                      is used to determine what size of data block to allocate.\n                      Datablocks are available in fixed sizes from\n                      ::SOLCLIENT_GLOBAL_PROP_DBQUANTASIZE_0\n                      to ::SOLCLIENT_GLOBAL_PROP_DBQUANTASIZE_4.\n                      If it is too small for the subsequently created stream, a\n                      larger data block is allocated when necessary and\n                      existing structured data copied into place. This\n                      reallocation can negatively affect performance.\n\n @returns             ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_createBinaryAttachmentStream(
        msg_p: solClient_opaqueMsg_pt,
        stream_p: *mut solClient_opaqueContainer_pt,
        size: solClient_uint32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Create a User Property map in the binary metadata header.\n The map is a multimap in which more than one value may be associated\n with a given field name. A call to <i>solClient_container_addXyz()</i> does not\n overwrite an existing one, but adds a new one instead. To overwrite an existing\n field, the field has to been deleted and then added with a new value. To get all\n values associated with a given field name, a linear search is required.\n Any existing data is overwritten with the map that is created by subsequent\n primitive data functions.\n It returns an opaque container reference that must be used for subsequent\n add functions.\n The returned map should later be closed by a call to\n ::solClient_container_closeMapStream(). However, if it is not, the stream\n is automatically closed when the associated message is freed through a call to\n ::solClient_msg_free(). If the stream is closed automatically, the\n application may not continue to use the stream. Attempting to use a closed stream\n returns an invalid pointer error (::SOLCLIENT_SUBCODE_PARAM_NULL_PTR).\n\n @param msg_p    solClient_opaqueMsg_pt returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param map_p         A pointer location to receive the container pointer.\n @param size          A hint to the size (in bytes) of the map to be created. This\n                      is used to determine what size of data block to allocate.\n                      Datablocks are available in fixed sizes from\n                      ::SOLCLIENT_GLOBAL_PROP_DBQUANTASIZE_0\n                      to ::SOLCLIENT_GLOBAL_PROP_DBQUANTASIZE_4.\n                      If it is too small for the subsequently created map, a\n                      larger data block is allocated when necessary, and\n                      existing structured data is copied into place. This\n                      reallocation can negatively affect performance.\n @returns             ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_createUserPropertyMap(
        msg_p: solClient_opaqueMsg_pt,
        map_p: *mut solClient_opaqueContainer_pt,
        size: solClient_uint32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Set the User Property map in the binary metadata header.\n If there is an existing User Property map,\n it is overwritten with the map that is passed as a parameter. If the application\n has any open containers referencing the existing map they are automatically closed.\n Attempting to use a closed stream returns an invalid pointer error\n (::SOLCLIENT_SUBCODE_PARAM_NULL_PTR).\n Changes made to the passed in map subsequent to this call do affect\n the user property map.\n\n @param msg_p    solClient_opaqueMsg_pt returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param map_p    An opaque container pointer for the map to set.\n @returns        ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setUserPropertyMap(
        msg_p: solClient_opaqueMsg_pt,
        map_p: solClient_opaqueContainer_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Check the binary attachment in the message for structured data.\n  If there is structured data found, either a map or steam, then the\n  opaque container required to access the data is returned.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param field_p  The address of the solClient_field_t structure where the API will\n                 returns the opaque container pointer and type.\n @param fieldSize  sizeof(solClient_field_t).\n\n @returns        ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL on failure.\n @subcodes\n @li ::SOLCLIENT_SUBCODE_NO_STRUCTURED_DATA\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getBinaryAttachmentField(
        msg_p: solClient_opaqueMsg_pt,
        field_p: *mut solClient_field_t,
        fieldSize: usize,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Returns the value of the specified message statistic.\n\n @param msgStatType The type of statistic to retrieve; one of ::solClient_msg_stats.\n @param statIndex   The zero-based index of the statistic (for example, which quanta);\n                    only used for ::SOLCLIENT_MSG_STATS_ALLOC_DATA_BLOCKS and\n                    ::SOLCLIENT_MSG_STATS_FREE_DATA_BLOCKS. This must be zero for\n                    other statistic types.\n @param statValue_p A pointer to the location to receive the statistic value from.\n\n @returns  ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL on failure.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getStat(
        msgStatType: solClient_msg_stats_t,
        statIndex: solClient_uint32_t,
        statValue_p: *mut solClient_uint64_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Display the contents of a message in human-readable form. This function creates a\n  string in application-supplied buffer that the application can log or print. If\n  the supplied buffer pointer is NULL, this function prints to STDOUT.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param buffer_p A pointer to a buffer to receive the output string. NULL means to dump\n                 to STDOUT.\n @param bufferSize The size of the memory area referenced by buffer_p. The output is\n                   truncated at this size if the buffer is not large enough. The\n                   returned string is always NULL-terminated even\n                   if truncated.\n @param flags    Flags to control the output. Possible values are:\n                      @li ::SOLCLIENT_MSGDUMP_BRIEF. Display only the length of the\n                          binary attachment, xml attachment, and user property map.\n                      @li ::SOLCLIENT_MSGDUMP_FULL. Display the entire message.\n\n  @returns            @li ::SOLCLIENT_OK on success\n                      @li ::SOLCLIENT_FAIL on failure. This function can fail if any\n                          of the parameters to the call are invalid.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_PARAM_NULL_PTR\n  @li ::SOLCLIENT_SUBCODE_PARAM_CONFLICT"]
    pub fn solClient_msg_dumpExt(
        msg_p: solClient_opaqueMsg_pt,
        buffer_p: *mut ::std::os::raw::c_char,
        bufferSize: usize,
        flags: solClient_uint32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Display the contents of a message in human-readable form. This function creates a\n  string in application-supplied buffer that the application can log or print as it\n  wishes. If the supplied buffer pointer is NULL, this function prints to STDOUT.\n  This function is equivalent to solClient_msg_dumpExt(msg_p, buffer_p, bufferSize,\n  SOLCLIENT_MSGDUMP_FULL).\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param buffer_p A pointer to a buffer to receive the output string. NULL means to dump\n                 to STDOUT.\n @param bufferSize The size of the memory area referenced by buffer_p. The output is\n                   truncated at this size if the buffer is not large enough. The\n                   returned string is always NULL-terminated even if truncated.\n\n  @returns            @li ::SOLCLIENT_OK on success.\n                      @li ::SOLCLIENT_FAIL on failure. This function can fail if any of the parameters to the\n                      call are invalid.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_PARAM_NULL_PTR\n  @li ::SOLCLIENT_SUBCODE_PARAM_CONFLICT"]
    pub fn solClient_msg_dump(
        msg_p: solClient_opaqueMsg_pt,
        buffer_p: *mut ::std::os::raw::c_char,
        bufferSize: usize,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set the optional ACK Immediately message property.\n When the ACK Immediately property is set to true on an outgoing Guaranteed Delivery message,\n it indicates that the appliance should ACK this message immediately upon receipt.\n By default the property is set to false on newly created messages.\n\n This property, when set by a publisher, may or may not be removed by the appliance prior to delivery\n to a consumer, so message consumers must not expect the property value indicates how the message was\n originally published. Therefore if a received message\n is forwarded by the application, the ACK immediately property should be explicitly set to the desired\n value (true or false).\n\n Setting this property on an outgoing direct message has no effect.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param val      A Boolean that indicates whether to set or clear the ACK Immediately message property.\n @returns        ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL if msg is invalid.\n\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setAckImmediately(
        msg_p: solClient_opaqueMsg_pt,
        val: solClient_bool_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, test if the ACK Immediately message property is set or not.\n When the ACK Immediately property is set to true on an outgoing Guaranteed Delivery message,\n it indicates that the appliance should ACK this message immediately upon receipt.\n\n This property, when set by a publisher, may or may not be removed by the appliance prior to delivery\n to a consumer, so message consumers must not expect the property value indicates how the message was\n originally published\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @returns         True, if the ACK Immediately message property is set to TRUE."]
    pub fn solClient_msg_isAckImmediately(msg_p: solClient_opaqueMsg_pt) -> solClient_bool_t;
}
extern "C" {
    #[doc = " Given a msg_p, retrieve the HTTP Content Type. On return type_p points to\n message memory and is only valid as long as msg_p is valid.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param type_p   On return, it points to message memory containing HTTP Content Type.\n @returns        ::SOLCLIENT_OK on success, ::SOLCLIENT_NOT_FOUND if the field is\n                     not present and ::SOLCLIENT_FAIL if  msg_p is invalid\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getHttpContentType(
        msg_p: solClient_opaqueMsg_pt,
        type_p: *mut *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, retrieve the HTTP Content Encoding. On return type_p points to\n message memory and is only valid as long as msg_p is valid.\n\n @param msg_p       solClient_opaqueMsg_pt that is returned from a previous call\n                    to solClient_msg_alloc() or received in a receive\n                    message callback.\n @param encoding_p  On return, it points to message memory containing HTTP Content Encoding.\n @returns           ::SOLCLIENT_OK on success, ::SOLCLIENT_NOT_FOUND if the field is\n                       not present and ::SOLCLIENT_FAIL if  msg_p is invalid\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_getHttpContentEncoding(
        msg_p: solClient_opaqueMsg_pt,
        encoding_p: *mut *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set or delete (if type_p == NULL) its HTTP Content Type.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param type_p   A pointer to a null terminated HTTP Content Type .\n @returns        ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setHttpContentType(
        msg_p: solClient_opaqueMsg_pt,
        type_p: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, set or delete (if encoding_p == NULL) its HTTP Content Encoding.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @param encoding_p     A pointer to a null terminated HTTP Content Encoding.\n @returns              ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_setHttpContentEncoding(
        msg_p: solClient_opaqueMsg_pt,
        encoding_p: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, delete the HTTP Content Type.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @returns        ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_deleteHttpContentType(
        msg_p: solClient_opaqueMsg_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Given a msg_p, delete the HTTP Content Encoding.\n\n @param msg_p    A solClient_opaqueMsg_pt that is returned from a previous call\n                 to solClient_msg_alloc() or received in a receive\n                 message callback.\n @returns        ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_msg_deleteHttpContentEncoding(
        msg_p: solClient_opaqueMsg_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Create a map container in a memory location given by the caller. It is the\n caller's responsibility to ensure that the memory pointer and size are valid. If the\n map that is created by subsequent calls to add structured data types exceeds\n <i>size</i>, the add operation fails and the error subCode is set to\n SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE.\n The map is a multimap in which more than one value may be associated with a given field\n name.\n A call to <i>solClient_container_addXyz()</i> does not\n overwrite an existing field, instead it adds a new one. To overwrite an existing\n field, the field has to been deleted and then added with a new value. To get all\n values associated with a given field name, a linear search is required.\n Any existing data is overwritten with the map that is created by subsequent\n primitive data functions. The returned opaque container reference must be used for\n subsequent add functions. In addition, the returned opaque container can itself be\n added to other containers or directly to a message binary attachment part.\n The returned map must later be closed by a call to\n ::solClient_container_closeMapStream().\n\n @param newContainer_p         A pointer location to receive the container pointer.\n @param mem_p         A pointer to memory that is used to build the map.\n @param size          The maximum size of the map to be created.\n\n @returns             ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_createMap(
        newContainer_p: *mut solClient_opaqueContainer_pt,
        mem_p: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " This function creates a stream container in a memory location given by the caller. It\n is the caller's responsibility to ensure that the memory pointer and size are valid.\n If the stream that is built by subsequent calls to add structured data types exceeds\n the specified maximum <i>size</i>, the add operation fails and the error subCode is\n set to SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE.\n Any existing data is overwritten with the stream that is created by subsequent\n primitive data functions. The returned opaque container reference must be used for\n subsequent add functions. In addition, the returned opaque container itself can be\n added to other containers or directly to a message binary attachment part.\n The returned stream must later be closed by a call to\n ::solClient_container_closeMapStream().\n\n @param newContainer_p         A pointer location to receive the container pointer.\n @param mem_p         A pointer to memory that is used to build the stream.\n @param size          The maximum size of the stream to be created.\n\n @returns             ::SOLCLIENT_OK, ::SOLCLIENT_FAIL\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_createStream(
        newContainer_p: *mut solClient_opaqueContainer_pt,
        mem_p: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Open a nested subMap. The subMap is a multimap in which more than one value may be\n associated with a given field name. This is a special add function to create a map in\n an existing container. It returns a new solClient_opaqueContainer_pt that\n can be used to build a map using addXXX function. It is possible to add to\n the original container; however, this can cause extensive data moving\n operations when the subMap is later closed by a call to\n ::solClient_container_closeMapStream. It is more efficient to write the subMap\n completely and close it before writing again to the original container.\n The returned map should later be closed by a call to\n ::solClient_container_closeMapStream(). However, if it is not, the map\n is automatically closed when the associated message is freed through a call to\n ::solClient_msg_free(), or if the parent container is closed.\n If the map is closed automatically, the\n application may not continue to use the map. Attempting to use a closed map\n returns an invalid pointer error (::SOLCLIENT_SUBCODE_PARAM_NULL_PTR).\n\n @param container_p  An opaque container pointer.\n @param newContainer_p A pointer to memory to receive returned opaque\n                     container pointer.\n @param name         The name of the Map if the container_ is Map, must be\n                     NULL if container_p references a Stream.\n @returns            ::SOLCLIENT_OK on success. ::SOLCLIENT_FAIL on\n                     failure.\n @subcodes\n  @li ::SOLCLIENT_SUBCODE_PARAM_NULL_PTR     - The opaque container pointer is invalid, or the container is a map and the field name\n                      pointer is invalid.\n  @li ::SOLCLIENT_SUBCODE_PARAM_OUT_OF_RANGE - The container is a stream and the field name pointer is non-null.\n  @li ::SOLCLIENT_SUBCODE_OUT_OF_MEMORY      - The container created by solClient_msg_createBinaryAttachmentMap(),\n                      or solClient_msg_createBinaryAttachmentStream(), or solClient_msg_createUserPropertyMap() has consumed all available\n                      space in the @ref solclientmsg \"message buffer\" and the API is unable to allocate more memory from the operating\n                      system heap.\n  @li ::SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE - The container created by solClient_container_createMap() or solClient_container_createStream()\n                      has consumed all available space in the buffer. <b>NOTE:</b> This error can occur when such a container has an open\n                      subcontainer; until the open subcontainer is closed, this function will fail and set this subcode. This does not\n                      occur on containers created in @ref solclientmsg as memory can be dynamically allocated.\n\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_openSubMap(
        container_p: solClient_opaqueContainer_pt,
        newContainer_p: *mut solClient_opaqueContainer_pt,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Open a nested subStream. This is a special 'add' function to create a stream in\n an existing container. It returns a new solClient_opaqueContainer_pt that\n may be used to build a stream using addXXX function. It is possible to add to\n the original container; however, this can cause extensive data moving\n operations when the subStream is later closed by a call to\n ::solClient_container_closeMapStream. It is more efficient to write the subStream\n completely and close it before writing again to the original container.\n The returned stream should later be closed by a call to\n ::solClient_container_closeMapStream(). However, if it is not, the stream\n is automatically closed when the associated message is freed by a call to\n ::solClient_msg_free(), or if the parent container is closed.\n If the stream is closed automatically, the\n application may not continue to use the stream. Attempting to use a closed stream\n will return an invalid pointer error (::SOLCLIENT_SUBCODE_PARAM_NULL_PTR).\n\n @param container_p  An opaque container pointer.\n @param newContainer_p A pointer to memory to receive returned opaque\n                     container pointer.\n @param name         The name of the stream if the container_p is a map; it must be\n                     NULL if container_p references a stream.\n @returns            ::SOLCLIENT_OK on success. ::SOLCLIENT_FAIL on\n                     failure.\n @subcodes\n  @li ::SOLCLIENT_SUBCODE_PARAM_NULL_PTR     - The opaque container pointer is invalid, or the container is a map and the field name\n                      pointer is invalid.\n  @li ::SOLCLIENT_SUBCODE_PARAM_OUT_OF_RANGE - The container is a stream and the field name pointer is non-null.\n  @li ::SOLCLIENT_SUBCODE_OUT_OF_MEMORY      - The container created by solClient_msg_createBinaryAttachmentMap(),\n                      or solClient_msg_createBinaryAttachmentStream(), or solClient_msg_createUserPropertyMap() has consumed all available\n                      space in the @ref solclientmsg \"message buffer\" and the API is unable to allocate more memory from the operating\n                      system heap.\n  @li ::SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE - The container created by solClient_container_createMap() or solClient_container_createStream()\n                      has consumed all available space in the buffer. <b>NOTE:</b> This error can occur when such a container has an open\n                      subcontainer; until the open subcontainer is closed, this function will fail and set this subcode. This does not\n                      occur on containers created in @ref solclientmsg as memory can be dynamically allocated.\n\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_openSubStream(
        container_p: solClient_opaqueContainer_pt,
        newContainer_p: *mut solClient_opaqueContainer_pt,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Finish a map or stream. This action makes the opaque container\n pointer invalid and fixes the structured data in memory.\n\n  @param container_p  A pointer to the opaque container pointer. The pointer is\n                      reset to NULL on return.\n\n  @returns            ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL on failure.\n @subcodes\n @li ::SOLCLIENT_SUBCODE_CONTAINER_BUSY\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_closeMapStream(
        container_p: *mut solClient_opaqueContainer_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Add a NULL to a map or stream. If the container is a stream, the\n  name parameter must be NULL. If the container is a map, the name parameter\n  must be non-NULL. @see @ref msgMaps\n\n  @param container_p  An opaque container pointer.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @see @ref encoding-overhead\n  @returns            ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL on failure.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_PARAM_NULL_PTR     - The opaque container pointer is invalid, or the container is a map and the field name\n                      pointer is invalid.\n  @li ::SOLCLIENT_SUBCODE_PARAM_OUT_OF_RANGE - The container is a stream and the field name pointer is non-null.\n  @li ::SOLCLIENT_SUBCODE_OUT_OF_MEMORY      - The container created by solClient_msg_createBinaryAttachmentMap(),\n                      or solClient_msg_createBinaryAttachmentStream(), or solClient_msg_createUserPropertyMap() has consumed all available\n                      space in the @ref solclientmsg \"message buffer\" and the API is unable to allocate more memory from the operating\n                      system heap.\n  @li ::SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE - The container created by solClient_container_createMap() or solClient_container_createStream()\n                      has consumed all available space in the buffer. <b>NOTE:</b> This error can occur when such a container has an open\n                      subcontainer; until the open subcontainer is closed, this function will fail and set this subcode. This does not\n                      occur on containers created in @ref solclientmsg as memory can be dynamically allocated.\n\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_addNull(
        container_p: solClient_opaqueContainer_pt,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Add a Boolean value to a map or stream. If the container is a stream, the\n  name parameter must be NULL. If the container is a map, the name parameter\n  must be non-NULL. @see @ref msgMaps.\n\n  @param container_p  An opaque container pointer.\n  @param value        A Boolean value. Any non-zero value is encoded\n                      as 1.\n  @param name         The name of a field for a Map. This parameter must be NULL for a stream.\n\n  @see @ref encoding-overhead\n  @returns            ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL on failure.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_PARAM_NULL_PTR     - The opaque container pointer is invalid, or the container is a map and the field name\n                      pointer is invalid.\n  @li ::SOLCLIENT_SUBCODE_PARAM_OUT_OF_RANGE - The container is a stream and the field name pointer is non-null.\n  @li ::SOLCLIENT_SUBCODE_OUT_OF_MEMORY      - The container created by solClient_msg_createBinaryAttachmentMap(),\n                      or solClient_msg_createBinaryAttachmentStream(), or solClient_msg_createUserPropertyMap() has consumed all available\n                      space in the @ref solclientmsg \"message buffer\" and the API is unable to allocate more memory from the operating\n                      system heap.\n  @li ::SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE - The container created by solClient_container_createMap() or solClient_container_createStream()\n                      has consumed all available space in the buffer. <b>NOTE:</b> This error can occur when such a container has an open\n                      subcontainer; until the open subcontainer is closed, this function will fail and set this subcode. This does not\n                      occur on containers created in @ref solclientmsg as memory can be dynamically allocated.\n\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_addBoolean(
        container_p: solClient_opaqueContainer_pt,
        value: solClient_bool_t,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Add a unsigned 8-bit value to a map or stream. If the container is a stream, the\n  name parameter must be NULL. If the container is a map, the name parameter\n  must be non-NULL. @see @ref msgMaps\n\n  @param container_p  An opaque container pointer.\n  @param value        An unsigned 8-bit value.\n  @param name        The name of a field for a map. This parameter must be NULL for a stream.\n\n  @see @ref encoding-overhead\n  @returns            ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL on failure.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_PARAM_NULL_PTR     - The opaque container pointer is invalid, or the container is a map and the field name\n                      pointer is invalid.\n  @li ::SOLCLIENT_SUBCODE_PARAM_OUT_OF_RANGE - The container is a stream and the field name pointer is non-null.\n  @li ::SOLCLIENT_SUBCODE_OUT_OF_MEMORY      - The container created by solClient_msg_createBinaryAttachmentMap(),\n                      or solClient_msg_createBinaryAttachmentStream(), or solClient_msg_createUserPropertyMap() has consumed all available\n                      space in the @ref solclientmsg \"message buffer\" and the API is unable to allocate more memory from the operating\n                      system heap.\n  @li ::SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE - The container created by solClient_container_createMap() or solClient_container_createStream()\n                      has consumed all available space in the buffer. <b>NOTE:</b> This error can occur when such a container has an open\n                      subcontainer; until the open subcontainer is closed, this function will fail and set this subcode. This does not\n                      occur on containers created in @ref solclientmsg as memory can be dynamically allocated.\n\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_addUint8(
        container_p: solClient_opaqueContainer_pt,
        value: solClient_uint8_t,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Add a signed 8-bit value to a map or stream. If the container is a stream, the\n  name parameter must be NULL. If the container is a map, the name parameter\n  must be non-NULL. @see @ref msgMaps\n\n  @param container_p  An opaque container pointer.\n  @param value         A signed 8-bit value.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @see @ref encoding-overhead\n  @returns            ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL on failure.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_PARAM_NULL_PTR     - The opaque container pointer is invalid, or the container is a map and the field name\n                      pointer is invalid.\n  @li ::SOLCLIENT_SUBCODE_PARAM_OUT_OF_RANGE - The container is a stream and the field name pointer is non-null.\n  @li ::SOLCLIENT_SUBCODE_OUT_OF_MEMORY      - The container created by solClient_msg_createBinaryAttachmentMap(),\n                      or solClient_msg_createBinaryAttachmentStream(), or solClient_msg_createUserPropertyMap() has consumed all available\n                      space in the @ref solclientmsg \"message buffer\" and the API is unable to allocate more memory from the operating\n                      system heap.\n  @li ::SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE - The container created by solClient_container_createMap() or solClient_container_createStream()\n                      has consumed all available space in the buffer. <b>NOTE:</b> This error can occur when such a container has an open\n                      subcontainer; until the open subcontainer is closed, this function will fail and set this subcode. This does not\n                      occur on containers created in @ref solclientmsg as memory can be dynamically allocated.\n\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_addInt8(
        container_p: solClient_opaqueContainer_pt,
        value: solClient_int8_t,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Add an unsigned 16-bit value to a map or stream. If the container is a stream, the\n  name parameter must be NULL. If the container is a map, the name parameter\n  must be non-NULL. @see @ref msgMaps\n\n  @param container_p  An opaque container pointer.\n  @param value        An unsigned 16-bit.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @see @ref encoding-overhead\n  @returns            ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL on failure.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_PARAM_NULL_PTR     - The opaque container pointer is invalid, or the container is a map and the field name\n                      pointer is invalid.\n  @li ::SOLCLIENT_SUBCODE_PARAM_OUT_OF_RANGE - The container is a stream and the field name pointer is non-null.\n  @li ::SOLCLIENT_SUBCODE_OUT_OF_MEMORY      - The container created by solClient_msg_createBinaryAttachmentMap(),\n                      or solClient_msg_createBinaryAttachmentStream(), or solClient_msg_createUserPropertyMap() has consumed all available\n                      space in the @ref solclientmsg \"message buffer\" and the API is unable to allocate more memory from the operating\n                      system heap.\n  @li ::SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE - The container created by solClient_container_createMap() or solClient_container_createStream()\n                      has consumed all available space in the buffer. <b>NOTE:</b> This error can occur when such a container has an open\n                      subcontainer; until the open subcontainer is closed, this function will fail and set this subcode. This does not\n                      occur on containers created in @ref solclientmsg as memory can be dynamically allocated.\n\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_addUint16(
        container_p: solClient_opaqueContainer_pt,
        value: solClient_uint16_t,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Add a signed 16-bit value to a map or stream. If the container is a stream, the\n  name parameter must be NULL. If the container is a map, the name parameter\n  must be non-NULL. @see @ref msgMaps\n\n  @param container_p  An opaque container pointer.\n  @param value        A signed 16-bit value.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @see @ref encoding-overhead\n  @returns            ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL on failure.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_PARAM_NULL_PTR     - The opaque container pointer is invalid, or the container is a map and the field name\n                      pointer is invalid.\n  @li ::SOLCLIENT_SUBCODE_PARAM_OUT_OF_RANGE - The container is a stream and the field name pointer is non-null.\n  @li ::SOLCLIENT_SUBCODE_OUT_OF_MEMORY      - The container created by solClient_msg_createBinaryAttachmentMap(),\n                      or solClient_msg_createBinaryAttachmentStream(), or solClient_msg_createUserPropertyMap() has consumed all available\n                      space in the @ref solclientmsg \"message buffer\" and the API is unable to allocate more memory from the operating\n                      system heap.\n  @li ::SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE - The container created by solClient_container_createMap() or solClient_container_createStream()\n                      has consumed all available space in the buffer. <b>NOTE:</b> This error can occur when such a container has an open\n                      subcontainer; until the open subcontainer is closed, this function will fail and set this subcode. This does not\n                      occur on containers created in @ref solclientmsg as memory can be dynamically allocated.\n\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_addInt16(
        container_p: solClient_opaqueContainer_pt,
        value: solClient_int16_t,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Add an unsigned 32-bit value to a map or stream. If the container is a stream, the\n  name parameter must be NULL. If the container is a map, the name parameter\n  must be non-NULL. @see @ref msgMaps\n\n  @param container_p  An opaque container pointer.\n  @param value        An unsigned 32-bit value.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @see @ref encoding-overhead\n  @returns            ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL on failure.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_PARAM_NULL_PTR     - The opaque container pointer is invalid, or the container is a map and the field name\n                      pointer is invalid.\n  @li ::SOLCLIENT_SUBCODE_PARAM_OUT_OF_RANGE - The container is a stream and the field name pointer is non-null.\n  @li ::SOLCLIENT_SUBCODE_OUT_OF_MEMORY      - The container created by solClient_msg_createBinaryAttachmentMap(),\n                      or solClient_msg_createBinaryAttachmentStream(), or solClient_msg_createUserPropertyMap() has consumed all available\n                      space in the @ref solclientmsg \"message buffer\" and the API is unable to allocate more memory from the operating\n                      system heap.\n  @li ::SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE - The container created by solClient_container_createMap() or solClient_container_createStream()\n                      has consumed all available space in the buffer. <b>NOTE:</b> This error can occur when such a container has an open\n                      subcontainer; until the open subcontainer is closed, this function will fail and set this subcode. This does not\n                      occur on containers created in @ref solclientmsg as memory can be dynamically allocated.\n\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_addUint32(
        container_p: solClient_opaqueContainer_pt,
        value: solClient_uint32_t,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Add a signed 32-bit value to a map or stream. If the container is a stream, the\n  name parameter must be NULL. If the container is a map, the name parameter\n  must be non-NULL. @see @ref msgMaps\n\n  @param container_p  An opaque container pointer.\n  @param value        A signed 32-bit value.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @see @ref encoding-overhead\n  @returns            ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL on failure.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_PARAM_NULL_PTR     - The opaque container pointer is invalid, or the container is a map and the field name\n                      pointer is invalid.\n  @li ::SOLCLIENT_SUBCODE_PARAM_OUT_OF_RANGE - The container is a stream and the field name pointer is non-null.\n  @li ::SOLCLIENT_SUBCODE_OUT_OF_MEMORY      - The container created by solClient_msg_createBinaryAttachmentMap(),\n                      or solClient_msg_createBinaryAttachmentStream(), or solClient_msg_createUserPropertyMap() has consumed all available\n                      space in the @ref solclientmsg \"message buffer\" and the API is unable to allocate more memory from the operating\n                      system heap.\n  @li ::SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE - The container created by solClient_container_createMap() or solClient_container_createStream()\n                      has consumed all available space in the buffer. <b>NOTE:</b> This error can occur when such a container has an open\n                      subcontainer; until the open subcontainer is closed, this function will fail and set this subcode. This does not\n                      occur on containers created in @ref solclientmsg as memory can be dynamically allocated.\n\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_addInt32(
        container_p: solClient_opaqueContainer_pt,
        value: solClient_int32_t,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Add a unsigned 64-bit value to a map or stream. If the container is a stream, the\n  name parameter must be NULL. If the container is a map, the name parameter\n  must be non-NULL. @see @ref msgMaps\n\n  @param container_p  An opaque container pointer.\n  @param value        An unsigned 64-bit value.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @see @ref encoding-overhead\n  @returns            ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL on failure.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_PARAM_NULL_PTR     - The opaque container pointer is invalid, or the container is a map and the field name\n                      pointer is invalid.\n  @li ::SOLCLIENT_SUBCODE_PARAM_OUT_OF_RANGE - The container is a stream and the field name pointer is non-null.\n  @li ::SOLCLIENT_SUBCODE_OUT_OF_MEMORY      - The container created by solClient_msg_createBinaryAttachmentMap(),\n                      or solClient_msg_createBinaryAttachmentStream(), or solClient_msg_createUserPropertyMap() has consumed all available\n                      space in the @ref solclientmsg \"message buffer\" and the API is unable to allocate more memory from the operating\n                      system heap.\n  @li ::SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE - The container created by solClient_container_createMap() or solClient_container_createStream()\n                      has consumed all available space in the buffer. <b>NOTE:</b> This error can occur when such a container has an open\n                      subcontainer; until the open subcontainer is closed, this function will fail and set this subcode. This does not\n                      occur on containers created in @ref solclientmsg as memory can be dynamically allocated.\n\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_addUint64(
        container_p: solClient_opaqueContainer_pt,
        value: solClient_uint64_t,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Add a signed 64-bit value to a map or stream. If the container is a stream, the\n  name parameter must be NULL. If the container is a map, the name parameter\n  must be non-NULL. @see @ref msgMaps\n\n  @param container_p  An opaque container pointer.\n  @param value        A signed 64-bit value.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @see @ref encoding-overhead\n  @returns            ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL on failure.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_PARAM_NULL_PTR     - The opaque container pointer is invalid, or the container is a map and the field name\n                      pointer is invalid.\n  @li ::SOLCLIENT_SUBCODE_PARAM_OUT_OF_RANGE - The container is a stream and the field name pointer is non-null.\n  @li ::SOLCLIENT_SUBCODE_OUT_OF_MEMORY      - The container created by solClient_msg_createBinaryAttachmentMap(),\n                      or solClient_msg_createBinaryAttachmentStream(), or solClient_msg_createUserPropertyMap() has consumed all available\n                      space in the @ref solclientmsg \"message buffer\" and the API is unable to allocate more memory from the operating\n                      system heap.\n  @li ::SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE - The container created by solClient_container_createMap() or solClient_container_createStream()\n                      has consumed all available space in the buffer. <b>NOTE:</b> This error can occur when such a container has an open\n                      subcontainer; until the open subcontainer is closed, this function will fail and set this subcode. This does not\n                      occur on containers created in @ref solclientmsg as memory can be dynamically allocated.\n\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_addInt64(
        container_p: solClient_opaqueContainer_pt,
        value: solClient_int64_t,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Add an ASCII character to a map or stream. If the container is a stream, the\n  name parameter must be NULL. If the container is a map, the name parameter\n  must be non-NULL. @see @ref msgMaps\n\n  @param container_p  An opaque container pointer.\n  @param value        An ASCII character.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @see @ref encoding-overhead\n  @returns            ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL on failure.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_PARAM_NULL_PTR     - The opaque container pointer is invalid, or the container is a map and the field name\n                      pointer is invalid.\n  @li ::SOLCLIENT_SUBCODE_PARAM_OUT_OF_RANGE - The container is a stream and the field name pointer is non-null.\n  @li ::SOLCLIENT_SUBCODE_OUT_OF_MEMORY      - The container created by solClient_msg_createBinaryAttachmentMap(),\n                      or solClient_msg_createBinaryAttachmentStream(), or solClient_msg_createUserPropertyMap() has consumed all available\n                      space in the @ref solclientmsg \"message buffer\" and the API is unable to allocate more memory from the operating\n                      system heap.\n  @li ::SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE - The container created by solClient_container_createMap() or solClient_container_createStream()\n                      has consumed all available space in the buffer. <b>NOTE:</b> This error can occur when such a container has an open\n                      subcontainer; until the open subcontainer is closed, this function will fail and set this subcode. This does not\n                      occur on containers created in @ref solclientmsg as memory can be dynamically allocated.\n\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_addChar(
        container_p: solClient_opaqueContainer_pt,
        value: ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Add a unicode (wide) character to a map or stream. If the container is a stream, the\n  name parameter must be NULL. If the container is a map, the name parameter\n  must be non-NULL. @see @ref msgMaps\n\n  @param container_p  An opaque container pointer.\n  @param value        A 16-bit unicode character.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @see @ref encoding-overhead\n  @returns            ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL on failure.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_PARAM_NULL_PTR     - The opaque container pointer is invalid, or the container is a map and the field name\n                      pointer is invalid.\n  @li ::SOLCLIENT_SUBCODE_PARAM_OUT_OF_RANGE - The container is a stream and the field name pointer is non-null.\n  @li ::SOLCLIENT_SUBCODE_OUT_OF_MEMORY      - The container created by solClient_msg_createBinaryAttachmentMap(),\n                      or solClient_msg_createBinaryAttachmentStream(), or solClient_msg_createUserPropertyMap() has consumed all available\n                      space in the @ref solclientmsg \"message buffer\" and the API is unable to allocate more memory from the operating\n                      system heap.\n  @li ::SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE - The container created by solClient_container_createMap() or solClient_container_createStream()\n                      has consumed all available space in the buffer. <b>NOTE:</b> This error can occur when such a container has an open\n                      subcontainer; until the open subcontainer is closed, this function will fail and set this subcode. This does not\n                      occur on containers created in @ref solclientmsg as memory can be dynamically allocated.\n\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_addWchar(
        container_p: solClient_opaqueContainer_pt,
        value: solClient_wchar_t,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Add a byte array to a map or stream. If the container is a stream, the\n  name parameter must be NULL. If the container is a map, the name parameter\n  must be non-NULL. @see @ref msgMaps\n\n  @param container_p  An opaque container pointer.\n  @param arr_p        A pointer to the byte array.\n  @param length       The length of the byte array.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @see @ref encoding-overhead\n  @returns            ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL on failure.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_PARAM_NULL_PTR     - The opaque container pointer is invalid, or the container is a map and the field name\n                      pointer is invalid.\n  @li ::SOLCLIENT_SUBCODE_PARAM_OUT_OF_RANGE - The container is a stream and the field name pointer is non-null.\n  @li ::SOLCLIENT_SUBCODE_OUT_OF_MEMORY      - The container created by solClient_msg_createBinaryAttachmentMap(),\n                      or solClient_msg_createBinaryAttachmentStream(), or solClient_msg_createUserPropertyMap() has consumed all available\n                      space in the @ref solclientmsg \"message buffer\" and the API is unable to allocate more memory from the operating\n                      system heap.\n  @li ::SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE - The container created by solClient_container_createMap() or solClient_container_createStream()\n                      has consumed all available space in the buffer. <b>NOTE:</b> This error can occur when such a container has an open\n                      subcontainer; until the open subcontainer is closed, this function will fail and set this subcode. This does not\n                      occur on containers created in @ref solclientmsg as memory can be dynamically allocated.\n\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_addByteArray(
        container_p: solClient_opaqueContainer_pt,
        arr_p: *const solClient_uint8_t,
        length: solClient_uint32_t,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Add a Solace Message Format (SMF) message to a map or stream. If the container is a stream, the\n  name parameter must be NULL. If the container is a map, the name parameter\n  must be non-NULL. @see @ref msgMaps\n\n  @param container_p  An opaque container pointer.\n  @param smf_p        A pointer to the SMF message.\n  @param length       The length of the SMF message.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @see @ref encoding-overhead\n  @returns            ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL on failure.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_PARAM_NULL_PTR     - The opaque container pointer is invalid, or the container is a map and the field name\n                      pointer is invalid.\n  @li ::SOLCLIENT_SUBCODE_PARAM_OUT_OF_RANGE - The container is a stream and the field name pointer is non-null.\n  @li ::SOLCLIENT_SUBCODE_OUT_OF_MEMORY      - The container created by solClient_msg_createBinaryAttachmentMap(),\n                      or solClient_msg_createBinaryAttachmentStream(), or solClient_msg_createUserPropertyMap() has consumed all available\n                      space in the @ref solclientmsg \"message buffer\" and the API is unable to allocate more memory from the operating\n                      system heap.\n  @li ::SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE - The container created by solClient_container_createMap() or solClient_container_createStream()\n                      has consumed all available space in the buffer. <b>NOTE:</b> This error can occur when such a container has an open\n                      subcontainer; until the open subcontainer is closed, this function will fail and set this subcode. This does not\n                      occur on containers created in @ref solclientmsg as memory can be dynamically allocated.\n\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_addSmf(
        container_p: solClient_opaqueContainer_pt,
        smf_p: *const solClient_uint8_t,
        length: solClient_uint32_t,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Add an existing container to a map or stream. If the container being added to is a stream, the\n  name parameter must be NULL. If the container is a map, the name parameter\n  must be non-NULL.\n  This is a copy-in operation. Changing the subContainer after calling this function will not\n  be reflected in the copy created by this function. @see @ref msgMaps\n\n  @param container_p  An opaque container pointer.\n  @param subContainer_p  An opaque container pointer for the container to add.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @see @ref encoding-overhead\n  @returns            ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL on failure.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_PARAM_NULL_PTR     - The opaque container pointer is invalid, or the container is a map and the field name\n                      pointer is invalid.\n  @li ::SOLCLIENT_SUBCODE_PARAM_OUT_OF_RANGE - The container is a stream and the field name pointer is non-null.\n  @li ::SOLCLIENT_SUBCODE_OUT_OF_MEMORY      - The container created by solClient_msg_createBinaryAttachmentMap(),\n                      or solClient_msg_createBinaryAttachmentStream(), or solClient_msg_createUserPropertyMap() has consumed all available\n                      space in the @ref solclientmsg \"message buffer\" and the API is unable to allocate more memory from the operating\n                      system heap.\n  @li ::SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE - The container created by solClient_container_createMap() or solClient_container_createStream()\n                      has consumed all available space in the buffer. <b>NOTE:</b> This error can occur when such a container has an open\n                      subcontainer; until the open subcontainer is closed, this function will fail and set this subcode. This does not\n                      occur on containers created in @ref solclientmsg as memory can be dynamically allocated.\n\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_addContainer(
        container_p: solClient_opaqueContainer_pt,
        subContainer_p: solClient_opaqueContainer_pt,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Add a 32-bit floating point number to a map or stream. If the container is a stream, the\n  name parameter must be NULL. If the container is a map, the name parameter\n  must be non-NULL. @see @ref msgMaps\n\n  @param container_p  An opaque container pointer.\n  @param value        A 32-bit floating point number\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @see @ref encoding-overhead\n  @returns            ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL on failure.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_PARAM_NULL_PTR     - The opaque container pointer is invalid, or the container is a map and the field name\n                      pointer is invalid.\n  @li ::SOLCLIENT_SUBCODE_PARAM_OUT_OF_RANGE - The container is a stream and the field name pointer is non-null.\n  @li ::SOLCLIENT_SUBCODE_OUT_OF_MEMORY      - The container created by solClient_msg_createBinaryAttachmentMap(),\n                      or solClient_msg_createBinaryAttachmentStream(), or solClient_msg_createUserPropertyMap() has consumed all available\n                      space in the @ref solclientmsg \"message buffer\" and the API is unable to allocate more memory from the operating\n                      system heap.\n  @li ::SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE - The container created by solClient_container_createMap() or solClient_container_createStream()\n                      has consumed all available space in the buffer. <b>NOTE:</b> This error can occur when such a container has an open\n                      subcontainer; until the open subcontainer is closed, this function will fail and set this subcode. This does not\n                      occur on containers created in @ref solclientmsg as memory can be dynamically allocated.\n\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_addFloat(
        container_p: solClient_opaqueContainer_pt,
        value: f32,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Add a 64-bit floating point number to a map or stream. If the container is a stream, the\n  name parameter must be NULL. If the container is a map, the name parameter\n  must be non-NULL. @see @ref msgMaps\n\n  @param container_p  An opaque container pointer.\n  @param value        A 64-bit floating point number\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @see @ref encoding-overhead\n  @returns            ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL on failure.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_PARAM_NULL_PTR     - The opaque container pointer is invalid, or the container is a map and the field name\n                      pointer is invalid.\n  @li ::SOLCLIENT_SUBCODE_PARAM_OUT_OF_RANGE - The container is a stream and the field name pointer is non-null.\n  @li ::SOLCLIENT_SUBCODE_OUT_OF_MEMORY      - The container created by solClient_msg_createBinaryAttachmentMap(),\n                      or solClient_msg_createBinaryAttachmentStream(), or solClient_msg_createUserPropertyMap() has consumed all available\n                      space in the @ref solclientmsg \"message buffer\" and the API is unable to allocate more memory from the operating\n                      system heap.\n  @li ::SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE - The container created by solClient_container_createMap() or solClient_container_createStream()\n                      has consumed all available space in the buffer. <b>NOTE:</b> This error can occur when such a container has an open\n                      subcontainer; until the open subcontainer is closed, this function will fail and set this subcode. This does not\n                      occur on containers created in @ref solclientmsg as memory can be dynamically allocated.\n\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_addDouble(
        container_p: solClient_opaqueContainer_pt,
        value: f64,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Add a null terminated string (ASCII or UTF-8) to a map or stream. If the container is a stream, the\n  name parameter must be NULL. If the container is a map, the name parameter\n  must be non-NULL. @see @ref msgMaps\n\n  @param container_p  An opaque container pointer.\n  @param value        A pointer to a NULL-terminated string.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @see @ref encoding-overhead\n  @returns            ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL on failure.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_PARAM_NULL_PTR     - The opaque container pointer is invalid, or the container is a map and the field name\n                      pointer is invalid.\n  @li ::SOLCLIENT_SUBCODE_PARAM_OUT_OF_RANGE - The container is a stream and the field name pointer is non-null.\n  @li ::SOLCLIENT_SUBCODE_OUT_OF_MEMORY      - The container created by solClient_msg_createBinaryAttachmentMap(),\n                      or solClient_msg_createBinaryAttachmentStream(), or solClient_msg_createUserPropertyMap() has consumed all available\n                      space in the @ref solclientmsg \"message buffer\" and the API is unable to allocate more memory from the operating\n                      system heap.\n  @li ::SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE - The container created by solClient_container_createMap() or solClient_container_createStream()\n                      has consumed all available space in the buffer. <b>NOTE:</b> This error can occur when such a container has an open\n                      subcontainer; until the open subcontainer is closed, this function will fail and set this subcode. This does not\n                      occur on containers created in @ref solclientmsg as memory can be dynamically allocated.\n\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_addString(
        container_p: solClient_opaqueContainer_pt,
        value: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Add a Solace destination (queue or topic) to the container. If the\n  container is a stream, the\n  name parameter must be NULL. If the container is a map, the name parameter\n  must be non-NULL. @see @ref msgMaps\n\n  @param container_p  An opaque container pointer.\n  @param value        A pointer to a solClient_destination_t.\n  @param destSize     The size of solClient_destination_t\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @see @ref encoding-overhead\n  @returns            ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL on failure.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_PARAM_NULL_PTR     - The opaque container pointer is invalid, or the container is a map and the field name\n                      pointer is invalid.\n  @li ::SOLCLIENT_SUBCODE_PARAM_OUT_OF_RANGE - The container is a stream and the field name pointer is non-null.\n  @li ::SOLCLIENT_SUBCODE_OUT_OF_MEMORY      - The container created by solClient_msg_createBinaryAttachmentMap(),\n                      or solClient_msg_createBinaryAttachmentStream(), or solClient_msg_createUserPropertyMap() has consumed all available\n                      space in the @ref solclientmsg \"message buffer\" and the API is unable to allocate more memory from the operating\n                      system heap.\n  @li ::SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE - The container created by solClient_container_createMap() or solClient_container_createStream()\n                      has consumed all available space in the buffer. <b>NOTE:</b> This error can occur when such a container has an open\n                      subcontainer; until the open subcontainer is closed, this function will fail and set this subcode. This does not\n                      occur on containers created in @ref solclientmsg as memory can be dynamically allocated.\n\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_addDestination(
        container_p: solClient_opaqueContainer_pt,
        value: *const solClient_destination_t,
        destSize: usize,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Add an application-defined field to the container. The field must be properly\n  encoded according to the Solace-defined machine-independent coding rules.\n  Typically, this function is only used by forwarding applications that need to\n  forward unrecognized fields discovered by solClient_container_getField (field type is ::SOLCLIENT_UNKNOWN).\n  If the container is a stream, the name parameter must be NULL. If the container is a map, the\n  name parameter must be non-NULL. @see @ref msgMaps\n\n  @param container_p  An opaque container pointer.\n  @param field_p      A pointer to a byte array containing the encoded field.\n  @param length       The length of the field.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @see @ref encoding-overhead\n  @returns            ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL on failure.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_PARAM_NULL_PTR     - The opaque container pointer is invalid, or the container is a map and the field name\n                      pointer is invalid.\n  @li ::SOLCLIENT_SUBCODE_PARAM_OUT_OF_RANGE - The container is a stream and the field name pointer is non-null.\n  @li ::SOLCLIENT_SUBCODE_OUT_OF_MEMORY      - The container created by solClient_msg_createBinaryAttachmentMap(),\n                      or solClient_msg_createBinaryAttachmentStream(), or solClient_msg_createUserPropertyMap() has consumed all available\n                      space in the @ref solclientmsg \"message buffer\" and the API is unable to allocate more memory from the operating\n                      system heap.\n  @li ::SOLCLIENT_SUBCODE_INSUFFICIENT_SPACE - The container created by solClient_container_createMap() or solClient_container_createStream()\n                      has consumed all available space in the buffer. <b>NOTE:</b> This error can occur when such a container has an open\n                      subcontainer; until the open subcontainer is closed, this function will fail and set this subcode. This does not\n                      occur on containers created in @ref solclientmsg as memory can be dynamically allocated.\n\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_addUnknownField(
        container_p: solClient_opaqueContainer_pt,
        field_p: *const solClient_uint8_t,
        length: usize,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Rewind a container.\n\n Rewind the stream or map so that the getting of fields can be started over from\n the start of the stream or map.\n\n  @param container_p  An opaque container pointer.\n  @returns            ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL on failure.\n  @subcodes\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_rewind(
        container_p: solClient_opaqueContainer_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " When iterating through a container (a map or stream), this function will return false when\n the end of the container is reached without advancing the read cursor. It will return true\n otherwise.\n @param container_p An opaque container pointer.\n @returns   TRUE, if there is a next field in the container; FALSE, otherwise.\n @subcodes\n @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_hasNextField(
        container_p: solClient_opaqueContainer_pt,
    ) -> solClient_bool_t;
}
extern "C" {
    #[doc = " Read the next field of the map (or stream, although this function is not preferred for streams).\n\n For a map, this returns the next field in the map, including the name of\n the field. This allows the application to iterate over the contents of the\n map.\n\n While this function will work for a stream, it is preferable to use\n solClient_container_getField or solClient_container_getXXX for a specific\n field type. If this routine is used, a NULL pointer is returned for the\n field name if the provided pointer to the field name is not NULL.\n\n If the returned field is a container (map or stream), the container should\n later be closed by a call to ::solClient_container_closeMapStream(). However, if it is not,\n the container is automatically closed when the associated message is freed through a call to\n ::solClient_msg_free(), or if the parent container is closed.\n If the container is closed automatically, the application may not continue\n to use the container. Attempting to use a closed container\n will return an invalid pointer error (::SOLCLIENT_SUBCODE_PARAM_NULL_PTR).\n\n  @param container_p  An opaque container pointer.\n  @param field_p      The address of solClient_field_t where the API will return\n                      field type and value.\n  @param fieldSize    sizeof(solClient_field_t). This parameter is used for backwards binary\n                      compatibility if solClient_field_t grows.\n  @param name_p       The address of the pointer where API will return a pointer to\n                        the NULL-terminated field name. For a stream, the\n                        passed in pointer can be NULL, and if not, the returned\n                        pointer will be NULL.\n\n  @returns            ::SOLCLIENT_OK on success, ::SOLCLIENT_FAIL on failure.\n                      ::SOLCLIENT_EOS at end of container.\n  @subcodes\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_getNextField(
        container_p: solClient_opaqueContainer_pt,
        field_p: *mut solClient_field_t,
        fieldSize: usize,
        name_p: *mut *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Get a field value from the map or stream.\n For a map, the name pointer must not be NULL, and the field corresponding to\n the name is returned.\n For a stream, the name pointer must be NULL. The next field in the stream is\n extracted, and the read position in the stream is advanced.\n\n Note that normally the solClient_container_getXXX for a specific type is used,\n instead of solClient_container_getField. However, this function can be used\n to get a named field from a map, or the next field from a stream, without knowing\n its type in advance.\n\n If the returned field is a container (map or stream), the container should\n later be closed by a call to ::solClient_container_closeMapStream(). However, if it is not,\n the container is automatically closed when the associated message is freed through a call to\n ::solClient_msg_free(), or if the parent container is closed.\n If the container is closed automatically, the\n application may not continue to use the container. Attempting to use a closed container\n will return an invalid pointer error (::SOLCLIENT_SUBCODE_PARAM_NULL_PTR).\n\n  @param container_p  An opaque container pointer.\n  @param value        A pointer to a solClient_field_t to receive the returned\n                      type and value.\n  @param fieldSize    sizeof(solClient_field_t). This parameter is used for backwards binary compatibility if solClient_field_t grows.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @returns            ::SOLCLIENT_OK on success, ::SOLCLIENT_EOS on the end of a stream, ::SOLCLIENT_NOT_FOUND if not found in a map, ::SOLCLIENT_FAIL on failure.\n  @subcodes\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_getField(
        container_p: solClient_opaqueContainer_pt,
        value: *mut solClient_field_t,
        fieldSize: usize,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Return the size of the map or stream.\n\n  @param container_p  An opaque container pointer.\n  @param size_p       A pointer to a size_t location where the size is returned.\n\n  @returns            @li  ::SOLCLIENT_OK on success.\n                      @li  ::SOLCLIENT_FAIL if container_p is invalid.\n  @subcodes\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_getSize(
        container_p: solClient_opaqueContainer_pt,
        size_p: *mut usize,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Get a NULL value from the map or stream.\n  Any data type, including maps and streams, can be read as a NULL\n  type.\n  For a map, the name pointer must not be NULL, and the field corresponding to\n  the name is returned.\n  For a stream, the name pointer must be NULL. The next field in the stream is\n  extracted and the read position in the stream is advanced.\n\n  @param container_p  An opaque container pointer.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @returns            @li ::SOLCLIENT_OK on success.\n                      @li ::SOLCLIENT_EOS on the end of a stream.\n                      @li ::SOLCLIENT_NOT_FOUND if not found in a map.\n                      @li ::SOLCLIENT_FAIL on failure. This function can\n                      fail if any of the parameters to the call are\n                      invalid.\n  @subcodes\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_getNull(
        container_p: solClient_opaqueContainer_pt,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Get a Boolean value from the map or stream.\n  For a map, the name pointer must not be NULL, and the field corresponding to\n  the name is returned.\n  For a stream, the name pointer must be NULL. The next field in the stream is\n  extracted and the read position in the stream is advanced.\n\n  @param container_p  An opaque container pointer.\n  @param value        A pointer to a Boolean, it contains binary 0 or 1\n                      on successful return.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @returns            @li ::SOLCLIENT_OK on success.\n                      @li ::SOLCLIENT_EOS on the end of a stream.\n                      @li ::SOLCLIENT_NOT_FOUND if not found in a map.\n                      @li ::SOLCLIENT_FAIL on failure. This function can\n                      fail if the referenced field cannot be converted to\n                      Boolean, or if any of the parameters to the call are\n                      invalid.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_INVALID_DATA_CONVERSION\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_getBoolean(
        container_p: solClient_opaqueContainer_pt,
        value: *mut solClient_bool_t,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Get an unsigned 8-bit int from the map or stream.\n  For a map, the name pointer must not be NULL, and the field corresponding to\n  the name is returned.\n  For a stream, the name pointer must be NULL. The next field in the stream is\n  extracted and the read position in the stream is advanced.\n\n  @param container_p  An opaque container pointer.\n  @param value        A pointer to a unsigned 8-bit int.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @returns            @li ::SOLCLIENT_OK on success.\n                      @li ::SOLCLIENT_EOS on the end of a stream.\n                      @li ::SOLCLIENT_NOT_FOUND if not found in a map.\n                      @li ::SOLCLIENT_FAIL on failure. This function can\n                      fail if the referenced field cannot be converted to an\n                      unsigned 8-bit int, or if any of the parameters to the\n                      call are invalid.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_INVALID_DATA_CONVERSION\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_getUint8(
        container_p: solClient_opaqueContainer_pt,
        value: *mut solClient_uint8_t,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Get a signed 8-bit int from the map or stream.\n  For a map, the name pointer must not be NULL, and the field corresponding to\n  the name is returned.\n  For a stream, the name pointer must be NULL. The next field in the stream is\n  extracted and the read position in the stream is advanced.\n\n  @param container_p  An opaque container pointer.\n  @param value        A pointer to a signed 8-bit int.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @returns            @li ::SOLCLIENT_OK on success.\n                      @li ::SOLCLIENT_EOS on the end of a stream.\n                      @li ::SOLCLIENT_NOT_FOUND if not found in a map.\n                      @li ::SOLCLIENT_FAIL on failure. This function can\n                      fail if the referenced field cannot be converted to a\n                      signed 8-bit int or if any of the parameters to the\n                      call are invalid.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_INVALID_DATA_CONVERSION\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_getInt8(
        container_p: solClient_opaqueContainer_pt,
        value: *mut solClient_int8_t,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Get an unsigned 16-bit int from the map or stream.\n  For a map, the name pointer must not be NULL, and the field corresponding to\n  the name is returned.\n  For a stream, the name pointer must be NULL. The next field in the stream is\n  extracted and the read position in the stream is advanced.\n\n  @param container_p  An opaque container pointer.\n  @param value        A pointer to an unsigned 16-bit int.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @returns            @li ::SOLCLIENT_OK on success.\n                      @li ::SOLCLIENT_EOS on the end of a stream.\n                      @li ::SOLCLIENT_NOT_FOUND if not found in a map.\n                      @li ::SOLCLIENT_FAIL on failure. This function can\n                      fail if the referenced field cannot be converted to an\n                      unsigned 16-bit int or if any of the parameters to the\n                      call are invalid.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_INVALID_DATA_CONVERSION\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_getUint16(
        container_p: solClient_opaqueContainer_pt,
        value: *mut solClient_uint16_t,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Get a signed 16-bit int from the map or stream.\n  For a map, the name pointer must not be NULL, and the field corresponding to\n  the name is returned.\n  For a stream, the name pointer must be NULL. The next field in the stream is\n  extracted and the read position in the stream is advanced.\n\n  @param container_p  An opaque container pointer.\n  @param value        A pointer to a signed 16-bit int.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @returns            @li ::SOLCLIENT_OK on success.\n                      @li ::SOLCLIENT_EOS on the end of a stream.\n                      @li ::SOLCLIENT_NOT_FOUND if not found in a map.\n                      @li ::SOLCLIENT_FAIL on failure. This function can\n                      fail if the referenced field cannot be converted to a\n                      signed 16-bit int or if any of the parameters to the\n                      call are invalid.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_INVALID_DATA_CONVERSION\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_getInt16(
        container_p: solClient_opaqueContainer_pt,
        value: *mut solClient_int16_t,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Get an unsigned 32-bit int from the map or stream.\n  For a map, the name pointer must not be NULL, and the field corresponding to\n  the name is returned.\n  For a stream, the name pointer must be NULL. The next field in the stream is\n  extracted and the read position in the stream is advanced.\n\n  @param container_p  An opaque container pointer.\n  @param value        A pointer to an unsigned 32-bit int.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @returns            @li ::SOLCLIENT_OK on success\n                      @li ::SOLCLIENT_EOS on the end of a stream\n                      @li ::SOLCLIENT_NOT_FOUND if not found in a map\n                      @li ::SOLCLIENT_FAIL on failure. This function can\n                      fail if the referenced field cannot be converted to an\n                      unsigned 32-bit int, or if any of the parameters to the call are invalid.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_INVALID_DATA_CONVERSION\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_getUint32(
        container_p: solClient_opaqueContainer_pt,
        value: *mut solClient_uint32_t,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Get a signed 32-bit int from the map or stream.\n  For a map, the name pointer must not be NULL, and the field corresponding to\n  the name is returned.\n  For a stream, the name pointer must be NULL. The next field in the stream is\n  extracted and the read position in the stream is advanced.\n\n  @param container_p  An opaque container pointer.\n  @param value        A pointer to a signed 32-bit int.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @returns            @li ::SOLCLIENT_OK on success.\n                      @li ::SOLCLIENT_EOS on the end of a stream.\n                      @li ::SOLCLIENT_NOT_FOUND if not found in a map.\n                      @li ::SOLCLIENT_FAIL on failure. This function can\n                      fail if the referenced field cannot be converted to a\n                      signed 32-bit int or if any of the parameters to the\n                      call are invalid.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_INVALID_DATA_CONVERSION\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_getInt32(
        container_p: solClient_opaqueContainer_pt,
        value: *mut solClient_int32_t,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Get an unsigned 64-bit int from the map or stream.\n  For a map, the name pointer must not be NULL, and the field corresponding to\n  the name is returned.\n  For a stream, the name pointer must be NULL. The next field in the stream is\n  extracted and the read position in the stream is advanced.\n\n  @param container_p  An opaque container pointer.\n  @param value        A pointer to an unsigned 64-bit int.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @returns            @li ::SOLCLIENT_OK on success.\n                      @li ::SOLCLIENT_EOS on the end of a stream.\n                      @li ::SOLCLIENT_NOT_FOUND if not found in a map.\n                      @li ::SOLCLIENT_FAIL on failure. This function may\n                      fail if the referenced field cannot be converted to an\n                      unsigned 64 bit int, or if any of the parameters to the\n                      call are invalid.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_INVALID_DATA_CONVERSION\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_getUint64(
        container_p: solClient_opaqueContainer_pt,
        value: *mut solClient_uint64_t,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Get a signed 64-bit int from the map or stream.\n  For a map, the name pointer must not be NULL, and the field corresponding to\n  the name is returned.\n  For a stream, the name pointer must be NULL. The next field in the stream is\n  extracted, and the read position in the stream is advanced.\n\n  @param container_p  An opaque container pointer.\n  @param value        A pointer to a signed 64-bit int.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @returns            @li ::SOLCLIENT_OK on success.\n                      @li ::SOLCLIENT_EOS on the end of a stream.\n                      @li ::SOLCLIENT_NOT_FOUND if not found in a map.\n                      @li ::SOLCLIENT_FAIL on failure. This function can\n                      fail if the referenced field cannot be converted to a\n                      signed 64-bit int or if any of the parameters to the\n                      call are invalid.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_INVALID_DATA_CONVERSION\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_getInt64(
        container_p: solClient_opaqueContainer_pt,
        value: *mut solClient_int64_t,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Get an ASCII character from the map or stream.\n  For a map, the name pointer must not be NULL, and the field corresponding to\n  the name is returned.\n  For a stream, the name pointer must be NULL. The next field in the stream is\n  extracted and the read position in the stream is advanced.\n\n  @param container_p  An opaque container pointer.\n  @param value        A pointer to a char.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @returns            @li ::SOLCLIENT_OK on success.\n                      @li ::SOLCLIENT_EOS on the end of a stream.\n                      @li ::SOLCLIENT_NOT_FOUND if not found in a map.\n                      @li ::SOLCLIENT_FAIL on failure. This function can\n                      fail if the referenced field cannot be converted to an\n                      ASCII char, or if any of the parameters to the\n                      call are invalid.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_INVALID_DATA_CONVERSION\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_getChar(
        container_p: solClient_opaqueContainer_pt,
        value: *mut ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Get a unicode character from the map or stream.\n  For a map, the name pointer must not be NULL, and the field corresponding to\n  the name is returned.\n  For a stream, the name pointer must be NULL. The next field in the stream is\n  extracted and the read position in the stream is advanced.\n\n  @param container_p  An opaque container pointer.\n  @param value        A pointer to a unicode character.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @returns            @li ::SOLCLIENT_OK on success.\n                      @li ::SOLCLIENT_EOS on the end of a stream.\n                      @li ::SOLCLIENT_NOT_FOUND if not found in a map.\n                      @li ::SOLCLIENT_FAIL on failure. This function can\n                      fail if the referenced field cannot be converted to a\n                      unicode char, or if any of the parameters to the\n                      call are invalid.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_INVALID_DATA_CONVERSION\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_getWchar(
        container_p: solClient_opaqueContainer_pt,
        value: *mut solClient_wchar_t,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Get a pointer to a byte array from the map or stream.\n  For a map, the name pointer must not be NULL, and the field corresponding to\n  the name is returned.\n  For a stream, the name pointer must be NULL. The next field in the stream is\n  extracted and the read position in the stream is advanced.\n\n  @param container_p  An opaque container pointer.\n  @param array_p      The address where the pointer to a byte array is returned.\n  @param arrayLength_p The returned array length.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @returns            @li ::SOLCLIENT_OK on success.\n                      @li ::SOLCLIENT_EOS on the end of a stream.\n                      @li ::SOLCLIENT_NOT_FOUND if not found in a map.\n                      @li ::SOLCLIENT_FAIL on failure. This function can\n                      fail if the referenced field is not a byte array,\n                      or if any of the parameters to the\n                      call are invalid.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_INVALID_DATA_CONVERSION\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_getByteArrayPtr(
        container_p: solClient_opaqueContainer_pt,
        array_p: *mut *mut solClient_uint8_t,
        arrayLength_p: *mut solClient_uint32_t,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Get the contents of a byte array from the map or stream.\n  For a map, the name pointer must not be NULL, and the field corresponding to\n  the name is returned.\n  For a stream, the name pointer must be NULL. The next field in the stream is\n  extracted, and the read position in the stream is advanced.\n\n  @param container_p  An opaque container pointer.\n  @param array_p      A pointer to where the byte array is returned\n  @param arrayLength_p  The IN/OUT maximum length of array.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n\n  @returns            @li ::SOLCLIENT_OK on success.\n                      @li ::SOLCLIENT_EOS on the end of a stream.\n                      @li ::SOLCLIENT_NOT_FOUND if not found in a map.\n                      @li ::SOLCLIENT_FAIL on failure. This function can\n                      fail if the referenced field is not a byte array\n                      or if any of the parameters to the\n                      call are invalid.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_INVALID_DATA_CONVERSION\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_getByteArray(
        container_p: solClient_opaqueContainer_pt,
        array_p: *mut solClient_uint8_t,
        arrayLength_p: *mut solClient_uint32_t,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Get a pointer to a Solace Message Format (SMF) message from the map or stream.\n  For a map, the name pointer must not be NULL, and the field corresponding to\n  the name is returned.\n  For a stream, the name pointer must be NULL. The next field in the stream is\n  extracted, and the read position in the stream is advanced.\n\n  @param container_p  An opaque container pointer.\n  @param smf_p        An address where a pointer to a byte array is returned\n  @param smfLength_p  The returned array length.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @returns            @li ::SOLCLIENT_OK on success.\n                      @li ::SOLCLIENT_EOS on the end of a stream.\n                      @li ::SOLCLIENT_NOT_FOUND if not found in a map.\n                      @li ::SOLCLIENT_FAIL on failure. This function can\n                      fail if the referenced field is not a byte array,\n                      or if any of the parameters to the\n                      call are invalid.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_INVALID_DATA_CONVERSION\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_getSmfPtr(
        container_p: solClient_opaqueContainer_pt,
        smf_p: *mut *mut solClient_uint8_t,
        smfLength_p: *mut solClient_uint32_t,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Get contents of a Solace Message Format (SMF) message from the map or stream.\n  For a map, the name pointer must not be NULL, and the field corresponding to\n  the name is returned.\n  For a stream, the name pointer must be NULL. The next field in the stream is\n  extracted and the read position in the stream is advanced.\n\n  @param container_p  An opaque container pointer.\n  @param smf_p      A pointer to where the byte array is returned\n  @param smfLength_p  The IN/OUT maximum length of array.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @returns            @li ::SOLCLIENT_OK on success\n                      @li ::SOLCLIENT_EOS on the end of a stream\n                      @li ::SOLCLIENT_NOT_FOUND if not found in a map\n                      @li ::SOLCLIENT_FAIL on failure. This function can\n                      fail if the referenced field is not a byte array,\n                      or if any of the parameters to the\n                      call are invalid.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_INVALID_DATA_CONVERSION\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_getSmf(
        container_p: solClient_opaqueContainer_pt,
        smf_p: *mut solClient_uint8_t,
        smfLength_p: *mut solClient_uint32_t,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Get a float from the map or stream.\n  For a map, the name pointer must not be NULL, and the field corresponding to\n  the name is returned.\n  For a stream, the name pointer must be NULL. The next field in the stream is\n  extracted and the read position in the stream is advanced.\n\n  @param container_p  An opaque container pointer.\n  @param value        A pointer to a float value.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @returns            @li ::SOLCLIENT_OK on success.\n                      @li ::SOLCLIENT_EOS on the end of a stream.\n                      @li ::SOLCLIENT_NOT_FOUND if not found in a map.\n                      @li ::SOLCLIENT_FAIL on failure. This function can\n                      fail if the referenced field cannot be converted to a\n                      32-bit floating point int, or if any of the parameters to the\n                      call are invalid.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_INVALID_DATA_CONVERSION\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_getFloat(
        container_p: solClient_opaqueContainer_pt,
        value: *mut f32,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Get a double from the map or stream.\n  For a map, the name pointer must not be NULL, and the field corresponding to\n  the name is returned.\n  For a stream, the name pointer must be NULL. The next field in the stream is\n  extracted, and the read position in the stream is advanced.\n\n  @param container_p  An opaque container pointer.\n  @param value        A pointer to a double.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @returns            @li ::SOLCLIENT_OK on success.\n                      @li ::SOLCLIENT_EOS on the end of a stream.\n                      @li ::SOLCLIENT_NOT_FOUND if not found in a map.\n                      @li ::SOLCLIENT_FAIL on failure. This function can\n                      fail if the referenced field cannot be converted to a\n                      64-bit floating point int, or if any of the parameters to the\n                      call are invalid.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_INVALID_DATA_CONVERSION\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_getDouble(
        container_p: solClient_opaqueContainer_pt,
        value: *mut f64,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Get a null terminated string from the map or stream.\n  For a map, the name pointer must not be NULL, and the field corresponding to\n  the name is returned.\n  For a stream, the name pointer must be NULL. The next field in the stream is\n  extracted, and the read position in the stream is advanced.\n\n  @param container_p  An opaque container pointer.\n  @param string       An address of pointer to a string location.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @returns            @li ::SOLCLIENT_OK on success\n                      @li ::SOLCLIENT_EOS on the end of a stream.\n                      @li ::SOLCLIENT_NOT_FOUND if not found in a map.\n                      @li ::SOLCLIENT_FAIL on failure. This function can\n                      fail if the referenced field is not a string,\n                      or if any of the parameters to the\n                      call are invalid.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_INVALID_DATA_CONVERSION\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_getStringPtr(
        container_p: solClient_opaqueContainer_pt,
        string: *mut *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Copy a null terminated string from the map or stream.\n  For a map, the name pointer must not be NULL, and the field corresponding to\n  the name is returned.\n  For a stream, the name pointer must be NULL. The next field in the stream is\n  extracted, and the read position in the stream is advanced.\n\n  @param container_p  An opaque container pointer.\n  @param string       A pointer to a string location.\n  @param size         A maximum length of string.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @returns            @li ::SOLCLIENT_OK on success.\n                      @li ::SOLCLIENT_EOS on the end of a stream.\n                      @li ::SOLCLIENT_NOT_FOUND if not found in a map.\n                      @li ::SOLCLIENT_FAIL on failure. This function can\n                      fail if the referenced field is not a string\n                      int or if any of the parameters to the\n                      call are invalid.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_INVALID_DATA_CONVERSION\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_getString(
        container_p: solClient_opaqueContainer_pt,
        string: *mut ::std::os::raw::c_char,
        size: usize,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Get a destination.\n  For a map, the name pointer must not be NULL, and the field corresponding to\n  the name is returned.\n  For a stream, the name pointer must be NULL. The next field in the stream is\n  extracted and the read position in the stream is advanced.\n\n  If the field is a destination, this function copies the destination\n  information to the supplied 'destination' structure. Within the destination is a pointer\n  to the destination name (a string within the message). This string is only valid as\n  long as the solClient_msg is valid.\n\n  @param container_p  An opaque container pointer.\n  @param value        A pointer to a solClient_destination_t.\n  @param destSize     sizeof(solClient_destination_t). This parameter is used for backwards binary compatibility if solClient_destination_t changes in the future.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @returns            @li ::SOLCLIENT_OK on success.\n                      @li ::SOLCLIENT_EOS on the end of a stream.\n                      @li ::SOLCLIENT_NOT_FOUND if not found in a map.\n                      @li ::SOLCLIENT_FAIL on failure. This function can\n                      fail if the referenced field does not contain a\n                      destination, or if any of the parameters to the\n                      call are invalid.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_INVALID_DATA_CONVERSION\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_getDestination(
        container_p: solClient_opaqueContainer_pt,
        value: *mut solClient_destination_t,
        destSize: usize,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Get a container pointer for the SubMap found in the current\n container.\n For a map, the name pointer must not be NULL, and the field corresponding to\n the name is returned.\n For a stream, the name pointer must be NULL. The next field in the stream is\n extracted, and the read position in the stream is advanced.\n\n The returned map should later be closed by a call to\n ::solClient_container_closeMapStream(). However, if it is not, the map\n is automatically closed when the associated message is freed through a call to\n ::solClient_msg_free(). If the map is closed automatically, the\n application may not continue to use the map. Attempting to use a closed map\n will return an invalid pointer error (::SOLCLIENT_SUBCODE_PARAM_NULL_PTR).\n\n  @param container_p  An opaque container pointer.\n  @param value        A pointer to a container pointer.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @returns            @li ::SOLCLIENT_OK on success.\n                      @li ::SOLCLIENT_EOS on the end of a stream.\n                      @li ::SOLCLIENT_NOT_FOUND if not found in a map.\n                      @li ::SOLCLIENT_FAIL on failure. This function can\n                      fail if the referenced field is not a map\n                      or if any of the parameters to the\n                      call are invalid.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_INVALID_DATA_CONVERSION\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_getSubMap(
        container_p: solClient_opaqueContainer_pt,
        value: *mut solClient_opaqueContainer_pt,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Get a container pointer for the SubStream found in the current\n container.\n For a map, the name pointer must not be NULL, and the field corresponding to\n the name is returned.\n For a stream, the name pointer must be NULL. The next field in the stream is\n extracted and the read position in the stream is advanced.\n\n The returned stream should later be closed by a call to\n ::solClient_container_closeMapStream(). However, if it is not, the stream\n is automatically closed when the associated message is freed through a call to\n ::solClient_msg_free(). If the stream is closed automatically, the\n application may not continue to use the stream. Attempting to use a closed stream\n will return an invalid pointer error (::SOLCLIENT_SUBCODE_PARAM_NULL_PTR).\n\n  @param container_p  An opaque container pointer.\n  @param value        A pointer to a container pointer.\n  @param name         The name of a field for a map. This parameter must be NULL for a stream.\n\n  @returns            @li ::SOLCLIENT_OK on success.\n                      @li ::SOLCLIENT_EOS on the end of a stream.\n                      @li ::SOLCLIENT_NOT_FOUND if not found in a map.\n                      @li ::SOLCLIENT_FAIL on failure. This function can\n                      fail if the referenced field is not a stream,\n                      or if any of the parameters to the\n                      call are invalid.\n  @subcodes\n  @li ::SOLCLIENT_SUBCODE_INVALID_DATA_CONVERSION\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_getSubStream(
        container_p: solClient_opaqueContainer_pt,
        value: *mut solClient_opaqueContainer_pt,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = "  Remove a field from a map. This function returns an error if called on\n  a stream. The serialized map is scanned and the named field is removed.\n  All subsequent fields in the serialized map are moved; this can be a slow\n  operation.\n\n  @param container_p  An opaque container pointer.\n  @param name         The name of the field to remove.\n\n  @returns            @li ::SOLCLIENT_OK on success\n                      @li ::SOLCLIENT_FAIL on failure. This function can\n                      fail if any of the parameters to the\n                      call are invalid.\n  @subcodes\n  @see ::solClient_subCode for a description of all subcodes."]
    pub fn solClient_container_deleteField(
        container_p: solClient_opaqueContainer_pt,
        name: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Create an initialized message block from the passed in serialized (or raw)\n SMF message. A solClient message buffer is allocated. Applications\n are responsible for releasing the message buffer.\n\n @param bufinfo_p   A pointer to the bufInfo describing a validly formatted SMF direct message.\n @param msg_p       Pointer to a reference to a message. This value is set\n                    on successful return to a msg_p suitable for subsequent function calls.\n                    The message buffer has to be freed by applications on successful return.\n @returns           ::SOLCLIENT_OK or ::SOLCLIENT_FAIL\n"]
    pub fn solClient_msg_decodeFromSmf(
        bufinfo_p: solClient_bufInfo_pt,
        msg_p: *mut solClient_opaqueMsg_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Encode a message in Solace Message Format (SMF) and save the SMF encodings in\n the message bufinfo part.\n If both bufinfo_p and datab_p are not NULL pointers, they contain\n the bufinfo for the SMF encodings and its associated data block as returns.\n Client applications are responsible for releasing the associated data block.\n\n It returns SOLCLIENT_FAIL if one of bufinfo_p and datab_p is NULL pointer and the other is not a NULL pointer.\n\n @param msg_p    A pointer to the message\n @param bufinfo_p       A pointer to a bufInfo containing buffer information (ptr, size).as returns.\n @param datab_p         A pointer to a data block reference returns data block pointer.The data block has to be released by applications.\n @returns              ::SOLCLIENT_OK or ::SOLCLIENT_FAIL"]
    pub fn solClient_msg_encodeToSMF(
        msg_p: solClient_opaqueMsg_pt,
        bufinfo_p: solClient_bufInfo_pt,
        datab_p: *mut solClient_opaqueDatablock_pt,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Get message priority.\n\n @param msg_p    A pointer to the message\n @param priority_p   A pointer to memory that contains priority on return, or -1 if it is not set.\n @returns              ::SOLCLIENT_OK or ::SOLCLIENT_FAIL"]
    pub fn solClient_msg_getPriority(
        msg_p: solClient_opaqueMsg_pt,
        priority_p: *mut solClient_int32_t,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Set message priority.\n\n @param msg_p    A pointer to the message\n @param priority Priority value. The valid value range is 0-255 with 0 as the lowest priority and 255 as the highest, or -1 to delete priority.\n @returns              ::SOLCLIENT_OK or ::SOLCLIENT_FAIL"]
    pub fn solClient_msg_setPriority(
        msg_p: solClient_opaqueMsg_pt,
        priority: solClient_int32_t,
    ) -> solClient_returnCode_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct solClient_replicationGroupMessageId {
    pub replicationGroupMessageId: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_solClient_replicationGroupMessageId() {
    const UNINIT: ::std::mem::MaybeUninit<solClient_replicationGroupMessageId> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<solClient_replicationGroupMessageId>(),
        16usize,
        concat!("Size of: ", stringify!(solClient_replicationGroupMessageId))
    );
    assert_eq!(
        ::std::mem::align_of::<solClient_replicationGroupMessageId>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(solClient_replicationGroupMessageId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).replicationGroupMessageId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(solClient_replicationGroupMessageId),
            "::",
            stringify!(replicationGroupMessageId)
        )
    );
}
pub type solClient_replicationGroupMessageId_pt = *mut solClient_replicationGroupMessageId;
extern "C" {
    #[doc = " Validate a Replication Group Message Id\n\n @param rgmid_p       A pointer to a ::solClient_replicationGroupMessageId_t. The\n                      object must have been previously initialized by either\n                      ::solClient_msg_getReplicationGroupMessageId() or\n                      ::solClient_replicationGroupMessageId_fromString()\n @returns             ::SOLCLIENT_OK or ::SOLCLIENT_FAIL"]
    pub fn solClient_replicationGroupMessageId_isValid(
        rgmid_p: solClient_replicationGroupMessageId_pt,
    ) -> solClient_bool_t;
}
extern "C" {
    #[doc = " Compare two Replication Group Message Id.  Not all valid ::solClient_replicationGroupMessageId_t\n can be compared.  If the messages identified were not published to the same broker or HA pair, then\n they are not comparable and this method returns ::SOLCLIENT_FAIL\n\n @param rgmid1_p      A pointer to the first ::solClient_replicationGroupMessageId_t\n @param rgmid2_p      A pointer to the second ::solClient_replicationGroupMessageId_t\n @param compare_p     A pointer to an integer for the result which is:\n                              *compare_p < 0 if first is less than the second\n                              *compare_p == 0 if both are the same.\n                              *compare_p >0 if the first is greater than the second.\n @returns             ::SOLCLIENT_OK on success.  ::SOLCLIENT_FAIL if the Replication Group\n                      Message Id cannot be compared.\n @subcodes            ::SOLCLIENT_SUBCODE_MESSAGE_ID_NOT_COMPARABLE"]
    pub fn solClient_replicationGroupMessageId_compare(
        rgmid1_p: solClient_replicationGroupMessageId_pt,
        rgmid2_p: solClient_replicationGroupMessageId_pt,
        compare_p: *mut ::std::os::raw::c_int,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Convert a Replication Group Message Id to a defined string format.  The standard\n format can be stored for later use in ::solClient_replicationGroupMessageId_fromString.\n\n @param rgmid_p       A pointer to ::solClient_replicationGroupMessageId_t to serialize.\n @param size_rgmid    The return from sizeof(solClient_replicationGroupMessageId_t)\n @param str           Pointer to string location to copy the string into.\n @param size_str      The available memory for the string. It should be at least 45 bytes\n                      for the standard string: rmid1:xxxxx-xxxxxxxxxxx-xxxxxxxx-xxxxxxxx\n                      If there is not enough room the output is truncated.\n\n @returns             ::SOLCLIENT_OK or ::SOLCLIENT_FAIL"]
    pub fn solClient_replicationGroupMessageId_toString(
        rgmid_p: solClient_replicationGroupMessageId_pt,
        size_rgmid: usize,
        str_: *mut ::std::os::raw::c_char,
        size_str: usize,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Create a Replication Group Message Id from the string format.  The string may be\n retrieved by a call to ::solClient_replicationGroupMessageId_toString, or it can be retrieved\n from any of the broker admin interfaces.\n\n @param rgmid_p       A pointer to ::solClient_replicationGroupMessageId_t to be filled.\n @param size_rgmid    The return from sizeof(solClient_replicationGroupMessageId_t)\n @param rgmid_str     Pointer to string representation of the Replication Group MessageId.\n\n @returns             ::SOLCLIENT_OK or ::SOLCLIENT_FAIL"]
    pub fn solClient_replicationGroupMessageId_fromString(
        rgmid_p: solClient_replicationGroupMessageId_pt,
        size_rgmid: usize,
        rgmid_str: *const ::std::os::raw::c_char,
    ) -> solClient_returnCode_t;
}
extern "C" {
    #[doc = " Retrieve a Replication Group Message Id from a received message.\n\n @param msg_p         solClient_opaqueMsg_pt that is received in a receive message callback.\n @param rgmid_p       A pointer to ::solClient_replicationGroupMessageId_t to be filled.\n @param size          The return from sizeof(solClient_replicationGroupMessageId_t)\n\n @returns             ::SOLCLIENT_OK or ::SOLCLIENT_FAIL or ::SOLCLIENT_NOT_FOUND"]
    pub fn solClient_msg_getReplicationGroupMessageId(
        msg_p: solClient_opaqueMsg_pt,
        rgmid_p: solClient_replicationGroupMessageId_pt,
        size: usize,
    ) -> solClient_returnCode_t;
}
